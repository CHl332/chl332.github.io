<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/10/12/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>在计算机网络的基本概念中，分层次的体系结构是  基本的。计算机网络体系结</p><p>构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。</p><h2 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h2><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则， 比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 </p><h2 id="为什么要对网络协议分层？"><a href="#为什么要对网络协议分层？" class="headerlink" title="为什么要对网络协议分层？"></a>为什么要对网络协议分层？</h2><ul><li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 </li><li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受 影响。 </li><li>易于实现和维护。 </li><li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li></ul><p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。 为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提 出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI&#x2F;RM，简称为OSI。 </p><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用， TCP&#x2F;IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP&#x2F;IP 是一个四 层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字 是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP&#x2F;IP 只 有上面的三层，因为下面的网络接口层并没有什么具体内容，因此在学习计 算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用 一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方 便，也可把底下两层称为网络接口层。 </p><ul><li>四层协议，五层协议和七层协议的关系如下： </li><li>TCP&#x2F;IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接 口层。 </li><li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。 </li><li>OSI七层协议模型主要包括是：应用层（Application）、表示层 （Presentation）、会话层（Session）、运输层（Transport）、网络层 （Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p><img src="/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p><p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是  TCP&#x2F;IP 四层体系结构。 </p><h1 id="TCP-x2F-IP-四层体系结构。-TCP-x2F-IP-协议族"><a href="#TCP-x2F-IP-四层体系结构。-TCP-x2F-IP-协议族" class="headerlink" title="TCP&#x2F;IP 四层体系结构。 TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 四层体系结构。 TCP&#x2F;IP 协议族</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应 用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和 交互的规则。 </p><p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域 名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等 等。 </p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通 用的数据传输服务。应用进程利用该服务传送应用层报文。 运输层主要使用一下两种协议 </p><ol><li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。 </li><li>用户数据协议-UDP：提供无连接的，尽大努力的数据传输服务（不 保证数据传输的可靠性）。</li></ol><table><thead><tr><th>UDP</th><th>TCP</th><th></th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传 输，不使 用流量控 制和拥塞 控制</td><td>可靠传 输，使用 流量控制 和拥塞控 制</td></tr><tr><td>连接对象 个数</td><td>支持一对 一，一对 多，多对 一和多对 多交互通 信</td><td>只能是一 对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节 流</td></tr><tr><td>首部开销</td><td>首部开销 小，仅8字 节</td><td>首部小 20字节， 大60字 节</td></tr><tr><td>场景</td><td>适用于实 时应用 （IP电 话、视频会议、直 播等）</td><td>适用于要 求可靠传 输的应 用，例如 文件传输</td></tr></tbody></table><p>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协 议之一： </p><p>运行在TCP协议上的协议： </p><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>，主要用于普通浏 览。 </li><li><strong>HTTPS（HTTP over SSL，安全超文本传输协议）</strong>,HTTP协议的安全版本。 </li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong>，用于文件传输。 </li><li><strong>POP3（Post Office Protocol, version 3，邮局协议）</strong>，收邮件用。 </li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</strong>，用来发送电子 邮件。 </li><li><strong>TELNET（Teletype over the Network，网络电传）</strong>，通过一个终端 （terminal）登陆到网络。 </li><li><strong>SSH（Secure Shell，用于替代安全性差的TELNET）</strong>，用于加密安全登陆用。 运行在UDP协议上的协议： </li><li><strong>BOOTP（Boot Protocol，启动协议）</strong>，应用于无盘设备。 </li><li><strong>NTP（Network Time Protocol，网络时间协议）</strong>，用于网络同步。 </li><li><strong>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</strong>，动态 配置IP地址。 运行在TCP和UDP协议上： </li><li><strong>DNS（Domain Name Service，域名服务）</strong>，用于完成地址查找，邮件转发等 工作。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时 传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和 包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫  IP 数据报 ，简称数据报。 </p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连 接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol） 和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 </p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总 是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 </p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装 成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息 （如同步信息，地址信息，差错控制等）。 </p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特 结束。 </p><p>一般的web应用的通信传输流是这样的：</p><p><img src="/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/web%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt="web应用通信传输流"></p><p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信 息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息 去除。 </p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相 邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的 差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送 比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说， 这个电路好像是看不见的。</p><h2 id="TCP-x2F-IP-协议族"><a href="#TCP-x2F-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h2><p>在互联网使用的各种协议中重要和著名的就是 TCP&#x2F;IP 两个协议。现在人们 经常提到的 TCP&#x2F;IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表 示互联网所使用的整个 TCP&#x2F;IP 协议族。</p><p>![TCP_IP 协议族](20-计算机网络面试题（2020最新版）.assets&#x2F;TCP_IP 协议族.png)</p><blockquote><p>互联网协议套件（英语：Internet Protocol Suite，缩写<strong>IPS</strong>）是一个网络通讯模型， 以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP&#x2F;IP协 议族（英语：<strong>TCP&#x2F;IP Protocol Suite</strong>，或<strong>TCP&#x2F;IP Protocols</strong>），简称<strong>TCP&#x2F;IP</strong>。因为该 协定家族的两个核心协定：<strong>TCP（传输控制协议）和IP（网际协议）</strong>，为该家族中早 通过的标准。 </p></blockquote><p>划重点： </p><p><strong>TCP（传输控制协议）和IP（网际协议）</strong> 是先定义的两个核心协议，所以才统称为<strong>TCP&#x2F;IP协议族</strong></p><h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据 前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服 务端保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问 题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP头部。 </p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连 接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个 链接，通过四次挥手来关闭一个连接。</strong> </p><p>**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。 **</p><h2 id="TCP报文的头部结构"><a href="#TCP报文的头部结构" class="headerlink" title="TCP报文的头部结构"></a>TCP报文的头部结构</h2><p>在了解TCP连接之前先来了解一下TCP报文的头部结构。</p><p><img src="/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/TCP%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="TCP报文头部结构"></p><p>上图中有几个字段需要重点介绍下： </p><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流， 发起方发送数据时对此进行标记。 </p><p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有 效，ack&#x3D;seq+1。 </p><p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如 下： </p><ul><li>ACK：确认序号有效。 </li><li>FIN：释放一个连接。 </li><li>PSH：接收方应该尽快将这个报文交给应用层。 </li><li>RST：重置连接。 </li><li>SYN：发起一个新连接。 </li><li>URG：紧急指针（urgent pointer）有效。</li></ul><p>需要注意的是： </p><ul><li>不要将确认序号ack与标志位中的ACK搞混了。</li><li>确认方ack&#x3D;发起方seq+1，两端配对。</li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的本质是确认通信双方收发数据的能力首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</p><p>于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我 后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。这，就是三次握手，这样说，你理解了吗？</p><p><img src="/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="三次握手"></p><ul><li>第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN&#x3D;1)，序列号seq&#x3D;100。</li><li>第二次握手：服务端收到客户端发过来的报文后，发现SYN&#x3D;1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN&#x3D;1,ACK&#x3D;1)、序列号seq&#x3D;300、确认号ack&#x3D;101(客户端发过来的序列号+1)。</li><li>第三次握手：客户端收到服务端的回复后发现ACK&#x3D;1并且ack&#x3D;101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN&#x3D;1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK&#x3D;1)、ack&#x3D;301(服务端序列号+1)、seq&#x3D;101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK&#x3D;1并且ack&#x3D;301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手的目的是关闭一个连接</p><p><img src="/20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="四次挥手"></p><p>比如客户端初始化的序列号ISA&#x3D;100，服务端初始化的序列号ISA&#x3D;300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p><ul><li>第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN&#x3D;1)、序列号seq&#x3D;1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li><li>第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;1102(客户端FIN报文序列号1101+1)、序列号seq&#x3D;2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li><li>第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN&#x3D;1,ACK&#x3D;1)、确认号和第二次挥手一样ack&#x3D;1102、序列号seq&#x3D;2350(2300+50)。</li><li>第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;2351、序列号seq&#x3D;1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li></ul><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h2><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p><p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进</p><p>行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><h2 id="为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>为什么TCP连接的时候是3次，关闭的时候却是4次？</h2><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和</p><p>FIN报文发给客户端，就是这里多出来了一次)。</p><h2 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h2><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认 ack报文就会重发第三次挥手的报文，这样报文一去一回  长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。什么是HTTP，HTTP 与 HTTPS 的区别</p><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><table><thead><tr><th>区别</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>协议</td><td>运行在   TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份</td><td>身披 SSL(   Secure   Socket   Layer  )外壳的   HTTP，运行于 SSL 上，SSL 运行于   TCP 之  上，  是添加了加密和认证机制的   HTTP。</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>资源消耗</td><td>较少</td><td>由于加解密处理，会消耗更  多的 CPU 和内存资源</td></tr><tr><td>开销</td><td>无需证书</td><td>需要证书，而证书一般需要向认证机构购买</td></tr><tr><td>加密机制</td><td>无</td><td>共享密钥加密和公开密钥加密并用的混合加密机制</td></tr><tr><td>安全性</td><td>弱</td><td>由于加密机制，安全性强</td></tr></tbody></table><h2 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h2><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><p>状态码的类别：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client   Error（客户端错误状态码）服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server   Error（服务器错误状态码）服务器处理请求出错</td></tr></tbody></table><p>常用HTTP状态码：</p><table><thead><tr><th>2XX</th><th>成功（这系列表明请求被正常处理了）</th></tr></thead><tbody><tr><td>200</td><td>OK，表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>204</td><td>No   content，表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial   Content  ，进行范围请求成功</td></tr><tr><td>3XX</td><td>重定向  （表明浏览器要执行特殊处理）</td></tr><tr><td>301</td><td>moved permanently，永久  性重定向，表示资源已被分配了新的 URL</td></tr><tr><td>302</td><td>found，临时性重定向，表示资源临时被分配了新的   URL</td></tr><tr><td>303</td><td>see   other，表示资源存在着另一个 URL，  应使用   GET 方法获取资源  （对于  301&#x2F;302&#x2F;  303响应，几乎所有浏览器都会删除报文主体并  自动用  GET重新请求）</td></tr><tr><td>304</td><td>not   modified ，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td></tr><tr><td>307</td><td>temporary   redirect，临时重定  向，和302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td></tr><tr><td>4XX</td><td>客户端错误</td></tr><tr><td>400</td><td>bad   request，请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized，表示发送的请求需要有通过   HTTP 认证的认证信息</td></tr><tr><td>403</td><td>forbidden  ，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td></tr><tr><td>404</td><td>not   found，表示在服务器上没有找到请求的资源</td></tr><tr><td>5XX</td><td>服务器错误</td></tr><tr><td>500</td><td>internal   sever   error，表  示服务器端在执行请求时发生了错误</td></tr><tr><td>501</td><td>Not   Implemented，表示服务器不支持当前请求所需要的某个功能</td></tr><tr><td>503</td><td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td></tr></tbody></table><h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过</p><p>HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p><p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p><p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p><ul><li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li><li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li><li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li><li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li></ul><p>GET和POST区别</p><p>\1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p><p>\2. Get请求提交的url中的数据 多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p><p>\3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个</p><p>ISO10646字符集。</p><p>\4. Get执行效率却比Post方法好。Get是form提交的默认方法。</p><p>\5. GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h2 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h2><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢什么是HTTP2</p><p>HTTP2 可以提高了网页的性能。</p><p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六</p><p>个），当在请求很多资源的时候，由于队头阻塞当浏览器达到  大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p><p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p><h2 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h2><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p><p>什么是cookie</p><p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p><p>什么是session</p><p>session是依赖Cookie实现的。session是服务器端对象</p><p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默</p><p>认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 </p><p>cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><p>cookie与session区别</p><p> 存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</p><p> 存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点多保存20个cookie，session无此限制</p><p> 占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</p><p>什么是Token</p><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p>Token 是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位 session与token区别</p><ul><li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li><li>session存储在服务器端，token存储在客户端</li><li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li><li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li></ul><h2 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h2><p>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet() 和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p><p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h2><p>在Java Web程序中，Servlet主要负责接收用户请求HttpServletRequest，在 doGet()，doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：</p><ul><li>void init(ServletConfig config) throws ServletException </li><li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</li><li>void destory() </li><li>java.lang.String getServletInfo() </li><li>ServletConfig getServletConfig()</li></ul><p>生命周期：</p><p>Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其 init()方法进行Servlet的初始化；</p><p>请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求</p><p>对应的doGet或doPost等方法；</p><p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet 的destroy()方法。</p><p>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><h2 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p><p>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ol><li><p>手动通过URL传值、隐藏表单传递Session ID。</p></li><li><p>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/19-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/19-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-模型"><a href="#一-模型" class="headerlink" title="一. 模型"></a>一. 模型</h2><h3 id="1-节点"><a href="#1-节点" class="headerlink" title="1. 节点"></a>1. 节点</h3><p>在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认 为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分 构成，则在模型中可以将一个进程划分为多个节点。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>机器宕机：</strong>机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概 率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小 时，一般需要人工介入重启机器。 </p><p><strong>网络异常：</strong>消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分 化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考 虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息 不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可 靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络 通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内 的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。 </p><p><strong>分布式三态：</strong>如果某个节点向另一个节点发起RPC(Remote procedure call) 调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内 容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC  执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分 布式系统的三态。 </p><p><strong>存储数据丢失：</strong>对于有状态节点来说，数据丢失意味着状态丢失，通常只能从 其他节点读取、恢复存储的状态。 </p><p><strong>异常处理原则：</strong>被大量工程实践所检验过的异常处理黄金原则是：任何在设 计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇 到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设 计时不能放过任何异常情况。</p><h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p>副本（replica&#x2F;copy）指在分布式系统中为数据或服务提供的冗余。对于数据副本指 在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从 副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。另一类副本 是服务副本，指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地 存储，其所需数据一般来自其他节点。</p><p>副本协议是贯穿整个分布式系统的理论核心。</p><p><strong>副本一致性</strong></p><p>分布式系统通过副本控制协议，使得从系统外部读取系统内部各个副本的数据在一定 的约束条件下相同，称之为副本一致性(consistency)。副本一致性是针对分布式系统 而言的，不是针对某一个副本而言。</p><ol><li>强一致性(strong consistency)：任何时刻任何用户或节点都可以读到最近 一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最 难以实现的一致性。 </li><li>单调一致性(monotonic consistency)：任何时刻，任何用户一旦读到某个 数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性 是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从 己方视角观察到的一致性，而不会关注其他用户的一致性情况。 </li><li>会话一致性(session consistency)：任何用户在某一次会话内一旦读到某 个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更 旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松 约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户 间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好 对应会话的概念，例如php 中的session 概念。 </li><li>最终一致性(eventual consistency)：最终一致性要求一旦更新成功，各个 副本上的数据最终将达 到完全一致的状态，但达到完全一致状态所需要的时间 不能保障。对于最终一致性系统而言，一个用户只要始终读取某一个副本的数<br>据，则可以实现类似单调一致性的效果，但一旦用户更换读取的副本，则无法 保障任何一致性。 </li><li>弱一致性(week consistency)：一旦某个更新成功，用户无法在一个确定 时间内读到这次更新的值，且即使在某个副本上读到了新的值，也不能保证在 其他副本上可以读到新的值。弱一致性系统一般很难在实际中使用，使用弱一 致性系统需要应用方做更多的工作从而使得系统可用。</li></ol><h2 id="3-衡量分布式系统的指标"><a href="#3-衡量分布式系统的指标" class="headerlink" title="3. 衡量分布式系统的指标"></a>3. 衡量分布式系统的指标</h2><p>性能：系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以 用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能 需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通 常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约， 追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难 提高QPS。 </p><p>可用性：系统的可用性(availability)指系统在面对各种异常时可以正确提供 服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例 来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布 式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。 </p><p>可扩展性：系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模 提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布 式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中 的机器数量线性增长。 </p><p>一致性：分布式系统为了提高可用性，总是不可避免的使用副本的机制，从 而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起 来越简单。</p><h1 id="二-分布式系统原理"><a href="#二-分布式系统原理" class="headerlink" title="二. 分布式系统原理"></a>二. 分布式系统原理</h1><h2 id="4-数据分布方式"><a href="#4-数据分布方式" class="headerlink" title="4. 数据分布方式"></a>4. 数据分布方式</h2><p>所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计 算、存储等问题。单机系统与分布式系统的最大的区别在于问题的规模，即计算、存<br>储的数据量的区别。将一个单机问题使用分布式解决，首先要解决的就是如何将问题 拆解为可以使用多机分布式解决，使得分布式系统中的每台机器负责原问题的一个子 集。由于无论是计算还是存储，其问题输入对象都是数据，所以如何拆解分布式系统 的输入数据成为分布式系统的基本问题。</p><h3 id="哈希方式"><a href="#哈希方式" class="headerlink" title="哈希方式"></a>哈希方式</h3><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/哈希方式.png" alt="哈希方式"></p><p>哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展， 则几乎所有的数据需要被迁移并重新分布。工程中，扩展哈希分布数据的系统时，往 往使得集群规模成倍扩展，按照数据重新计算哈希，这样原本一台机器上的数据只需 迁移一半到另一台对应的机器上即可完成扩展。</p><p>针对哈希方式扩展性差的问题，一种思路是不再简单的将哈希值与机器做除法取模映 射，而是将对应关系作为元数据由专门的元数据服务器管理.同时，哈希值取模个数往 往大于机器个数，这样同一台机器上需要负责多个哈希取模的余数。但需要以较复杂 的机制维护大量的元数据。哈希分布数据的另一个缺点是，一旦某数据特征值的数据 严重不均，容易出现“数据倾斜”（data skew）问题。</p><p>哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据 倾斜”（data skew）问题</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看" alt="数据倾斜（data skew）">\19-分布式面试必会（2020最新版）.assets&#x2F;数据倾斜（data skew）.png)</p><h3 id="按数据范围分布"><a href="#按数据范围分布" class="headerlink" title="按数据范围分布"></a>按数据范围分布</h3><p>按数据范围分布是另一个常见的数据分布式，将数据按特征值的值域范围划分为不同 的区间，使得集群中每台（组）服务器处理不同区间的数据。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/按数据范围分布.png" alt="按数据范围分布"></p><p>工程中，为了数据迁移等负载均衡操作的方便，往往利用动态划分区间的技术，使得 每个区间中服务的数据量尽量的一样多。当某个区间的数据量较大时，通过将区 间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在一个 较为固定的阈值之下。</p><p>一般的，往往需要使用专门的服务器在内存中维护数据分布信息，称这种数据的分布 信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台 计算 机无法独立维护，需要使用多台机器作为元信息服务器。</p><h3 id="按数据量分布"><a href="#按数据量分布" class="headerlink" title="按数据量分布"></a>按数据量分布</h3><p>数据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将 这个文件按照某一较为固定的大小划分为若干数据块（chunk），不同的数据块分布到不同的服务器上。与按数据范围分布数据的方式类似的是，按数据量分布数据也需 要记录数据块的具体分布情况，并将该分布信息作为元数据使用元数据服务器管理。</p><p>由于与具体的数据内容无关，按数据量分布数据的方式一般没有数据倾斜的问题，数 据总是被均匀切分并分布到集群中。当集群需要重新负载均衡时，只需通过迁移数据 块即可完成。集群扩容也没有太大的限制，只需将部分数据库迁移到新加入的机器上 即可以完成扩容。按数据量划分数据的缺点是需要管理较为复杂的元信息，与按范围 分布数据的方式类似，当集群规模较大时，元信息的数据量也变得很大，高效的管理 元信息成为新的课题。</p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>一致性哈希（consistent hashing）是另一个种在工程中使用较为广泛的数据分布方 式。一致性哈希最初在P2P 网络中作为分布式哈希表（DHT）的常用数据分布算法。 一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希 函数的输出值域为一个封闭的环，即哈希函数输出的最大值是最小值的前序。将节点 随机分布到这个环上，每个节点负责处理从自己开始顺时针至下一个节点的全部哈希 值域上的数据。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/一致性哈希.png" alt="一致性哈希"></p><p>使用一致性哈希的方式需要将节点在一致性哈希环上的位置作为元信息加以管理，这 点比直接使用哈希分布数据的方式要复杂。然而，节点的位置信息只于集群中的机器 规模相关，其元信息的量通常比按数据范围分布数据和按数据量分布数据的元信息量 要小很多。</p><p>为此一种常见的改进算法是引入虚节点（virtual node）的概念，系统初始时就创建 许多虚节点，虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功能与基本一致性哈希算法中的节点相同。为每个节点分配 若干虚节点。操作数据时，首先通过数据的哈希值在环上找到对应的虚节点，进而查 找元数据找到对应的真实节点。使用虚节点改进有多个优点。首先，一旦某个节点不 可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节点负载失效节点 的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负 载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。</p><h3 id="副本与数据分布"><a href="#副本与数据分布" class="headerlink" title="副本与数据分布"></a>副本与数据分布</h3><p>分布式系统容错、提高可用性的基本手段就是使用副本。对于数据副本的分布方式主 要影响系统的可扩展性。一种基本的数据副本策略是以机器为单位，若干机器互为副 本，副本机器之间的数据完全相同。这种策略适用于上述各种数据分布方式。其优点 是非常简单，其缺点是恢复数据的效率不高、可扩展性也不高。</p><p>更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段 为单位作为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小 以内。数据段有很多不同的称谓，segment，fragment，chunk，partition 等等。 数据段的选择与数据分布方式直接相关。对于哈希分数据的方式，每个哈希分桶后的 余数可以作为一个数据段，为了控制数据段的大小，常常使得分桶个数大于集群规 模。一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再 硬相关，每台机器都可以负责一定数据段的副本。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/副本与数据分布.png" alt="副本与数据分布"></p><p>一旦副本分布与机器无关，数据丢失后的恢复效率将非常高。这是因为，一旦某台机 器的数据丢失，其上数据段的副本将分布在整个集群的所有机器中，而不是仅在几个 副本机器中，从而可以从整个集群同时拷贝恢复数据，而集群中每台数据源机器都可 以以非常低的资源做拷贝。作为恢复数据源的机器即使都限速1MB&#x2F;s，若有100 台机 器参与恢复，恢复速度也能达到100MB&#x2F;s。再者，副本分布与机器无关也利于集群容错。如果出现机器宕机，由于宕机机器上的副本分散于整个集群，其压力也自然分散 到整个集群。最后，副本分布与机器无关也利于集群扩展。理论上，设集群规模 为N  台机器，当加入一台新的机器时，只需从各台机器上迁移1&#x2F;N – 1&#x2F;N+1 比例的数据 段到新机器即实现了新的负载均衡。由于是从集群中各机器迁移数据，与数据恢复同 理，效率也较高。工程中，完全按照数据段建立副本会引起需要管理的元数据的开销 增大，副本维护的难度也相应增大。一种折中的做法是将某些数据段组成一个数据段 分组，按数据段分组为粒度进行副本管理。这样做可以将副本粒度控制在一个较为合 适的范围内。</p><h3 id="本地化计算"><a href="#本地化计算" class="headerlink" title="本地化计算"></a>本地化计算</h3><p>在分布式系统中，数据的分布方式也深深影响着计算的分布方式。在分布式系统中计 算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不同的物理 机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传 输，此种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将 计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化 计算。本地化计算是计算调度的一种重要优化，其体现了一种重要的分布式调度思 想：“移动数据不如移动计算”。</p><h3 id="数据分布方式的选择"><a href="#数据分布方式的选择" class="headerlink" title="数据分布方式的选择"></a>数据分布方式的选择</h3><p>在实际工程实践中，可以根据需求及实施复杂度合理选择数据分布方式。另外，数据 分布方式是可以灵活组合使用的，往往可以兼备各种方式的优点，收到较好的综合效 果。</p><p>例：数据倾斜问题，在按哈希分数据的基础上引入按数据量分布数据的方式，解决该 数据倾斜问题。按用户id 的哈希值分数据，当某个用户id 的数据量特别大时，该用 户的数据始终落在某一台机器上。此时，引入按数据量分布数据的方式，统计用户的 数据量，并按某一阈值将用户的数据切为多个均匀的数据段，将这些数据段分布到集 群中去。由于大部分用户的数据量不会超过阈值，所以元数据中仅仅保存超过阈值的 用户的数据段分布信息，从而可以控制元数据的规模。这种哈希分布数据方式与按数 据量分布数据方式组合使用的方案，在某真实系统中使用，取得了较好的效果。</p><h2 id="5-基本副本协议"><a href="#5-基本副本协议" class="headerlink" title="5. 基本副本协议"></a>5. 基本副本协议</h2><p>副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可 用性和一致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能 力，从而使得系统具有一定的可用性，同时副本控制协议要能提供一定一致性级别。 由CAP 原理（在2.9 节详细分析）可知，要设计一种满足强一致性，且在出现任何网 络异常时都可用的副本协议是不可能的。为此，实际中的副本控制协议总是在可用 性、一致性与性能等各要素之间按照具体需求折中。</p><p>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化 (decentralized)副本控制协议”。</p><h3 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a>中心化副本控制协议</h3><p>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之 间的一致性。图给出了中心化副本协议的通用架构。中心化副本控制协议的优点是协 议相对较为简单，所有的副本相关的控制交由中心节点完成。并发控制将由中心节点 完成，从而使得一个分布式并发控制问题，简化为一个单机并发控制问题。所谓并发 控制，即多个节点同时需要修改副本数据时，需要解决“写写”、“读写”等并发冲 突。单机系统上常用加锁等方式进行并发控制。对于分布式并发控制，加锁也是一个 常用的方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的锁系统， 会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性依赖于中心化节 点，当中心节点异常或与中心节点通信中断时，系统将失去某些服务（通常至少失去 更新服务），所以中心化副本控制协议的缺点正是存在一定的停服务时间。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/中心化副本控制协议.png" alt="中心化副本控制协议"></p><h3 id="primary-secondary-协议"><a href="#primary-secondary-协议" class="headerlink" title="primary-secondary 协议"></a>primary-secondary 协议</h3><p>在primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作 为primary 副本，除primary 以外的副本都作为secondary 副本。维护primary 副本 的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协调副本的一致 性。</p><p>Primary-secondary 类型的协议一般要解决四大类问题：数据更新流程、数据读取方 式、Primary 副本的确定和切换、数据同步（reconcile）。</p><p>数据更新基本流程 </p><ol><li>数据更新都由primary 节点协调完成。 </li><li>外部节点将更新操作发给primary 节点 </li><li>primary 节点进行并发控制即确定并发更新操作的先后顺序 </li><li>primary 节点将更新操作发送给secondary 节点 </li><li>primary 根据secondary 节点的完成情况决定更新是否成功并将结果返回外 部节点</li></ol><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/数据更新基本流程.png" alt="数据更新基本流程"></p><p>在工程实践中，如果由primary 直接同时发送给其他N 个副本发送数据，则每个  secondary 的更新吞吐受限于primary 总的出口网络带宽，最大为primary 网络出口 带宽的1&#x2F;N。为了解决这个问题，有些系统（例如，GFS），使用接力的方式同步数 据，即primary 将更新发送给第一 个secondary 副本，第一个secondary 副本发送 给第二secondary 副本，依次类推。</p><h3 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a>数据读取方式</h3><p>数据读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以 满足需求。如果需要会话一致性，则可以为副本设置版本号，每次更新后递增版本 号，用户读取副本时验证版本号，从而保证用户读到的数据在会话范围内单调递增。 使用primary-secondary 比较困难的是实现强一致性。</p><ol><li>由于数据的更新流程都是由primary 控制的，primary 副本上的数据一定是 最新的，所以 如果始终只读primary 副本的数据，可以实现强一致性。如果只 读primary 副本，则secondary 副本将不提供读服务。实践中，如果副本不与 机器绑定，而是按照数据段为单位维护副本，仅有primary 副本提供读服务在 很多场景下并不会造出机器资源浪费。</li></ol><p>将副本分散到集群中个，假设primary 也是随机的确定的，那么每台机器上都有一些 数据的primary 副本，也有另一些数据段的secondary 副本。从而某台服务器实际都 提供读写服务。</p><ol><li>由primary 控制节点secondary 节点的可用性。当primary 更新某个 secondary 副本不成功时，primary 将该secondary 副本标记为不可用，从而 用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与 primary 同步数据，当与primary 完成数据同步后，primary 可以副本标记为 可用。这种方式使得所有的可用的副本，无论是primary 还是secondary 都是 可读的，且在一个确定的时间内，某secondary 副本要么更新到与primary 一 致的最新状态，要么被标记为不可用，从而符合较高的一致性要求。这种方式 依赖于一个中心元数据管理系统，用于记录哪些副本可用，哪些副本不可用。 某种意义上，该方式通过降低系统的可用性来提高系统的一致性。</li></ol><h3 id="primary-副本的确定与切换"><a href="#primary-副本的确定与切换" class="headerlink" title="primary 副本的确定与切换"></a>primary 副本的确定与切换</h3><p>在primary-secondary 类型的协议中，另一个核心的问题是如何确定primary 副本， 尤其是在原primary 副本所在机器出现宕机等异常时，需要有某种机制切换primary  副本，使得某个secondary 副本成为新的primary 副本。</p><p>通常的，在primary-secondary 类型的分布式系统中，哪个副本是primary 这一信息 都属于元信息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务 器获取副本的primary 信息，从而进一步执行数据更新流程。</p><p>由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通 常是10 秒级别，这也意味着一旦primary 异常，最多需要10 秒级别的发现时间，系统才能开始primary 的切换，在这10 秒时间内，由于没有primary，系统不能提供更  新服务，如果系统只能读primary 副本，则这段时间内甚至不能提供读服务。从这里 可以看到，primary-backup 类副本协议的最大缺点就是由于primary 切换带来的一 定的停服务时间。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>不一致的secondary 副本需要与primary 进行同步（reconcile）。</p><p>通常不一致的形式有三种：一、由于网络分化等异常，secondary 上的数据落后于 primary 上的数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要 被丢弃。所谓脏数据是由于primary 副本没有进行某一更新操作，而secondary 副本 上反而进行的多余的修改操作，从而造成secondary 副本数据错误。三、secondary  是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。</p><p>对于第一种secondary 数据落后的情况，常见的同步方式是回放primary 上的操作日 志（通常是redo 日志），从而追上primary 的更新进度。对于脏数据的情况，较好 的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也 应该使得产生脏数据的概率降到非常低得情况，从而一旦发生脏数据的情况可以简单 的直接丢弃有脏数据的副本，这样相当于副本没有数据。另外，也可以设计一些基于 undo 日志的方式从而可以删除脏数据。如果secondary 副本完全没有数据，则常见 的做法是直接拷贝primary 副本的数据，这种方法往往比回放日志追更新进度的方法 快很多。但拷贝数据时primary 副本需要能够继续提供更新服务，这就要求primary  副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷 贝完成后使用回放日志的方式追快照形成后的更新操作。</p><h3 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a>去中心化副本控制协议</h3><p>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间 通过平等协商达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务 等问题。 去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当去中心化协议需要实现 强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化协议的效<br>率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类 似专制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影 响较大；去中心化副本控制协议类似民主制度，节点集体协商，效率低下，但个别节 点的异常不会对系统总体造成太大影响。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/去中心化副本控制协议.png" alt="去中心化副本控制协议"></p><h2 id="6-Lease-机制"><a href="#6-Lease-机制" class="headerlink" title="6. Lease 机制"></a>6. Lease 机制</h2><p>Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。</p><h3 id="基于lease-的分布式cache-系统"><a href="#基于lease-的分布式cache-系统" class="headerlink" title="基于lease 的分布式cache 系统"></a>基于lease 的分布式cache 系统</h3><p>基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存 储、维护着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服 务器节点读取、修改其上的元数据。由于系统中各种操作都依赖于元数据，如果每次 读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶 颈。为此，设计一种元数据cache，在各个节点上 cache 元数据信息，从而减少对中 心服务器节点的访问，提高性能。另一方面，系统的正确运行严格依赖于元数据的正 确，这就要求各个节点上cache 的数据始终与中心服务器上的数据一致，cache 中的 数据不能是旧的脏数据。最后，设计的cache 系统要能最大可能的处理节点宕机、网 络中断等异常，最大程度的提高系统的可用性。</p><p>为此，利用lease 机制设计一套cache 系统，其基本原理为如下。中心服务器在向各 节点发送数据时同时向节点颁发一个lease。每个lease 具有一个有效期，和信用卡上 的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如12:00:10，一旦真 实时间超过这个时间点，则lease 过期失效。这样lease 的有效期与节点收到lease 的 时间无关，节点可能收到lease 时该lease 就已经过期失效。这里首先假设中心服务 器与各节点的时钟是同步的，在下节中讨论时钟不同步对lease 的影响。中心服务器 发出的lease 的含义为：在lease 的有效期内，中心服务器保证不会修改对应数据的值。因此，节点收到数据和lease 后，将数据加入本地Cache，一旦对应的lease 超 时，节点将对应的本地cache 数据删除。中心服务器在修改数据时，首先阻塞所有新 的读请求，并等待之前为该数据发出的所有lease 超时过期，然后修改数据的值。<br>基于lease 的cache，客户端节点读取元数据</p><ol><li>判断元数据是否已经处于本地cache 且lease 处于有效期内1.1 是：直接返回 cache 中的元数据1.2 否：向中心服务器节点请求读取元数据信息1.2.1 服务器 收到读取请求后，返回元数据及一个对应的lease 1.2.2 客户端是否成功收到服 务器返回的数据   1.2.2.1 失败或超时：退出流程，读取失败，可重试1.2.2.2 成 功：将元数据与该元数据的lease 记录到内存中，返回元数据 </li><li>基于lease 的cache，客户端节点修改元数据流程2.1 节点向服务器发起修改 元数据请求。2.2 服务器收到修改请求后，阻塞所有新的读数据请求，即接收读 请求，但不返回数据。2.3 服务器等待所有与该元数据相关的lease 超时。2.4  服务器修改元数据并向客户端节点返回修改成功。</li></ol><p>上述机制可以保证各个节点上的cache 与中心服务器上的中心始终一致。这是因为中 心服务器节点在发送数据的同时授予了节点对应的lease，在lease 有效期内，服务器 不会修改数据，从而客户端节点可以放心的在lease 有效期内cache 数据。上述lease  机制可以容错的关键是：服务器一旦 发出数据及lease，无论客户端是否收到，也无 论后续客户端是否宕机，也无论后续网络是否正常，服务器只要等待lease 超时，就 可以保证对应的客户端节点不会再继续cache 数据，从而可以放心的修改数据而不会 破坏cache 的一致性。</p><p>上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一： 服务器在修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止 发出新的lease 从而引起不断有新客户端节点持有lease 并缓存着数据，形成“活 锁”。优化的方法很简单，服务器在进入修改数据流程后，一旦收到读请求则只返回 数据但不颁发lease。从而造成在修改流程执行的过程中，客户端可以读到元数据， 只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的lease 有效 期限选择为已发出的lease 的最大有效期限。这样做，客户端可以继续在服务器进入 修改流程后继续缓存元数据，但服务器的等待所有lease 过期的时间也不会因为颁发 新的lease 而不断延长。</p><p>最后，&#x3D;cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 是 将一份数据保存在多个节点上。但Cache 机制却要简单许多，对于cache 的数据，可 以随时删除丢弃，并命中cache 的后果仅仅是需要访问数据源读取数据；然而副本机 制却不一样，副本是不能随意丢弃的，每失去一个副本，服务质量都在下降，一旦副 本数下降到一定程度，则往往服务将不再可用。</p><h3 id="lease-机制的分析"><a href="#lease-机制的分析" class="headerlink" title="lease 机制的分析"></a>lease 机制的分析</h3><p>lease 的定义：Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发出 lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要lease 不过 期，颁发者一定严守承诺；另一方面，接收方在lease 的有效期内可以使用颁发者的 承诺，但一旦lease 过期，接收方一定不能继续使用颁发者的承诺。</p><p>Lease 机制具有很高的容错能力。首先，通过引入有效期，Lease 机制能否非常好的 容错网络异常。Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发 者发送消息，也不影响lease 的颁发。由于lease 的有效期是一个确定的时间点， lease 的语义与发送lease 的具体时间无关，所以 同一个lease 可以被颁发者不断重 复向接受方发送。即使颁发者偶尔发送lease 失败，颁发者也可以 简单的通过重发的 办法解决。一旦lease 被接收方成功接受，后续lease 机制不再依赖于网络通信，即 使网络完全中断lease 机制也不受影响。再者，Lease 机制能较好的容错节点宕机。 如果颁发者宕机，则宕机的颁发者通常无法改变之前的承诺，不会影响lease 的正确 性。在颁发者机恢复后，如果颁发者恢复出了之前的lease 信息，颁发者可以继续遵 守lease 的承诺。如果颁发者无法恢复lease 信息，则只需等待一个最大的lease 超时 时间就可以使得所有的lease 都失效，从而不破坏lease机制。</p><p>例如上节中的cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢 复后，只需等待一个最大的lease 超时时间，所有节点上的缓存信息都将被清空。对 于接受方宕机的情况，颁发者 不需要做更多的容错处理，只需等待lease 过期失效， 就可以收回承诺，实践中也就是收回之前赋予的权限、身份等。最后，lease 机制不 依赖于存储。颁发者可以持久化颁发过的lease 信息，从而在 宕机恢复后可以使得在 有效期的lease 继续有效。但这对于lease 机制只是一个优化，如之前的分析，即使颁发者没有持久化lease 信息，也可以通过等待一个最大的lease 时间的方式使得之 前所有颁发 的lease 失效，从而保证机制继续有效。</p><p>Lease 机制依赖于有效期，这就要求颁发者和接收者的时钟是同步的。一方面，如果 颁发者的 时钟比接收者的时钟慢，则当接收者认为lease 已经过期的时候，颁发者依 旧认为lease 有效。接收者可以用在lease 到期前申请新的lease 的方式解决这个问 题。另一方面，如果颁发者的时钟比接收 者的时钟快，则当颁发者认为lease 已经过 期的时候，接收者依旧认为lease 有效，颁发者可能将lease 颁发给其他节点，造成 承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者 的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对lease 的有效性的 影响。</p><h3 id="基于lease-机制确定节点状态"><a href="#基于lease-机制确定节点状态" class="headerlink" title="基于lease 机制确定节点状态"></a>基于lease 机制确定节点状态</h3><p>分布式协议依赖于对节点状态认知的全局一致性，即一旦节点Q 认为某个节点 A 异 常，则节点A 也必须认为自己异常，从而节点A 停止作为primary，避免“双主”问 题的出现。解决这种问题有两种思路，第一、设计的分布式协议可以容忍“双主”错 误，即不依赖于对节点状 态的全局一致性认识，或者全局一致性状态是全体协商后的 结果；第二、利用lease 机制。对于第一 种思路即放弃使用中心化的设计，而改用去 中心化设计，超过本节的讨论范畴。下面着重讨论利用 lease 机制确定节点状态。</p><p>由中心节点向其他节点发送lease，若某个节点持有有效的lease，则认为该节点正常 可以提供服 务。用于例2.3.1 中，节点A、B、C 依然周期性的发送heart beat 报告自 身状态，节点Q 收到heart beat 后发送一个lease，表示节点Q 确认了节点A、B、C  的状态，并允许节点在lease 有效期内正常工 作。节点Q 可以给primary 节点一个特 殊的lease，表示节点可以作为primary 工作。一旦节点Q 希望切换新的primary，则 只需等前一个primary 的lease 过期，则就可以安全的颁发新的lease 给新的 primary 节点，而不会出现“双主”问题。</p><p>在实际系统中，若用一个中心节点发送lease 也有很大的风险，一旦该中心节点宕机 或网络异常，则所有的节点没有lease，从而造成系统高度不可用。为此，实际系统 总是使用多个中心节点互为副本，成为一个小的集群，该小集群具有高可用性，对外 提供颁发lease 的功能。chubby 和zookeeper 都是基于这样的设计。</p><h3 id="lease-的有效期时间选择"><a href="#lease-的有效期时间选择" class="headerlink" title="lease 的有效期时间选择"></a>lease 的有效期时间选择</h3><p>工程中，常选择的lease 时长是10 秒级别，这是一个经过验证的经验值，实践中可以 作为参考并综合选择合适的时长。</p><h2 id="7-Quorum-机制"><a href="#7-Quorum-机制" class="headerlink" title="7. Quorum 机制"></a>7. Quorum 机制</h2><p>先做这样的约定：更新操作（write）是一系列顺序的过程，通过其他机制确定更新操 作的顺序（例如primary-secondary 架构中由primary 决定顺序），每个更新操作记 为wi， i 为更新操作单调递增的序号，每个wi 执行成功后副本数据都发生变化，称为 不同的数据版本，记 作vi。假设每个副本都保存了历史上所有版本的数据。</p><h3 id="write-all-read-one"><a href="#write-all-read-one" class="headerlink" title="write-all-read-one"></a>write-all-read-one</h3><p>Write-all-read-one（简称WARO）是一种最简单的副本控制规则，顾名思义即在更 新时写所有的副本，只有在所有的副本上更新成功，才认为更新成功，从而保证所有 的副本一致，这样在读取数据时可以读任一副本上的数据。</p><p>由于更新操作需要在所有的N 个副本上都成功，更新操作才能成 功，所以一旦有一 个副本异常，更新操作失败，更新服务不可用。对于更新服务，虽然有N 个副本，  但系统无法容忍任何一个副本异常。另一方面，N 个副本中只要有一个副本正常，系 统就可以提供读服务。对于读服务而言，当有N 个副本时，系统可以容忍N-1 个副本 异常。从上述分析可以发现WARO 读服务的可用性较高，但更新服务的可用性不 高，甚至虽然使用了副本，但更新服务的可用性等效于没有副本。</p><h3 id="Quorum-定义"><a href="#Quorum-定义" class="headerlink" title="Quorum 定义"></a>Quorum 定义</h3><p>在Quorum 机制下，当某次更新操作wi 一旦在所有N 个副本中的W 个副本上都成 功，则就称 该更新操作为“成功提交的更新操作”，称对应的数据为“成功提交的数 据”。令R&gt;N-W，由于更新 操作wi 仅在W 个副本上成功，所以在读取数据时，最 多需要读取R 个副本则一定能读到wi 更新后 的数据vi 。如果某次更新wi 在W 个副本 上成功，由于W+R&gt;N，任意R 个副本组成的集合一定与 成功的W个副本组成的集合有交集，所以读取R 个副本一定能读到wi 更新后的数据vi。如图 2-10， Quorum 机 制的原理可以文森图表示。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看" alt="Quorum 定义">\19-分布式面试必会（2020最新版）.assets&#x2F;Quorum 定义.png)</p><p>某系统有5 个副本，W&#x3D;3，R&#x3D;3，最初5 个副本的数据一致，都是v1，某次更新操作  w2 在前3 副本上成功，副本情况变成（v2 v2 v2 v1 v1）。此时，任意3 个副本组成 的集合中一定包括 v2。在上述定义中，令W&#x3D;N，R&#x3D;1，就得到WARO，即WARO  是Quorum 机制的一种特例。与分析WARO 相似，分析Quorum 机制的可用性。限 制Quorum 参数为W+R&#x3D;N+1。由于更新 操作需要在W 个副本上都成功，更新操作 才能成功，所以一旦N-W+1 个副本异常，更新操作始终无法在W 个副本上成功，更 新服务不可用。另一方面，一旦N-R+1 个副本异常，则无法保证一定可以读到与W  个副本有交集的副本集合，则读服务的一致性下降。</p><p>再次强调：仅仅依赖quorum 机制是无法保证强一致性的。因为仅有quorum 机制时 无法确定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的 元数据服务器或元数据集群管理，否则很难确定最新成功提交的版本号。在下一节 中，将讨论在哪些情况下，可以仅仅 通过quorum 机制来确定最新成功提交的版本号。</p><p>Quorum 机制的三个系统参数N、W、R 控制了系统的可用性，也是系统对用户的服 务承诺：数据最多有N 个副本，但数据更新成功W 个副本即返回用户成功。对于一 致性要求较高的Quorum 系统，系统还应该承诺任何时候不读取未成功提交的数据， 即读取到的数据都是曾经在W 个副本上成功的数据。</p><h3 id="读取最新成功提交的数据"><a href="#读取最新成功提交的数据" class="headerlink" title="读取最新成功提交的数据"></a>读取最新成功提交的数据</h3><p>Quorum 机制只需成功更新N 个副本中的W 个，在读取R 个副本时，一定可以读到 最新的成功提交的数据。但由于有不成功的更新情况存在，仅仅读取R 个副本却不一 定能确定哪个版本的数据 是最新的已提交的数据。对于一个强一致性Quorum 系 统，若存在个数据少于W 个，假设为X 个，则继续读取其他副本，直若成功读取到W  个 该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满 足W 个，则R 中版本号第二大的为最新的成功提交的副本。例：在读取 到（v2 v1 v1）时，继续读取剩余的副本，若读到剩余两个副本 为（v2 v2）则v2 是 最新的已提交的副本；若读到剩余的两个副本为（v2 v1）或（v1 v1）则v1 是最新 成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最 新的成功提交的版本。</p><p>可以看出，在单纯使用Quorum 机制时，若要确定最新的成功提交的版本，最多需要 读取R+ （W-R-1）&#x3D;N 个副本，当出现任一副本异常时，读最新的成功提交的版本 这一功能都有可能不可用。实际工程中，应该尽量通过其他技术手段，回避通过 Quorum 机制读取最新的成功提交的版本。例如，当quorum 机制与primarysecondary 控制协议结合使用时，可以通过读取primary 的方式读取到最新的已提交 的数据。</p><h3 id="基于Quorum-机制选择primary副本"><a href="#基于Quorum-机制选择primary副本" class="headerlink" title="基于Quorum 机制选择primary副本"></a>基于Quorum 机制选择primary副本</h3><p>读取数据时依照一致性要求的不同可以有不同的做法：如果需要强一致性的立刻读取 到最新的成功提交的数据，则可以简单的只读取primary 副本上的数据即可，也可以 通过上节的方式读取；如果需要会话一致性，则可以根据之前已经读到的数据版本号 在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副本读取。</p><p>在primary-secondary 协议中，当primary 异常时，需要选择出一个新的primary， 之后secondary 副本与primary 同步数据。通常情况下，选择新的primary 的工作是 由某一中心节点完成的，在引入 quorum 机制后，常用的primary 选择方式与读取 数据的方式类似，即中心节点读取R 个副本，选择 R 个副本中版本号最高的副本作为 新的primary。新primary 与至少W 个副本完成数据同步后作为新的primary 提供读 写服务。首先，R 个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。再 者，虽然不能确定最高版本号的数是一个成功提交的数据，但新的primary 在随后与 secondary 同 步数据，使得该版本的副本个数达到W，从而使得该版本的数据成为 成功提交的数据。</p><p>例：在N&#x3D;5，W&#x3D;3，R&#x3D;3 的系统中，某时刻副本最大版本号为（v2 v2 v1 v1  v1），此时v1 是系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。假设此刻原primary 副本异常，中心节点进行primary 切换工作。这 类“中间态”数据究竟作为“脏数据”被删除，还是作为新的数据被同步后成为生效 的数据，完全取决于这个数据能否参与新primary 的选举。下面分别分析这两种情 况。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看" alt="基于Quorum 机制选择primary副本1">\19-分布式面试必会（2020最新版）.assets&#x2F;基于Quorum 机制选择primary副本1.png)</p><p>第一、如图 2-12，若中心节点与其中3 个副本通信成功，读取到的版本号为（v1 v1  v1），则任 选一个副本作为primary，新primary 以v1 作为最新的成功提交的版本 并与其他副本同步，当与第1、第2 个副本同步数据时，由于第1、第2 个副本版本号 大于primary，属于脏数据，可以按照2.2.2.4 节中介绍的处理脏数据的方式解决。实 践中，新primary 也有可能与后两个副本完成同步后就提供数据服务，随后自身版本 号也更新到v2，如果系统不能保证之后的v2 与之前的v2 完全一样，则新 primary 在 与第1、2 个副本同步数据时不但要比较数据版本号还需要比较更新操作的具体内容 是否一样。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看" alt="基于Quorum 机制选择primary副本2">\19-分布式面试必会（2020最新版）.assets&#x2F;基于Quorum 机制选择primary副本2.png)</p><p>第二、若中心节点与其他3 个副本通信成功，读取到的版本号为（v2 v1 v1），则选 取版本号为 v2 的副本作为新的primary，之后，一旦新primary 与其他2 个副本完成 数据同步，则符合v2 的副 本个数达到W 个，成为最新的成功提交的副本，新 primary 可以提供正常的读写服务。</p><h2 id="8-日志技术"><a href="#8-日志技术" class="headerlink" title="8. 日志技术"></a>8. 日志技术</h2><p>日志技术是宕机恢复的主要技术之一。日志技术最初使用在数据库系统中。严格来说 日志技术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志 技术做宕机恢复，甚 至如BigTable 等系统将日志保存到一个分布式系统中进一步增 强了系统容错能力。</p><h3 id="Redo-Log-与Check-point"><a href="#Redo-Log-与Check-point" class="headerlink" title="Redo Log 与Check point"></a>Redo Log 与Check point</h3><p>设计一个高速的单机查询系统，将数据全部存放在内存中以实现高速的数据查询，每 次更新操作更新一小部分数据（例如 key-value 中的某一个key）。现在问题为利用 日志技术实现该内存查询系统的宕机恢复。与数据库的事务不同的是，这个问题模型 中的每个成功的更新操作都会生效。这也等效为数据库的每个事务只有一个更新操 作，且每次更新操作都可以也必须立即提交（Auto commit）。</p><ul><li>Redo Log</li></ul><ol><li>将更新操作的结果（例如Set K1&#x3D;1，则记录K1&#x3D;1）以追加写（append）的 方式写入磁盘的 日志文件 </li><li>按更新操作修改内存中的数据 </li><li>返回更新成功</li></ol><p>从Redo Log 的流程可以看出，Redo 写入日志的是更新操作完成后的结果（虽然本 文不讨论Undo Log，这点是与Undo Log 的区别之一），且由于是顺序追加写日志 文件，在磁盘等对顺序写有力的 存储设备上效率较高。</p><p>用Redo Log 进行宕机恢复非常简单，只需要“回放”日志即可。</p><p>流程2.5.2：Redo Log 的宕机恢复</p><p>从头读取日志文件中的每次更新操作的结果，用这些结果修改内存中的数 据。<br>从Redo Log 的宕机恢复流程也可以看出，只有写入日志文件的更新结果才能在宕机 后恢复。这也是为什么在Redo Log 流程中需要先更新日志文件再更新内存中的数据 的原因。假如先更新内存中的数据，那么用户立刻就能读到更新后的数据，一旦在完 成内存修改与写入日志之间发生宕机，那么最后一次更新操作无法恢复，但之前用户 可能已经读取到了更新后的数据，从而引起不一致的问题。</p><ul><li>Check point</li></ul><p>。在简化的模型下，check point 技术的过程即将内存中的数据以某种易于重新加载 的数据组织方式完整的dump 到磁盘，从而减少宕机恢复时需要回放的日志数据。</p><p>流程：check point</p><ol><li>向日志文件中记录“Begin Check Point” </li><li>将内存中的数据以某种易于重新加载的数据组织方式dump 到磁盘上 </li><li>向日志文件中记录“End Check Point” 在check point 流程中，数据可以 继续按照流程2.5.1 被更新，这段过程中新更新的数据可以dump 到磁盘也可以 不dump 到磁盘，具体取决于实现。例如，check point 开始时k1&#x3D;v1，check  point 过程 中某次更新为k1 &#x3D; v2，那么dump 到磁盘上的k1 的值可以是v1 也 可以是v2。</li></ol><p>流程：基于check point 的宕机恢复流程</p><ol><li>将dump 到磁盘的数据加载到内存。 </li><li>从后向前扫描日志文件，寻找最后一个“End Check Point”日志。 </li><li>从最后一个“End Check Point”日志向前找到最近的一个“Begin Check  Point”日志，并回 放该日志之后的所有更新操作日志。</li></ol><ul><li>No Undo&#x2F;No Redo log</li></ul><p>若数据维护在磁盘中，某批更新由若干个更新操作组成，这些更新操作需要原子生 效，即要么同时生效，要么都不生效。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看" alt="Redo Log 与Check point">\19-分布式面试必会（2020最新版）.assets&#x2F;Redo Log 与Check point.png)</p><p>0&#x2F;1 目录技术中有两个目录结构，称为目录0(Directory 0)和目录1(Directory 1)。另 有一个结构称为主记录（Master record）记录当前正在使用的目录称为活动目录。 主记录中要么记录使用目录0，要么记录使用目录1。目录0 或目录1 中记录了各个数 据的在日志文件中的位置。0&#x2F;1 目录的数据更新过程始终在非活动目录上进行，只是 在数据生效前，将主记录中的0、1 值反转，从而切换主记录。</p><p>流程：0&#x2F;1 目录数据更新流程</p><ol><li>将活动目录完整拷贝到非活动目录。 </li><li>对于每个更新操作，新建一个日志项纪录操作后的值，并在非活动目录中将 相应数据的位置修改为新建的日志项的位置。 </li><li>原子性修改主记录：反转主记录中的值，使得非活动目录生效。</li></ol><p>0&#x2F;1 目录的更新流程非常简单，通过0、1 目录的主记录切换使得一批修改的生效是原 子的。0&#x2F;1 目录将批量事务操作的原子性通过目录手段归结到主记录的原子切换。由 于多条记录的原子修改一般较难实现而单条记录的原子修改往往可以实现，从而降低 了问题实现的难度。在工程中0&#x2F;1 目录的思想运用非常广泛，其形式也不局限在上述 流程中，可以是内存中的两个数据结构来回切换，也可以是磁盘上的两个文件目录来 回生效切换。</p><h2 id="9-两阶段提交协议"><a href="#9-两阶段提交协议" class="headerlink" title="9. 两阶段提交协议"></a>9. 两阶段提交协议</h2><p>两阶段提交协议是一种经典的强一致性中心化副本控制协议。虽然在工程中该协议有 较多的问题，但研究该协议能很好的理解分布式系统的几个典型问题。</p><h3 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a>流程描述</h3><p>两阶段提交协议是一种典型的“中心化副本控制”协议。在该协议中，参与的节点分 为 两 类 ： 一 个 中 心 化 协 调 者 节 点 （ coordinator ） 和 N  个 参 与 者 节 点 （participant）。每个参与者节点即上文背景介绍中的管理数据库副本的节点。</p><p>两阶段提交的思路比较简单，在第一阶段，协调者询问所有的参与者是否可以提交事 务（请参与者投票），所有参与者向协调者投票。在第二阶段，协调者根据所有参与 者的投票结果做出是否事务可以全局提交的决定，并通知所有的参与者执行该决定。 在一个两阶段提交流程中，参与者不能改变自己的投票结果。两阶段提交协议的可以 全局提交的前提是所有的参与者都同意提交事务，只要有一个参与者投票选择放弃 (abort)事务，则事务必须被放弃。</p><p>流程：两阶段提交协调者流程</p><ol><li>写本地日志“begin_commit”，并进入WAIT 状态； </li><li>向所有参与者发送“prepare 消息”； </li><li>等待并接收参与者发送的对“prepare 消息”的响应；3.1 若收到任何一个 参与者发送的“vote-abort 消息”；3.1.1 写本地“global-abort”日志，进 入ABORT；3.1.2 向所有的参与者发送“global-abort 消息”；3.1.3 进入 ABORT 状态；3.2 若收到所有参与者发送的“vote-commit”消息；3.2.1 写 本地“global-commit”日志，进入COMMIT 状态；3.1.2 向所有的参与者发 送“global-commit 消息”； 4. 等待并接收参与者发送的对“global-abort 消息”或“global-commit 消 息”的确认响应消息，一旦收到所有参与者的确认消息，写本 地“end_transaction” 日志流程结束。</li></ol><p>流程：两阶段提交协调者流程</p><ol><li>写本地日志“init”记录，进入INIT 状态 </li><li>等待并接受协调者发送的“prepare 消息”，收到后  2.1 若参与者可以提交 本次事务 2.1.1 写本地日志“ready”，进入READY 状态 2.1.2 向协调者发 送“vote-commit”消息 2.1.4 等待协调者的消息2.1.4.1 若收到协调者 的“global-abort”消息2.1.4.1.1 写本地日志“abort”，进入ABORT 状态 2.1.4.1.2 向协调者发送对“global-abort”的确认消息   2.1.4.2 若收到协调者 的“global-commit”消息2.1.4.1.1 写本地日志“commit”，进入COMMIT  状态     2.1.4.1.2 向协调者发送对“global-commit”的确认消息  2.2 若参与 者无法提交本次事务 2.2.1 写本地日志“abort”，进入ABORT 状态 2.2.2 向协调者发送“vote-abort”消息 2.2.3 流程对该参与者结束 2.2.4 若后续收到 协调者的“global-abort”消息可以响应 </li><li>即使流程结束，但任何时候收到协调者发送的“global-abort”消息 或“global-commit”消息也都要发送一个对应的确认消息。</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>宕机恢复</p><ol><li>协调者宕机恢复 协调者宕机恢复后，首先通过日志查找到宕机前的状态。如 果日志中最后是“begin_commit”记录，说明宕机前协调者处于WAIT 状态， 协调者可能已经发送过“prepare 消息”也可能还没发送，但协调者一定还没 有发送过“global-commit 消息”或“global-abort 消息”，即事务的全局状 态还没有确定。此时，协调者可以重新发送“prepare 消息” 继续两阶段提交 流程，即使参与者已经发送过对“prepare 消息”的响应，也不过是再次重传 之前的响应而不会影响协议的一致性。如果日志中最后是“globalcommit”或“global-abort”记录，说明宕机前协调者处于COMMIT 或 ABORT 状态。此时协调者只需重新向所有的参与者发送“global-commit 消 息”或“global-abort 消息”就可以继续两阶段提交流程。 </li><li>参与者宕机恢复参与者宕机恢复后，首先通过日志查找宕机前的状态。如果 日志中最后是“init”记录，说明参与者处于INIT 状态，还没有对本次事务做 出投票选择，参与者可以继续流程等待协调者发送的“prepare 消息”。如果 日志中最后是“ready”记录，说明参与者处于REDAY 状态，此时说明参与者 已经就本次 事务做出了投票选择，但宕机前参与者是否已经向协调者发 送“vote-commit”消息并不可知。所以此时参与者可以向协调者重发“votecommit”，并继续协议流程。如果日志中最后是“commit”或“abort”记 录，说明参与者已经收到过协调者的“global-commit 消息”（处于COMMIT  状态）或者“global-abort 消息”（处于ABORT 状态）。至于是否向协调者 发 送过对“global-commit”或“global-abort”的确认消息则未知。但即使 没有发送过确认消息，由于协调者会不断重发“global-commit”或“globalabort”，只需在收到这些消息时发送确认消息既可，不影响协议的全局一致 性。</li></ol><h3 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h3><p>两阶段提交协议在工程实践中真正使用的较少，主要原因有以下几点：</p><ol><li>两阶段提交协议的容错能力较差。从上文的分析可以看出，两阶段提交协议 在某些情况下存在流程无法执行下去的情况，且也无法判断流程状态。在工程 中好的分布式协议往往总是可以在即使发生异常的情况下也能执行下去。例 如，回忆Lease 机制（2.3 ），一旦lease 发出，无论出现任何异常，Lease 服 务器节点总是可以通过时间判定出Lease 是否有效，也可以用等待Lease 超时 的方法收回Lease 权限，整个Lease 协议的流程不存在任何流程被阻塞而无法 执行下去的情况。与Lease 机制的简单有效相比，两阶段提交的协议显得较为 复杂且容错能力差。 </li><li>两阶段提交协议的性能较差。一次成功的两阶段提交协议流程中，协调者与 每个参与者 之间至少需要两轮交互4 个消息“prepare”、“votecommit”、“global-commit”、“确认global-commit”。过多的交互次 数会降低性能。另一方面，协调者需要等待所有的参与者的投票结果，一旦存 在较慢的参与者，会影响全局流程执行速度。</li></ol><p>虽然存在一些改进的两阶段提交协议可以提高容错能力和性能，然而这类协议依旧是 在工程中使用较少的一类协议，其理论价值大于实践意义。</p><h2 id="10-MVCC"><a href="#10-MVCC" class="headerlink" title="10. MVCC"></a>10. MVCC</h2><p>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初 也是在数据库系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系 统中同样有效。</p><p>MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成  一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性 读取。在使用MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可 以并行进行，从而可以产生一种图状结构。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/MVCC.png" alt="MVCC"></p><p>基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都各自对数 据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事 务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提 交，生成了数据版 本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合 并，如果数据没有冲突，即事务 B 没有修改事务A 与事务C 修改过的变量，那么事务 B 可以提交，否则事务B 提交失败。MVCC 的流程过程非常类似于SVN 等版本控制 系统的流程，或者说SVN 等版本控制系统就是 使用的MVCC 思想。事务在基于基础 数据版本做本地修改时，为了不影响真正的数据，通常有两种做法，一是将基础数据 版本中的数据完全拷贝出来再修改，SVN 即使用了这种方法，SVN check out 即是 拷贝的过程；二是每个事务中只记录更新操作，而不记录完整的数据，读取数据时再 将更新操作应用到用基础版本的数据从而计算出结果，这个过程也类似SVN 的增量提 交。</p><h2 id="11-Paxos协议"><a href="#11-Paxos协议" class="headerlink" title="11. Paxos协议"></a>11. Paxos协议</h2><p>Paxos 协议是少数在工程实践中证实的强一致性、高可用的去中心化分布式协议。 Paxos 协议的流程较为复杂，但其基本思想却不难理解，类似于人类社会的投票过程。Paxos 协议中，有一组完全对等的参与节点（称为accpetor），这组节点各自就某一事件做出决议，如果某个决议获得了超过半数节点的同意则生效。Paxos 协议中只要有超过一半的节点正常，就可以工作，能很好对抗宕机、网络分化等异常情况。</p><p>角色</p><p>Proposer：提案者。Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为value。不同的 Proposer 可以提出不同的甚至矛盾的value，例如某个Proposer 提议“将变量X 设置为1”，另一个Proposer 提议“将变量X 设置为2”，但对同一轮Paxos 过程，最多只有一个value 被批准。Acceptor：批准者。Acceptor 有N 个，Proposer 提出的value 必须获得超过半数(N&#x2F;2+1)的Acceptor 批准后才能通过。Acceptor 之间完全对等独立。Learner：学习者。Learner 学习被批准的value。所谓学习就是通过读取各个Proposer 对value 的选择结果，如果某个value 被超过半数Proposer 通过，则Learner 学习到了这个value。回忆（2.4 ） 不难理解，这里类似Quorum 机制，某个value 需要获得W&#x3D;N&#x2F;2 + 1 的Acceptor 批准，从而学习者需要至少读取N&#x2F;2+1 个Accpetor，至多读取N 个Acceptor 的结果后，能学习到一个通过的value。上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。</p><p>流程</p><p>Paxos 协议一轮一轮的进行，每轮都有一个编号。每轮Paxos 协议可能会批准一个 value，也可 能无法批准一个value。如果某一轮Paxos 协议批准了某个value，则以后各轮Paxos 只能批准这个 value。上述各轮协议流程组成了一个Paxos 协议实例，即一次Paxos 协议实例只能批准一个value，这也是Paxos 协议强一致性的重要体现。每轮Paxos 协议分为阶段，准备阶段和批准阶段，在这两个阶段Proposer 和 Acceptor 有各自的处理流程。</p><p>流程：Proposer 的流程 （准备阶段）</p><ol><li>向所有的Acceptor 发送消息“Prepare(b)”；这里b 是Paxos 的轮数，每</li></ol><p>轮递增</p><ol start="2"><li><p>如果收到任何一个Acceptor 发送的消息“Reject(B)”，则对于这个 Proposer 而言本轮Paxos 失败，将轮数b 设置为B+1 后重新步骤1；（批准阶段，根据收到的Acceptor 的消息作出不同选择）</p></li><li><p>如果接收到的Acceptor 的“Promise(b, v_i)”消息达到N&#x2F;2+1 个（N 为 Acceptor 总数，除法取整， 下同）；v_i 表示Acceptor 最近一次在i 轮批准过 value v。3.1 如果收到的“Promise(b, v)”消息中，v 都为空，Proposer 选择一个value v，向所有Acceptor 广播Accept(b, v)；3.2 否则，在所有收到的“Promise(b, v_i)”消息中，选择i 最大的value v，向所有Acceptor 广播消息Accept(b，v)；</p></li><li><p>如果收到Nack(B)，将轮数b 设置为B+1 后重新步骤1；流程：Accpetor 流程 （准备阶段）</p></li><li><p>接受某个Propeser 的消息Prepare(b)。参数B 是该Acceptor 收到的最大</p></li></ol><p>Paxos 轮数编号；V 是Acceptor 批准的value，可以为空 1.1 如果b&gt;B，回复 Promise(b, V_B)，设置B&#x3D;b; 表示保证不再接受编号小于b 的提案。1.2 否则，回复Reject(B) （批准阶段）</p><ol start="2"><li>接收Accept(b, v)， 2.1 如果b &lt; B, 回复Nack(B)，暗示proposer 有一个更大编号的提案被这个Acceptor 接收了 2.2 否则设置V&#x3D;v。表示这个Acceptor 批准的Value 是v。广播Accepted 消息。</li></ol><p>例子</p><p>基本例子里有5 个Acceptor，1 个Proposer，不存在任何网络、宕机异常。我们着重考察各个Accpetor 上变量B 和变量V 的变化，及Proposer 上变量b 的变化。</p><ol><li>初始状态</li></ol><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/初始状态.jpg" alt="初始状态"></p><ol start="2"><li>Proposer 向所有Accpetor 发送“Prepare(1)”，所有Acceptor 正确处理，并回复Promise(1, NULL</li></ol><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/2.jpg" alt="2"></p><ol start="3"><li>Proposer 收到5 个Promise(1, NULL)，满足多余半数的Promise 的value 为空，此时发送 Accept(1, v1)，其中v1 是Proposer 选择的Value。</li></ol><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\19-分布式面试必会（2020最新版）.assets/3.jpg" alt="3"></p><ol start="4"><li>此时，v1 被超过半数的Acceptor 批准，v1 即是本次Paxos 协议实例批准的</li></ol><p>Value。如果Learner 学习value，学到的只能是v1</p><p>在同一个Paxos 实例中，批准的Value 是无法改变的，即使后续Proposer 以更高的序号发起Paxos 协议也无法改变value。Paxos 协议的核心就在于“批准的value 无法改变”，这也是整个协议正确性的基础。</p><p>Paxos 协议是被人为设计出来，其设计过程也是协议的推导过程。Paxos 协议利用了 Quorom 机 制，选择的W&#x3D;R&#x3D;N&#x2F;2+1。简单而言，协议就是Proposer 更新 Acceptor 的过程，一旦某个Acceptor 成功更新了超过半数的Acceptor，则更新成功。Learner 按Quorum 去读取Acceptor，一旦某个value 在超过半数的Proposer 上被成功读取，则说明这是一个被批准的value。协议通过引入轮次，使得高轮次的提议抢占低轮次的提议来避免死锁。协议设计关键点是如何满足“在一次Paxos 算法实例过程中只批准一个Value”这一约束条件。</p><h2 id="12-CAP"><a href="#12-CAP" class="headerlink" title="12. CAP"></a>12. CAP</h2><p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性：</p><ul><li>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4 ）；</li><li>Availiablity(可用性)：指系统在出现异常时已经可以提供服务；</li><li>Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2 ）这种异常情 况进行容错处理；</li></ul><p>CAP 理论指出：无法设计一种分布式协议，使得同时完全具备CAP 三个属性，即1) 该种协议下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统协议只能在CAP 这三者间所有折中。热力学第二定律说明了永动机是不可能存在的，不要去妄图设计永动机。与之类似， CAP 理论的意义就在于明确提出了不要去妄图设计一种对CAP 三大属性都完全拥有的完美系统，因为这种系统在理论上就已经被证明不存在。</p><ul><li><p>Lease 机制: Lease 机制牺牲了部分异常情况下的A，从而获得了完全的C 与很好的P。</p></li><li><p>Quorum 机制: Quorum 机制，在CAP 三大因素中都各做了折中，有一定的C，有较好 的A，也有较好的P，是一种较为平衡的分布式协议。</p></li><li><p>两阶段提交协议: 两阶段提交系统具有完全的C，很糟糕的A，很糟糕的P。</p></li><li><p>Paxos 协议：同样是强一致性协议，Paxos 在CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的C，较好的A，较好的P。Paxos 的A 与P 的属性与Quorum 机制类似，因为Paxos 的协议本 身就具有Quorum 机制的因素。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/18-Spring%20Cloud%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/18-Spring%20Cloud%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么需要学习Spring-Cloud"><a href="#为什么需要学习Spring-Cloud" class="headerlink" title="为什么需要学习Spring Cloud"></a>为什么需要学习Spring Cloud</h1><p>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</p><p> 代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；</p><p> 开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；</p><p> 排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。</p><p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring </p><p>Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p><h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h1 id="设计目标与优缺点"><a href="#设计目标与优缺点" class="headerlink" title="设计目标与优缺点"></a>设计目标与优缺点</h1><p>设计目标</p><p>协调各个微服务，简化分布式系统开发。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring </p><p>Cloud的呢？</p><p>优点：</p><ul><li>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</li><li>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</li><li>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率可以更精准的制定优化服务方案，提高系统的可维护性减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发微服务可以是跨平台的，可以用任何一种语言开发适于互联网时代，产品迭代周期更短</li></ul><p>缺点：</p><ul><li>微服务过多，治理成本高，不利于维护系统</li><li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</li></ul><h1 id="Spring-Cloud发展前景"><a href="#Spring-Cloud发展前景" class="headerlink" title="Spring Cloud发展前景"></a>Spring Cloud发展前景</h1><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring </p><p>Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>![整体架构](18-Spring Cloud面试题（2020最新版）.assets&#x2F;整体架构.jpg)</p><h1 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring </p><p>Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p><p>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</p><p>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p><p>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</p><p>Zuul：API网关组件，对请求提供路由及过滤功能。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p><p>Spring Cloud Consul</p><p>基于Hashicorp Consul的服务治理组件。</p><p>Spring Cloud Security</p><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p><h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p><h2 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h2><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p><p>Spring Cloud Zookeeper</p><p>基于Apache Zookeeper的服务治理组件。</p><p>Spring Cloud Gateway</p><p>API网关组件，对请求提供路由及过滤功能。</p><h2 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h2><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC 注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p><h1 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h1><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，</p><p>这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布</p><p>内容积累到临界点或者一个重大BUG被解决后，会发布一个”service </p><p>releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的 Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p><h2 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h2><table><thead><tr><th>Spring Cloud   Version</th><th>SpringBo  ot   Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwic h</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><h2 id="Spring-Cloud和各子项目版本对应关系"><a href="#Spring-Cloud和各子项目版本对应关系" class="headerlink" title="Spring Cloud和各子项目版本对应关系"></a>Spring Cloud和各子项目版本对应关系</h2><table><thead><tr><th>More Actions  Compon  ent</th><th>Edgware.  SR6</th><th>Greenwic  h.SR2</th></tr></thead><tbody><tr><td>spring- cloud- bus</td><td>1.3.4.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud-  commons</td><td>1.3.6.RELE    ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud- config</td><td>1.4.7.RELE  ASE</td><td>2.1.3.RELE  ASE</td></tr><tr><td>spring-  cloud-     netflix</td><td>1.4.7.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud- security</td><td>1.2.4.RELE  ASE</td><td>2.1.3.RELE  ASE</td></tr><tr><td>spring- cloud- consul</td><td>1.3.6.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud- sleuth</td><td>1.3.6.RELE  ASE</td><td>2.1.1.RELE  ASE</td></tr><tr><td>spring- cloud- stream</td><td>Ditmars.S  R5</td><td>Fishtown.  SR3</td></tr><tr><td>spring- cloud- zookeepe r</td><td>1.2.3.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring-  boot</td><td>1.5.21.REL  EASE</td><td>2.1.5.RELE  ASE</td></tr><tr><td>spring- cloud- task</td><td>1.2.4.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud- gateway</td><td>1.0.3.RELE  ASE</td><td>2.1.2.RELE  ASE</td></tr><tr><td>spring- cloud- openfeig n</td><td>暂无</td><td>2.1.2.RELE  ASE</td></tr></tbody></table><p>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</p><h1 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h1><p>SpringBoot专注于快速方便的开发单个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p><p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p><h2 id="使用-Spring-Boot-开发分布式微服务时，我们面临以下问题"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临以下问题" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临以下问题"></a>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</h2><p>（1）  与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p><p>（2）  服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p><p>（3）  冗余-分布式系统中的冗余问题。</p><p>（4）  负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p><p>（5）  性能-问题 由于各种运营开销导致的性能问题。</p><p>（6）部署复杂性-Devops 技能的要求。</p><h1 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h1><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><p>Spring Cloud 和dubbo区别?</p><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api （2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是 zookeeper</p><p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合， springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分</p><p>发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p><h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p><h1 id="什么是-Hystrix？它如何实现容错？"><a href="#什么是-Hystrix？它如何实现容错？" class="headerlink" title="什么是 Hystrix？它如何实现容错？"></a>什么是 Hystrix？它如何实现容错？</h1><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p><p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p><p>思考以下微服务</p><p>![Hystrix](18-Spring Cloud面试题（2020最新版）.assets&#x2F;Hystrix.jpg)</p><p>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。</p><p>但这仍然会导致整个系统崩溃。</p><p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.</p><p>这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功</p><p>能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。</p><p>简化图如下所示</p><p>![简化](18-Spring Cloud面试题（2020最新版）.assets&#x2F;简化.jpg)</p><p>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服</p><p>务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p><h1 id="什么是-Hystrix-断路器？我们需要它吗？"><a href="#什么是-Hystrix-断路器？我们需要它吗？" class="headerlink" title="什么是 Hystrix 断路器？我们需要它吗？"></a>什么是 Hystrix 断路器？我们需要它吗？</h1><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p><p>![Hystrix断路器](18-Spring Cloud面试题（2020最新版）.assets&#x2F;Hystrix断路器.jpg)</p><p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员</p><p>工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p><h2 id="什么是-Netflix-Feign？它的优点是什么？"><a href="#什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是 Netflix Feign？它的优点是什么？"></a>什么是 Netflix Feign？它的优点是什么？</h2><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p><p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p><p>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。</p><p>但是我们必须编写大量代码才能执行以下步骤（1）使用功能区进行负载平衡。</p><p>（2）  获取服务实例，然后获取基本 URL。</p><p>（3）  利用 REST 模板来使用服务。 前面的代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1  @Controller</span><br><span class="line">2  public class ConsumerControllerClient &#123;</span><br><span class="line">3  @Autowired</span><br><span class="line">4  private LoadBalancerClient loadBalancer;</span><br><span class="line">5  public void getEmployee() throws RestClientException, IOException &#123;</span><br><span class="line">6   ServiceInstance serviceInstance=loadBalancer.choose(&quot;employee‐ producer&quot;);</span><br><span class="line">7   System.out.println(serviceInstance.getUri());</span><br><span class="line">8   String baseUrl=serviceInstance.getUri().toString();</span><br><span class="line">9   baseUrl=baseUrl+&quot;/employee&quot;;</span><br><span class="line">10   RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">11   ResponseEntity&lt;String&gt; response=null;</span><br><span class="line">12   try&#123;</span><br><span class="line">13   response=restTemplate.exchange(baseUrl,</span><br><span class="line">14   HttpMethod.GET, getHeaders(),String.class);</span><br><span class="line">15   &#125;</span><br><span class="line">16   catch (Exception ex)</span><br><span class="line">17   &#123;</span><br><span class="line">18   System.out.println(ex);</span><br><span class="line">19   &#125;</span><br><span class="line">20   System.out.println(response.getBody());</span><br><span class="line">21  &#125;</span><br></pre></td></tr></table></figure><p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p><h2 id="什么是-Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是-Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是 Spring Cloud Bus？我们需要它吗？"></a>什么是 Spring Cloud Bus？我们需要它吗？</h2><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而</p><p>Spring Cloud Config 从 GIT 读取这些属性。</p><p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p><p>![获取Eureka注册财产](18-Spring Cloud面试题（2020最新版）.assets&#x2F;获取Eureka注册财产.jpg)</p><p>如果假设 GIT 中的 Eureka 注册属性更改(img)为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调</p><p>用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 </p><p>http：&#x2F;&#x2F;localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p><p>![Spring_Bus](18-Spring Cloud面试题（2020最新版）.assets&#x2F;Spring_Bus.jpg)</p><p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模</p><p>块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的刷新。</p><h1 id="Spring-Cloud断路器的作用"><a href="#Spring-Cloud断路器的作用" class="headerlink" title="Spring Cloud断路器的作用"></a>Spring Cloud断路器的作用</h1><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</p><p>关闭：当服务一直处于正常状态 能正常调用</p><h2 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是 config server，二是config client。</p><p>使用：</p><p>（1）  添加pom依赖</p><p>（2）  配置文件添加相关配置</p><p>（3）  启动类添加注解@EnableConfigServer</p><h2 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h2><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul 网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p><p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由</p><p>RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters 是各种过滤器，用来对请求做各种判断和修改。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/17-Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/17-Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h2 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h2><p>Spring Boot 主要有如下优点：</p><ol><li><p>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</p></li><li><p>开箱即用，远离繁琐的配置。</p></li><li><p>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</p></li><li><p>没有代码生成，也不需要XML配置。</p></li><li><p>避免大量的 Maven 导入和各种版本冲突。</p></li></ol><h2 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude </p><p>&#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）  面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以</p><p>充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的</p><p>@Bean 方法等。</p><p>（2）  减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。</p><p>但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从</p><p>技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 </p><p>Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><h2 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）     properties文件；</p><p>2）     YAML文件；</p><p>3）     系统环境变量；</p><p>等等……</p><h2 id="4）命令行参数；-什么是-YAML？"><a href="#4）命令行参数；-什么是-YAML？" class="headerlink" title="4）命令行参数； 什么是 YAML？"></a>4）命令行参数； 什么是 YAML？</h2><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h2 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h2><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li><p>配置有序，在一些特殊的场景下，配置有序很关键</p></li><li><p>支持数组，数组中的元素可以是基本数据类型也可以是对象</p></li><li><p>简洁</p></li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h2 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。 spring boot 核心配置文件是什么？</p><p>bootstrap.properties 和 application.properties 有何区别 ?</p><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文</p><p>件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><p> bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不</p><p>能被覆盖；</p><p> application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p><h2 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h2><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在</p><p>PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h2 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h2><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在</p><p>application.properties 中指定端口。server.port &#x3D; 8090</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h2><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展</p><p>WebSecurityConfigurerAdapter 并覆盖其方法。</p><h2 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h2><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 </p><p>Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 </p><p>Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring </p><p>Security 相比，主要有如下一些特点：</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级</li></ol><p>的安全管理框架</p><ol start="2"><li><p>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</p></li><li><p>Spring Security 功能强大；Shiro 功能简单</p></li></ol><h2 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1  @Configuration</span><br><span class="line">2  public class CorsConfig implements WebMvcConfigurer &#123; 3</span><br><span class="line">4   @Override</span><br><span class="line">5   public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">6   registry.addMapping(&quot;/**&quot;)</span><br><span class="line">7   .allowedOrigins(&quot;*&quot;)</span><br><span class="line">8   .allowCredentials(true)</span><br><span class="line">9   .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)</span><br><span class="line">10   .maxAge(3600);</span><br><span class="line">11   &#125; </span><br><span class="line">12</span><br><span class="line">13  &#125;</span><br></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。</p><p>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。</p><p>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。</p><p>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1  @Configuration</span><br><span class="line">2  public class CorsConfig &#123; 3</span><br><span class="line">4   @Bean</span><br><span class="line">5   public CorsFilter corsFilter() &#123;</span><br><span class="line">6   CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">7   corsConfiguration.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">8   corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">9   corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">10   corsConfiguration.setAllowCredentials(true);</span><br><span class="line">11   UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new U rlBasedCorsConfigurationSource();</span><br><span class="line">12   urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsCo nfiguration);</span><br><span class="line">13   return new CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">14   &#125; </span><br><span class="line">15</span><br><span class="line">16  &#125;</span><br></pre></td></tr></table></figure><h2 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h2><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使 终用户在当前通过身份验证的 Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h2><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问 的REST 端点来检查状态。</p><p>如何在 Spring Boot 中禁用 Actuator 端点安全性？</p><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色</p><p>的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h2 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h2><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h1 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h1><h2 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h2><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、     WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、     WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、     单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、     Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><p>什么是 Spring Data ?</p><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><ol><li><p>MongoDB （文档数据库）</p></li><li><p>Neo4j（图形数据库）</p></li><li><p>Redis（键&#x2F;值存储）</p></li><li><p>Hbase（列族数据库）</p></li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li><p>JDBC</p></li><li><p>JPA</p></li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h2 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h2><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h2 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h2><p>FreeMarker 是一个基于 Java 的模板引擎，  初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。 后使用 freemarker 可以将这些结合起来，给出  终的输出页面。</p><h2 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h2><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h2 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h2><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h2 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h2><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用 少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><p>前后端分离，如何维护接口文档 ?</p><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见</p><p>的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网</p><p>站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到 新的接口文档，非常方便。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h2><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。</p><p>Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员 需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。</p><p>它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;dependency&gt;</span><br><span class="line">2   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">3   &lt;artifactId&gt;spring‐boot‐devtools&lt;/artifactId&gt;</span><br><span class="line">4  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h2><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><p>Spring Boot 中的 starter 到底是什么 ?</p><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration </p><p>，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 </p><p>Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter spring-boot-starter-parent 有什么用 ?</p><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 </p><p>parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li><p>定义了 Java 编译版本为 1.8 。</p></li><li><p>使用 UTF-8 格式编码。</p></li><li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</p></li><li><p>执行打包操作的配置。</p></li><li><p>自动化的资源过滤。</p></li><li><p>自动化的插件配置。</p></li><li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 applicationdev.properties 和 application-dev.yml。</p></li></ol><p>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</p><p>Spring Boot 项目  终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot </p><p>打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><p>1）     打包用命令或者放到容器中运行</p><p>2）     用 Maven&#x2F; Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><h2 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h2><h2 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h2><p>1）     继承spring-boot-starter-parent项目</p><p>2）     导入spring-boot-dependencies项目依赖</p><h2 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h2><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h2 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h2><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><p>微服务中如何实现 session 共享 ?</p><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经</p><p>常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring </p><p>Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Netty-是什么？"><a href="#1-Netty-是什么？" class="headerlink" title="1. Netty 是什么？"></a>1. Netty 是什么？</h2><p>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能 协议服务器和客户端。Netty是基于nio的，它封装了jdk的nio，让我们使用起 来更加方法灵活。 </p><h2 id="2-Netty-特点是什么？"><a href="#2-Netty-特点是什么？" class="headerlink" title="2. Netty 特点是什么？"></a>2. Netty 特点是什么？</h2><ul><li>高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通 信框架，对比于 BIO（Blocking I&#x2F;O，阻塞IO），他的并发性能得到了很大提高。 </li><li>传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了 更高效率的传输。 </li><li>封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li></ul><h2 id="3-Netty-的优势有哪些？"><a href="#3-Netty-的优势有哪些？" class="headerlink" title="3. Netty 的优势有哪些？"></a>3. Netty 的优势有哪些？</h2><ul><li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li><li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li><li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li><li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能优。 </li><li>稳定：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务 本身。 </li><li>社区活跃：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。</li></ul><h2 id="4-Netty-的应用场景有哪些？"><a href="#4-Netty-的应用场景有哪些？" class="headerlink" title="4. Netty 的应用场景有哪些？"></a>4. Netty 的应用场景有哪些？</h2><p>典型的应用有：阿里分布式服务框架 Dubbo，默认使用 Netty 作为基础通信组 件，还有 RocketMQ 也是使用 Netty 作为通讯的基础。 </p><h2 id="5-Netty-高性能表现在哪些方面？"><a href="#5-Netty-高性能表现在哪些方面？" class="headerlink" title="5. Netty 高性能表现在哪些方面？"></a>5. Netty 高性能表现在哪些方面？</h2><ul><li>IO 线程模型：同步非阻塞，用少的资源做更多的事。 </li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li><li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查 找树管理内存分配情况。 </li><li>串形化处理读写：避免使用锁带来的性能开销。</li><li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li></ul><h2 id="6-BIO、NIO和AIO的区别？"><a href="#6-BIO、NIO和AIO的区别？" class="headerlink" title="6. BIO、NIO和AIO的区别？"></a>6. BIO、NIO和AIO的区别？</h2><p>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进 行处理。线程开销大。 </p><p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。 </p><p>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上， 多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。 </p><p>AIO：一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务 器应用去启动线程进行处理， </p><p>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻 塞的；BIO的Stream是单向的，而NIO的channel是双向的。 </p><p>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I&#x2F;O，I&#x2F;O读写不再阻 塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数 zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于 Reactor线程模型。 </p><p>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生， 事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来 做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理 器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理 器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还 控制权。 </p><h2 id="7-NIO的组成？"><a href="#7-NIO的组成？" class="headerlink" title="7. NIO的组成？"></a>7. NIO的组成？</h2><p>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入 Channel中的 </p><p>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就 是切换读写模式 </p><p>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。 </p><p>rewind方法 ： 重绕此缓冲区，将position置为0 </p><p>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁 的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I&#x2F;O 操作影响的大型、持久的缓冲区。如果数据量比较小的 中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。 </p><p>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只 能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都 导致数据复制了两次！ </p><p>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector， register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、 accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和 Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返 回，唤醒的 </p><p>原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高 的事件触发（如定时器事件），希望及时处理。 </p><p>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实 现，其中三个native方法是对epoll的封装，而EPollSelectorImpl.  </p><p>implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文 件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文 件描述符与SelectionKey的映射。 </p><p>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连 接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取 是在select方法中进行的，该方法是非线程安全的。 </p><p>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道 读取 </p><p>NIO的服务端建立过程：Selector.open()：打开一个Selector； </p><p>ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个 端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到 Selector上；select()轮询拿到已经就绪的事件 </p><h2 id="8-Netty的线程模型？"><a href="#8-Netty的线程模型？" class="headerlink" title="8. Netty的线程模型？"></a>8. Netty的线程模型？</h2><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个 线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的 accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read 和write事件，由对应的Handler处理。 </p><p>单线程模型：所有I&#x2F;O操作都由一个线程完成，即多路复用、事件分发和处理都 是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连 接，又要发送&#x2F;读取请求或应答&#x2F;响应消息。一个NIO 线程同时处理成百上千的 链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高 负载、大并发的应用场景不合适。 </p><p>多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和 发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线 程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证 时，一个Acceptor 线程可能会存在性能不足问题。 </p><p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理I&#x2F;O 的读写等操作，从而保证mainReactor只负 责接入认证、握手等操作； </p><h2 id="9-TCP-粘包-x2F-拆包的原因及解决方法？"><a href="#9-TCP-粘包-x2F-拆包的原因及解决方法？" class="headerlink" title="9. TCP 粘包&#x2F;拆包的原因及解决方法？"></a>9. TCP 粘包&#x2F;拆包的原因及解决方法？</h2><p>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发 送，也可能把小的封装成一个大的数据包发送。 </p><p>TCP粘包&#x2F;分包的原因： </p><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应 用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络 上，这将会发生粘包现象； </p><p>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆 包 </p><p>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。 </p><p>解决方法 </p><p>消息定长：FixedLengthFrameDecoder类 </p><p>包尾增加特殊字符分割： </p><ul><li>行分隔符类：LineBasedFrameDecoder</li><li>或自定义分隔符类 ：DelimiterBasedFrameDecoder</li></ul><p>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头 部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘 包。 </p><h2 id="10-什么是-Netty-的零拷贝？"><a href="#10-什么是-Netty-的零拷贝？" class="headerlink" title="10. 什么是 Netty 的零拷贝？"></a>10. 什么是 Netty 的零拷贝？</h2><p>Netty 的零拷贝主要包含三个方面： </p><ul><li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进 行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存 （HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内 存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓 冲区的内存拷贝。 </li><li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操 作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式 将几个小 Buffer 合并成一个大的 Buffer。 </li><li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发 送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li></ul><h1 id="11-Netty-中有哪种重要组件？"><a href="#11-Netty-中有哪种重要组件？" class="headerlink" title="11.Netty 中有哪种重要组件？"></a>11.Netty 中有哪种重要组件？</h1><ul><li>Channel：Netty 网络操作抽象类，它除了包括基本的 I&#x2F;O 操作，如 bind、 connect、read、write 等。</li><li>EventLoop：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。</li><li>ChannelFuture：Netty 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 </li><li>ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li><li>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。</li><li>ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li><li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li></ul><h1 id="12-Netty-发送消息有几种方式？"><a href="#12-Netty-发送消息有几种方式？" class="headerlink" title="12.Netty 发送消息有几种方式？"></a>12.Netty 发送消息有几种方式？</h1><p>Netty 有两种发送消息的方式：</p><ul><li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；</li><li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从ChannelPipeline 中的下一个 ChannelHandler 中移动。</li></ul><h1 id="13-默认情况-Netty-起多少线程？何时启动？"><a href="#13-默认情况-Netty-起多少线程？何时启动？" class="headerlink" title="13.默认情况 Netty 起多少线程？何时启动？"></a>13.默认情况 Netty 起多少线程？何时启动？</h1><p>Netty 默认是 CPU 处理器数的两倍，bind 完之后启动。</p><h1 id="14-了解哪几种序列化协议？"><a href="#14-了解哪几种序列化协议？" class="headerlink" title="14.了解哪几种序列化协议？"></a>14.了解哪几种序列化协议？</h1><p>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差 XML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p><p>JSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p><p>Fastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前 java语言中  快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端</p><p>Thrift，不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案</p><p>Avro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在</p><p>Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p><p>Protobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</p><p>其它</p><p>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</p><p>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</p><p>Message pack 一个高效的二进制序列化格式</p><p>Hessian 采用二进制协议的轻量级remoting onhttp工具</p><p>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</p><h1 id="15-如何选择序列化协议？"><a href="#15-如何选择序列化协议？" class="headerlink" title="15.如何选择序列化协议？"></a>15.如何选择序列化协议？</h1><p>具体场景</p><p>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP 协议是一个值得考虑的方案。</p><p>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</p><p>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</p><p>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</p><p>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</p><p>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</p><p>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</p><p>protobuf的数据类型有多种：bool、double、float、int32、int64、string、 bytes、enum、message。protobuf的限定符：required: 必须赋值，不能为</p><p>空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</p><p>protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</p><p>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</p><p>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder &#x3D; </p><p>UserProto.User.newBuilder();builder.build()；</p><p>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的 UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</p><h1 id="16-Netty-支持哪些心跳类型设置？"><a href="#16-Netty-支持哪些心跳类型设置？" class="headerlink" title="16.Netty 支持哪些心跳类型设置？"></a>16.Netty 支持哪些心跳类型设置？</h1><ul><li>readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）。</li><li>writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）。</li><li>allIdleTime：所有类型的超时时间。</li></ul><h1 id="17-Netty-和-Tomcat-的区别？"><a href="#17-Netty-和-Tomcat-的区别？" class="headerlink" title="17.Netty 和 Tomcat 的区别？"></a>17.Netty 和 Tomcat 的区别？</h1><ul><li>作用不同：Tomcat 是 Servlet 容器，可以视为 Web 服务器，而 Netty 是异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。</li><li>协议不同：Tomcat 是基于 http 协议的 Web 服务器，而 Netty 能通过编程自定义各种协议，因为 Netty 本身自己能编码&#x2F;解码字节流，所有 Netty 可以实现， HTTP 服务器、FTP 服务器、UDP 服务器、RPC 服务器、WebSocket 服务器、 Redis 的 Proxy 服务器、MySQL 的 Proxy 服务器等等。</li></ul><h1 id="18-NIOEventLoopGroup源码？"><a href="#18-NIOEventLoopGroup源码？" class="headerlink" title="18.NIOEventLoopGroup源码？"></a>18.NIOEventLoopGroup源码？</h1><p>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</p><p>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop 类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，   终执行 selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法</p><p>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录 selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量 selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行 rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</p><p>rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将</p><p>old selector的selectionKey执行cancel。   后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</p><p>接下来调用processSelectedKeys 方法（处理I&#x2F;O任务），当selectedKeys !&#x3D; null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ； OP_WRITE；OP_CONNECT事件。</p><p>后调用runAllTasks方法（非IO任务），该方法首先会调用</p><p>fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel 会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</p><p>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个 Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在</p><p>poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page 分割成多段，进行内存分配。</p><p>ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读&#x2F;写模</p><p>式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater 用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</p><h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Netty.png" alt="Netty"></p><p>Netty是 一个异步事件驱动的网络应用程(img)序框架，用于快速开发可维护的高性能协议服务器和客户端。</p><h2 id="JDK原生NIO程序的问题"><a href="#JDK原生NIO程序的问题" class="headerlink" title="JDK原生NIO程序的问题"></a>JDK原生NIO程序的问题</h2><p>JDK原生也有一套网络应用程序API，但是存在一系列问题，主要如下：</p><ul><li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等</li><li>需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序</li><li>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大</li><li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，  终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到</li><li>JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决</li></ul><h2 id="Netty的特点"><a href="#Netty的特点" class="headerlink" title="Netty的特点"></a>Netty的特点</h2><ul><li>Netty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：</li><li>设计优雅 适用于各种传输类型的统一API - 阻塞和非阻塞Socket 基于灵活且可扩展的事件模型，可以清晰地分离关注点 高度可定制的线程模型 - 单线程，一个或多个线程池 真正的无连接数据报套接字支持（自3.1起）</li><li>使用方便 详细记录的Javadoc，用户指南和示例 没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了</li><li>高性能 吞吐量更高，延迟更低 减少资源消耗   小化不必要的内存复制安全 完整的SSL &#x2F; TLS和StartTLS支持</li><li>社区活跃，不断更新 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入</li></ul><h2 id="Netty常见使用场景"><a href="#Netty常见使用场景" class="headerlink" title="Netty常见使用场景"></a>Netty常见使用场景</h2><p>Netty常见的使用场景如下：</p><ul><li>互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC 框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC 框架使用。 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</li><li>游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP&#x2F;UDP和HTTP协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</li><li>大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现有兴趣的读者可以了解一下目前有哪些开源项目使用了 Netty：Related projects</li></ul><h1 id="Netty高性能设计"><a href="#Netty高性能设计" class="headerlink" title="Netty高性能设计"></a>Netty高性能设计</h1><p>Netty作为异步事件驱动的网络，高性能之处主要来自于其I&#x2F;O模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据</p><h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I&#x2F;O模型在很大程度上决定了框架的性能阻塞I&#x2F;O 传统阻塞型I&#x2F;O(BIO)可以用下图表示：<img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/IO%E6%A8%A1%E5%9E%8B.jpg" alt="IO模型"></p><p>特点</p><p> 每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作问题</p><p>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</p><p>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</p><h3 id="I-x2F-O复用模型"><a href="#I-x2F-O复用模型" class="headerlink" title="I&#x2F;O复用模型"></a>I&#x2F;O复用模型</h3><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg" alt="IO复用模型"></p><p>在I&#x2F;O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I&#x2F;O所不同的的，这两个函数可以同时阻塞多个I&#x2F;O操作，而且可以同时对多个读操作，多个写操作的I&#x2F;O函数进行检测，直到有数据可读或可写时，才真正调用</p><p>I&#x2F;O操作函数</p><p>Netty的非阻塞I&#x2F;O的实现关键是基于I&#x2F;O复用模型，这里用Selector对象表示：</p><p>![Nonblocking IO](16-Netty面试题（2020最新版）.assets&#x2F;Nonblocking IO.jpg)</p><p>Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p><p>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I&#x2F;O阻塞导致的线程挂起，一个I&#x2F;O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I&#x2F;O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><h3 id="基于buffer"><a href="#基于buffer" class="headerlink" title="基于buffer"></a>基于buffer</h3><p>传统的I&#x2F;O是面向字节流或字符流的，以流式的方式顺序地从一个Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。</p><p>在NIO中, 抛弃了传统的 I&#x2F;O流, 而是引入了Channel和Buffer的概念. 在NIO中, </p><p>只能从Channel中读取数据到Buffer中或将数据 Buffer 中写入到 Channel。</p><p>基于buffer操作不像传统IO的顺序操作, NIO 中可以随意地读取任意位置的数据线程模型</p><p>数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，线程模型的不同，对性能的影响也非常大。</p><h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>通常，我们设计一个事件处理模型的程序有两种思路</p><p> 轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。</p><p> 事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中观察者模式的思路。</p><p>以GUI的逻辑处理为例，说明两种逻辑的不同：</p><p>轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑</p><p>事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑这里借用O’Reilly 大神关于事件驱动模型解释图</p><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.jpg" alt="事件驱动模型"></p><p>主要包括4个基本组件：</p><ul><li>事件队列（event queue）：接收事件的入口，存储待处理事件</li><li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li><li>事件通道（event channel）：分发器与处理器之间的联系渠道</li><li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li></ul><p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p><ul><li>可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑</li><li>高性能，基于队列暂存事件，能方便并行异步处理事件</li></ul><h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I&#x2F;O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。</p><p>Reactor模型中有2个关键组成：</p><ul><li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li><li>Handlers 处理程序执行I&#x2F;O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I&#x2F;O事件，处理程序执行非阻塞操作</li></ul><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Reactor.jpg" alt="Reactor"></p><p>取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种</p><ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul><p>可以这样理解，Reactor就是一个执行while (true) { selector.select(); …}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。</p><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty主要基于主从Reactors多线程模型（如下图）做了一定的修改，其中主从</p><p>Reactor多线程模型有多个Reactor：MainReactor和SubReactor：</p><p>MainReactor负责客户端的连接请求，并将请求转交给SubReactor SubReactor负责相应通道的IO读写请求</p><p>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进</p><p>行处理</p><p>这里引用Doug Lee大神的Reactor介绍：Scalable IO in Java里面关于主从 Reactor多线程模型的图</p><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="Reactor多线程模型"></p><p>特别说明的是： 虽然Netty的线程模型基于主从Reactor多线程，借用了</p><p>MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker 线程在同一个线程池中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1EventLoopGroup bossGroup =newNioEventLoopGroup();</span><br><span class="line">2EventLoopGroup workerGroup =newNioEventLoopGroup();</span><br><span class="line">3ServerBootstrap server =newServerBootstrap();</span><br><span class="line">4server.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure><ul><li>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，<strong>每个端口对应一个boss线程</strong>   </li><li>workerGroup线程池会被各个SubReactor和worker线程充分利用</li></ul><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><p>Netty中的I&#x2F;O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p><p>当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：</p><ul><li>通过isDone方法来判断当前操作是否完成</li><li>通过isSuccess方法来判断已完成的当前操作是否成功</li><li>通过getCause方法来获取已完成的当前操作失败的原因</li><li>通过isCancelled方法来判断已完成的当前操作是否被取消</li><li>通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器</li></ul><p>例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 serverBootstrap.bind(port).addListener(future ‐&gt; &#123;</span><br><span class="line">2 if (future.isSuccess()) &#123;</span><br><span class="line">3 System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">4 &#125; else &#123;</span><br><span class="line">5 System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">6 &#125;</span><br><span class="line">7 &#125;);</span><br></pre></td></tr></table></figure><p>相比传统阻塞I&#x2F;O，执行I&#x2F;O操作后线程会被阻塞住, 直到操作完成；异步处理的 好处是不会造成线程阻塞，线程在I&#x2F;O操作期间可以执行别的程序，在高并发情 形下会更稳定和更高的吞吐量。</p><h1 id="Netty架构设计"><a href="#Netty架构设计" class="headerlink" title="Netty架构设计"></a>Netty架构设计</h1><p>前面介绍完Netty相关一些理论介绍，下面从功能特性、模块组件、运作过程来介绍Netty的架构设计功能特性</p><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Netty%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7%E5%9B%BE.jpg" alt="Netty功能特性图"></p><ul><li>传输服务 支持BIO和NIO</li><li>容器集成 支持OSGI、JBossMC、Spring、Guice容器</li><li>协议支持 HTTP、Protobuf、二进制、文本、WebSocket等一系列常见协议都支持。 还支持通过实行编码解码逻辑来实现自定义协议</li><li>Core核心 可扩展事件模型、通用通信API、支持零拷贝的ByteBuf缓冲对象</li></ul><p>模块组件</p><h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p><h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Netty网络通信的组件，能够用于执行网络I&#x2F;O操作。 Channel为用户提供：</p><ul><li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li><li>网络连接的配置参数 （例如接收缓冲区大小）</li><li>提供异步的网络I&#x2F;O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I &#x2F; O调用都将立即返回，并且不保证在调用结束时所请求的I &#x2F; O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I &#x2F; O操作成功、失败或取消时回调通知调用方。</li><li>支持关联I&#x2F;O操作与对应的处理程序</li></ul><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型</p><ul><li>NioSocketChannel，异步的客户端 TCP Socket 连接</li><li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接</li><li>NioDatagramChannel，异步的 UDP 连接</li><li>NioSctpChannel，异步的客户端 Sctp 连接</li><li>NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.</li></ul><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Netty基于Selector对象实现I&#x2F;O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I&#x2F;O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p><h2 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h2><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I&#x2F;O任务和非I&#x2F;O任务：</p><ul><li>I&#x2F;O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li><li>非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li></ul><p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p><h2 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h2><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。 ChannelHandler</p><p>ChannelHandler是一个接口，处理I &#x2F; O事件或拦截I &#x2F; O操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p><p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><ul><li>ChannelInboundHandler用于处理入站I &#x2F; O事件</li><li>ChannelOutboundHandler用于处理出站I &#x2F; O操作</li></ul><p>或者使用以下适配器类：</p><ul><li>ChannelInboundHandlerAdapter用于处理入站I &#x2F; O事件</li><li>ChannelOutboundHandlerAdapter用于处理出站I &#x2F; O操作</li><li>ChannelDuplexHandler用于处理入站和出站事件</li></ul><p>ChannelHandlerContext 保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象 ChannelPipline</p><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p><p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了 ChannelPipeline中ChannelHandler通常如何处理I&#x2F;O事件。 I&#x2F;O事件由</p><p>ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用</p><p>ChannelHandlerContext中定义的事件传播方法（例如</p><p>ChannelHandlerContext.fireChannelRead（Object）和</p><p>ChannelOutboundInvoker.write（Object））转发到其 近的处理程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1   I/O Request</span><br><span class="line">2   via Channel or</span><br><span class="line">3   ChannelHandlerContext</span><br><span class="line">4   |</span><br><span class="line">5   +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+</span><br><span class="line">6   | ChannelPipeline | |</span><br><span class="line">7   | \|/ |</span><br><span class="line">8   | +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">9   | | Inbound Handler N | | Outbound Handler 1 | |</span><br><span class="line">10   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">11   | /|\ | |</span><br><span class="line">12   | | \|/ |</span><br><span class="line">13   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">14   | | Inbound Handler N‐1 | | Outbound Handler 2 | |</span><br><span class="line">15   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">16   | /|\ . |</span><br><span class="line">17   | . . |</span><br><span class="line">18   | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">19   | [ method call] [method call] |</span><br><span class="line">20   | . . |</span><br><span class="line">21   | . \|/ |</span><br><span class="line">22   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">23   | | Inbound Handler 2 | | Outbound Handler M‐1 | |</span><br><span class="line">24   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">25   | /|\ | |</span><br><span class="line">26   | | \|/ |</span><br><span class="line">27   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ |</span><br><span class="line">28   | | Inbound Handler 1 | | Outbound Handler M | |</span><br><span class="line">29   | +‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ +‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐+ </span><br><span class="line">30   | /|\ | |</span><br><span class="line">31   +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+</span><br><span class="line">32   | \|/</span><br><span class="line">33   +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+</span><br><span class="line">34   | | | |</span><br><span class="line">35   | [ Socket.read() ] [ Socket.write() ] |</span><br><span class="line">36   | |</span><br><span class="line">37   | Netty Internal I/O Threads (Transport Implementation) |</span><br><span class="line">38   +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+ 39</span><br><span class="line">40</span><br></pre></td></tr></table></figure><p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I &#x2F; O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p><p>出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I&#x2F;O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Channel.jpg" alt="Channel"></p><p>一个 Channel 包含了一个 ChannelPipel(img)ine, 而 ChannelPipeline 中又维护了</p><p>一个由 ChannelHandlerContext 组成的双向链表, 并且每个 </p><p>ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站</p><p>事件在一个双向链表中，入站事件会从链表head往后传递到  后一个入站的</p><p>handler，出站事件会从链表tail往前传递到   前一个出站的handler，两种类型的handler互不干扰。</p><h2 id="工作原理架构"><a href="#工作原理架构" class="headerlink" title="工作原理架构"></a>工作原理架构</h2><p>初始化并启动Netty服务端过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1public static void main(String[] args) &#123;</span><br><span class="line">2// 创建mainReactor</span><br><span class="line">3NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">4// 创建工作线程组</span><br><span class="line">5NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">6</span><br><span class="line">7final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">8serverBootstrap</span><br><span class="line">9// 组装NioEventLoopGroup</span><br><span class="line">10.group(boosGroup, workerGroup)</span><br><span class="line">11// 设置channel类型为NIO类型</span><br><span class="line">12.channel(NioServerSocketChannel.class)</span><br><span class="line">13// 设置连接配置参数</span><br><span class="line">14.option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">15.childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">16.childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">17// 配置入站、出站事件handler</span><br><span class="line">18.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">19@Override</span><br><span class="line">20protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">21// 配置入站、出站事件channel</span><br><span class="line">22ch.pipeline().addLast(...); 23 ch.pipeline().addLast(...);</span><br><span class="line">24&#125;</span><br><span class="line">25&#125;);</span><br><span class="line">26</span><br><span class="line">27// 绑定端口</span><br><span class="line">28int port = 8080;</span><br><span class="line">‐&gt;</span><br><span class="line">29serverBootstrap.bind(port).addListener(future  &#123;</span><br><span class="line">30if (future.isSuccess()) &#123;</span><br><span class="line">31System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">32&#125; else &#123;</span><br><span class="line">33System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">34&#125;</span><br><span class="line">35&#125;);36&#125;</span><br></pre></td></tr></table></figure><p>基本过程如下：</p><p>1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I&#x2F;O读写事件和业务逻辑</p><p>2 基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler</p><p>3 绑定端口，开始工作结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：</p><p><img src="/16-Netty%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Netty%E5%B7%A5%E4%BD%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Netty工作架构图"></p><p>server端包含1个Boss NioEventLoopGroup和1个Worker </p><p>NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组</p><p>里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1 个事件循环线程。</p><p>每个Boss NioEventLoop循环执行的任务包含3步：</p><p>1 轮询accept事件</p><p>2 处理accept I&#x2F;O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 *3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或 schedule执行的任务，或者其它线程提交到该eventloop的任务。</p><p>每个Worker NioEventLoop循环执行的任务包含3步：</p><p>1 轮询read、write事件；</p><p>2 处I&#x2F;O事件，即read、write事件，在NioSocketChannel可读、可写事件发生</p><p>时进行处理</p><p>​            3 处理任务队列中的任务，runAllTasks。</p><p>其中任务队列中的task有3种典型使用场景</p><p>​            1 用户程序自定义的普通任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1ctx.channel().eventLoop().execute(new Runnable() &#123;</span><br><span class="line">2@Override</span><br><span class="line">3public void run() &#123; 4 //...</span><br><span class="line">5&#125;</span><br><span class="line">6&#125;);</span><br></pre></td></tr></table></figure><p> 2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。 终的write会提交到任务队列中后被异步消费。</p><p>​           3 用户自定义定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1ctx.channel().eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">2@Override</span><br><span class="line">3public void run() &#123;</span><br><span class="line">4</span><br><span class="line">5&#125;</span><br><span class="line">6&#125;, 60, TimeUnit.SECONDS);</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在稳定推荐使用的主流版本还是Netty4，Netty5 中使用了 ForkJoinPool，</p><p>增加了代码的复杂度，但是对性能的改善却不明显，所以这个版本不推荐使用，官网也没有提供下载链接。</p><p>Netty 入门门槛相对较高，其实是因为这方面的资料较少，并不是因为他有多</p><p>难，大家其实都可以像搞透 Spring 一样搞透 Netty。在学习之前，建议先理解透整个框架原理结构，运行过程，可以少走很多弯路。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么使用MQ？MQ的优点"><a href="#为什么使用MQ？MQ的优点" class="headerlink" title="为什么使用MQ？MQ的优点"></a>为什么使用MQ？MQ的优点</h2><h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 </li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 </li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请 求。 </li><li>日志处理 - 解决大量日志传输。 </li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通 讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h3 id="详答"><a href="#详答" class="headerlink" title="详答"></a>详答</h3><p>主要是：解耦、异步、削峰。 </p><p><strong>解耦：</strong>A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要 这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统 跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系 统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据， 发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要 数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对  MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数 据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。 就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复 杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用  MQ 给它异步化解耦。 </p><p><strong>异步：</strong>A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写 库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、 200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户 感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用  MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从 接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms。 </p><p><strong>削峰：</strong>减少高峰时期对服务器压力。</p><h2 id="消息队列有什么优缺点？RabbitMQ有什么优缺点？"><a href="#消息队列有什么优缺点？RabbitMQ有什么优缺点？" class="headerlink" title="消息队列有什么优缺点？RabbitMQ有什么优缺点？"></a>消息队列有什么优缺点？RabbitMQ有什么优缺点？</h2><p>优点上面已经说了，就是**在特殊场景下有其对应的好处，解耦、异步、削峰。 **</p><p>缺点有以下几个： </p><p>系统可用性降低 </p><p>本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的 系统不是呵呵了。因此，系统可用性会降低； </p><p>系统复杂度提高 </p><p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息 不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂 性增大。 </p><p>一致性问题 </p><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是， 要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了， 咋整？你这数据就不一致了。 </p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对 它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈 呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用， 还是得用的。 </p><h2 id="你们公司生产环境用的是什么消息中间件？"><a href="#你们公司生产环境用的是什么消息中间件？" class="headerlink" title="你们公司生产环境用的是什么消息中间件？"></a>你们公司生产环境用的是什么消息中间件？</h2><p>这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是 RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 </p><p>举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还 是非常广泛的，功能很强大。 </p><p>但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高 吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企 业，用ActiveMQ做异步调用和系统解耦。</p><p>然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很 高，同时有非常完善便捷的后台管理界面可以使用。 </p><p>另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</p><p>而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的 case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 </p><p>除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的 bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 </p><p>但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致 较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为 扎实的erlang语言功底才可以。 </p><p>然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、 高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 </p><p>而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在 源码层面解决线上生产问题，包括源码的二次开发和改造。 </p><p>另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款 MQ中间件要少很多。 </p><p>但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数 据计算等场景来设计。 </p><p>因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、 Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。 </p><h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有-什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有-什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有 什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有 什么优缺点？</h2><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th><th>ZeroMQ</th><th></th></tr></thead><tbody><tr><td>单机吞吐 量</td><td>比 RabbitM Q低</td><td>2.6w&#x2F;s（ 消息做持 久化）</td><td>11.6w&#x2F;s</td><td>17.3w&#x2F;s</td><td>29w&#x2F;s</td></tr><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>Scala&#x2F;Java</td><td>C</td></tr><tr><td>主要维护者</td><td>Apache</td><td>Mozilla&#x2F;Spring</td><td>Alibaba</td><td>Apache</td><td>iMatix创始人已去世</td></tr><tr><td>成熟度</td><td>成熟</td><td>成熟</td><td>开源版本不够成熟</td><td>比较成熟</td><td>只有C、PHP等版本成熟</td></tr><tr><td>订阅形式</td><td>点对点 (p2p)、广 播（发布订阅）</td><td>提供了4 种： direct,  topic,Headers 和 fanout。 fanout就 是广播模 式</td><td>基于 topic&#x2F;me ssageTag 以及按照消息类 型、属性 进行正则 匹配的发 布订阅模 式</td><td>基于topic 以及按照 topic进行 正则匹配的发布订 阅模式</td><td>点对点(P2P)</td></tr><tr><td>持久化</td><td>支持少量 堆积</td><td>支持少量 堆积</td><td>支持大量 堆积</td><td>支持大量 堆积</td><td>不支持</td></tr><tr><td>顺序消息</td><td>不支持</td><td>不支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>性能稳定 性</td><td>好</td><td>好</td><td>一般</td><td>较差</td><td>很好</td></tr><tr><td>集群方式</td><td>支持简单 集群模 式，比 如’主备’，对 高级集群 模式支持 不好。</td><td>支持简单 集群，’复 制’模 式，对高 级集群模 式支持不 好。</td><td>常用 多 对’Mast erSlave’ 模 式，开源 版本需手 动切换 Slave变成 Master</td><td>天然 的‘Lead erSlave’无 状态集 群，每台 服务器既 是Master 也是Slave</td><td>不支持</td></tr><tr><td>管理界面</td><td>一般</td><td>较好</td><td>一般</td><td>无</td><td>无</td></tr></tbody></table><p>综上，各种对比之后，有如下建议： </p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用 的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是 算了吧，我个人不推荐用这个了； </p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师 去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开 源的，比较稳定的支持，活跃度也高； </p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出 品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但  GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用  RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝 对不会黄。 </p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是 不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选 择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝 对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性 规范。 </p><h2 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ 有哪些常见问题？如何解决这些问题？"></a>MQ 有哪些常见问题？如何解决这些问题？</h2><p>MQ 的常见问题有： </p><ol><li>消息的顺序问题 </li><li>消息的重复问题</li></ol><p>**消息的顺序问题 **</p><p>消息有序指的是可以按照消息的发送顺序来消费。 </p><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到  S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98.png" alt="消息的顺序问题"></p><p>解决方案： （1）保证生产者 - MQServer - 消费者是一对一对一的关系</p><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%982.png" alt="消息的顺序问题2"></p><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够） </li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我 们不得不花费更多的精力来解决阻塞的问题。（2）通过合理的设计或者将问题分解 来规避。 </li><li>不关注乱序的应用实际大量存在 </li><li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依 赖于消息系统，是一种更合理的方式。</li></ul><p>**消息的重复问题 **</p><p>造成消息重复的根本原因是：网络不可达。 </p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收 到两条一样的消息，应该怎样处理？ </p><p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消 息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与 去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 </p><h2 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h2><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 </p><h2 id="Rabbitmq-的使用场景"><a href="#Rabbitmq-的使用场景" class="headerlink" title="Rabbitmq 的使用场景"></a>Rabbitmq 的使用场景</h2><p>（1）服务间异步通信</p><p>（2）顺序消费 </p><p>（3）定时任务 </p><p>（4）请求削峰 </p><h2 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h2><ul><li>Broker： 简单来说就是消息队列服务器实体 </li><li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 </li><li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 </li><li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 </li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 </li><li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部 均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的 权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度， vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同 的 vhost 中）。 </li><li>Producer： 消息生产者，就是投递消息的程序 </li><li>Consumer： 消息消费者，就是接受消息的程序 </li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个 channel代表一个会话任务</li></ul><p>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的 唯一的线路。 </p><h2 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h2><h3 id="一-simple模式（即最简单的收发模式）"><a href="#一-simple模式（即最简单的收发模式）" class="headerlink" title="一.simple模式（即最简单的收发模式）"></a>一.simple模式（即最简单的收发模式）</h3><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/simple%E6%A8%A1%E5%BC%8F.png" alt="simple模式"></p><p>1.消息产生消息，将消息放入队列 </p><p>2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被 拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处 理完后要及时发送ack消息给队列，否则会造成内存溢出)。 </p><h3 id="二-work工作模式-资源的竞争"><a href="#二-work工作模式-资源的竞争" class="headerlink" title="二.work工作模式(资源的竞争)"></a>二.work工作模式(资源的竞争)</h3><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/work%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="work工作模式"></p><p>1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一 个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费 消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设 置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 </p><h3 id="三-publish-x2F-subscribe发布订阅-共享资源"><a href="#三-publish-x2F-subscribe发布订阅-共享资源" class="headerlink" title="三.publish&#x2F;subscribe发布订阅(共享资源)"></a>三.publish&#x2F;subscribe发布订阅(共享资源)</h3><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/publish_subscribe%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85(%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90).png" alt="publish_subscribe发布订阅(共享资源)">1、每个消费者监听自己的队列； </p><p>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队 列，每个绑定交换机的队列都将接收到消息。 </p><h3 id="四-routing路由模式"><a href="#四-routing路由模式" class="headerlink" title="四.routing路由模式"></a>四.routing路由模式</h3><p><img src="/15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6MQ%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/routing%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F.png" alt="routing路由模式">1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的 消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; </p><p>2.根据业务功能定义路由字符串 </p><p>3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。</p><p>4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户 通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可 以自定义消费者,实时接收错误;</p><h3 id="五-topic-主题模式-路由模式的一种"><a href="#五-topic-主题模式-路由模式的一种" class="headerlink" title="五.topic 主题模式(路由模式的一种)"></a>五.topic 主题模式(路由模式的一种)</h3><p>![topic 主题模式(路由模式的一种)](15-消息中间件MQ面试题（2020最新版）.assets&#x2F;topic 主题模式(路由模式的一种).png)<br>1.星号井号代表通配符 </p><p>2.星号代表多个单词,井号代表一个单词 </p><p>3.路由功能添加模糊匹配 </p><p>4.消息产生者产生消息,把消息交给交换机 </p><p>5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消 费 </p><p>（在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方 式） </p><h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确 实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个  consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 </p><h1 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h1><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能</p><h1 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h1><p>消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；常用的交换器主要分为一下三种： fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列</p><p>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</p><h1 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h1><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</h1><p>先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p><p>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时据，从而保证了数据的正确性。</p><h1 id="候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？"><a href="#候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？" class="headerlink" title="候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？"></a>候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</h1><p>发送方确认模式将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。</p><p>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。</p><p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。</p><p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。接收方确认机制消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p><p>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 </p><p>Consumer 足够长的时间来处理消息。保证数据的最终一致性；下面罗列几种特殊情况</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h1 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h1><p>消息不可靠的情况可能是消息丢失，劫持等原因；丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供 transaction和confirm模式来确保生产者不丢消息；</p><p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚</p><p>（channel.txRollback()）,如果发送成功则提交事务</p><p>（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p><p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；</p><p>rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；</p><p>如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><p>消息队列丢数据：消息持久化。</p><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p><p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p><p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>那么如何持久化呢？</p><p>这里顺便说一下吧，其实也很容易，就下面两步</p><p>\1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列</p><p>\2. 发送消息的时候将deliveryMode&#x3D;2</p><p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；如果这时处理消息失败，就会丢失该消息；解决方案：处理消息成功后，手动回复确认消息。</p><h1 id="为什么不应该对所有的-message-都使用持久化机制？"><a href="#为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制？"></a>为什么不应该对所有的 message 都使用持久化机制？</h1><p>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。</p><p>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</p><p>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条&#x2F;秒以上的消息吞吐量（单 RabbitMQ 服务</p><p>器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：</p><p>仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p><h1 id="如何保证高可用的？RabbitMQ-的集群"><a href="#如何保证高可用的？RabbitMQ-的集群" class="headerlink" title="如何保证高可用的？RabbitMQ 的集群"></a>如何保证高可用的？RabbitMQ 的集群</h1><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，</p><p>我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p>镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p><p>RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue 的完整数据。 </p><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p><p>消息积压处理办法：临时紧急扩容：</p><p>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。</p><p>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</p><p>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的</p><p>数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</p><p>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</p><p>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</p><p>MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间</p><p>的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><p>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要</p><p>了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p><h1 id="设计MQ思路"><a href="#设计MQ思路" class="headerlink" title="设计MQ思路"></a>设计MQ思路</h1><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，</p><p>broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。</p><p>如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有</p><p>磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p><p>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p><p>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="为什么要用-Dubbo？"><a href="#为什么要用-Dubbo？" class="headerlink" title="为什么要用 Dubbo？"></a>为什么要用 Dubbo？</h2><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越 复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务 路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框 架就出现了，Dubbo 也就这样产生了。 </p><h2 id="Dubbo-是什么？"><a href="#Dubbo-是什么？" class="headerlink" title="Dubbo 是什么？"></a>Dubbo 是什么？</h2><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发 现等高效服务治理方案， 可以和 Spring 框架无缝集成。 </p><h2 id="Dubbo-的使用场景有哪些？"><a href="#Dubbo-的使用场景有哪些？" class="headerlink" title="Dubbo 的使用场景有哪些？"></a>Dubbo 的使用场景有哪些？</h2><ul><li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置， 没有任何API侵入。 </li><li>软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少 单点。 </li><li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询 服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><h2 id="Dubbo-核心功能有哪些？"><a href="#Dubbo-核心功能有哪些？" class="headerlink" title="Dubbo 核心功能有哪些？"></a>Dubbo 核心功能有哪些？</h2><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异 步”和“请求-响应”模式的信息交换方式。 </li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支 持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 </li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务 提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="Dubbo-核心组件有哪些？"><a href="#Dubbo-核心组件有哪些？" class="headerlink" title="Dubbo 核心组件有哪些？"></a>Dubbo 核心组件有哪些？</h2><p>![Dubbo Architecture](14-Dubbo面试题（2020最新版）.assets&#x2F;Dubbo Architecture.png)</p><ul><li>Provider：暴露服务的服务提供方 </li><li>Consumer：调用远程服务消费方 </li><li>Registry：服务注册与发现注册中心 </li><li>Monitor：监控中心和访问调用统计 </li><li>Container：服务运行容器</li></ul><h2 id="Dubbo-服务器注册与发现的流程？"><a href="#Dubbo-服务器注册与发现的流程？" class="headerlink" title="Dubbo 服务器注册与发现的流程？"></a>Dubbo 服务器注册与发现的流程？</h2><p><strong>服务容器Container</strong>负责启动，加载，运行服务提供者。 </p><p><strong>服务提供者Provider</strong>在启动时，向注册中心注册自己提供的服务。 </p><p><strong>服务消费者Consumer</strong>在启动时，向注册中心订阅自己所需的服务。 </p><p><strong>中心Registry</strong>返回服务提供者地址列表给消费者，如果有变更，注册中心 将基于长连接推送变更数据给消费者。 </p><p><strong>服务消费者Consumer</strong>，从提供者地址列表中，基于软负载均衡算法，选一台 提供者进行调用，如果调用失败，再选另一台调用。 </p><p><strong>服务消费者Consumer和提供者Provider</strong>，在内存中累计调用次数和调用时 间，定时每分钟发送一次统计数据到监控中心Monitor。</p><h2 id="Dubbo-的整体架构设计有哪些分层"><a href="#Dubbo-的整体架构设计有哪些分层" class="headerlink" title="Dubbo 的整体架构设计有哪些分层?"></a>Dubbo 的整体架构设计有哪些分层?</h2><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Dubbo%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82.png" alt="Dubbo整体架构分层"></p><p><strong>接口服务层（Service）：</strong>该层与业务逻辑相关，根据 provider 和 consumer  的业务设计对应的接口和实现 </p><p><strong>配置层（Config）：</strong>对外配置接口，以 ServiceConfig 和 ReferenceConfig 为 中心 </p><p><strong>服务代理层（Proxy）：</strong>服务接口透明代理，生成服务的客户端 Stub 和 服务端 的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory </p><p><strong>服务注册层（Registry）：</strong>封装服务地址的注册和发现，以服务 URL 为中心， 扩展接口为 RegistryFactory、Registry、RegistryService </p><p><strong>路由层（Cluster）：</strong>封装多个提供者的路由和负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce </p><p><strong>监控层（Monitor）：</strong>RPC 调用次数和调用时间监控，以 Statistics 为中心， 扩展接口为 MonitorFactory、Monitor 和 MonitorService </p><p><strong>远程调用层（Protocal）：</strong>封装 RPC 调用，以 Invocation 和 Result 为中心， 扩展接口为 Protocal、Invoker 和 Exporter</p><p><strong>信息交换层（Exchange）：</strong>封装请求响应模式，同步转异步。以 Request 和 Response 为中心，扩展接口为 Exchanger、ExchangeChannel、 ExchangeClient 和 ExchangeServer </p><p><strong>网络传输层（Transport）：</strong>抽象 mina 和 netty 为统一接口，以 Message  为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec </p><p><strong>数据序列化层（Serialize）：</strong>可复用的一些工具，扩展接口为 Serialization、 ObjectInput、ObjectOutput 和 ThreadPool Dubbo </p><h2 id="Monitor-实现原理？"><a href="#Monitor-实现原理？" class="headerlink" title="Monitor 实现原理？"></a>Monitor 实现原理？</h2><p>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也 是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer  和 provider 的 filter 链中都会有 Monitorfilter。 </p><ol><li>MonitorFilter 向 DubboMonitor 发送数据 </li><li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存 到ConcurrentMap statisticsMap，然后使用一个含有 3 个线程（线程名字： DubboMonitorSendTimer）的线程池每隔 1min 钟，调用  SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一 个，就重置当前的 Statistics 的 AtomicReference </li><li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中 （队列大写为 100000） </li><li>SimpleMonitorService 使用一个后台线程（线程名为： DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线 程以死循环的形式来写） </li><li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字： DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</li></ol><p>分布式框架</p><h2 id="Dubbo-类似的分布式框架还有哪些？"><a href="#Dubbo-类似的分布式框架还有哪些？" class="headerlink" title="Dubbo 类似的分布式框架还有哪些？"></a>Dubbo 类似的分布式框架还有哪些？</h2><p>比较著名的就是 Spring Cloud。 </p><h2 id="Dubbo-和-Spring-Cloud-有什么关系？"><a href="#Dubbo-和-Spring-Cloud-有什么关系？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么关系？"></a>Dubbo 和 Spring Cloud 有什么关系？</h2><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流 量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理 的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在 开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。 </p><h2 id="Dubbo-和-Spring-Cloud-有什么哪些区别？"><a href="#Dubbo-和-Spring-Cloud-有什么哪些区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么哪些区别？"></a>Dubbo 和 Spring Cloud 有什么哪些区别？</h2><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 </p><p>Hession 序列化完成 RPC 通信。</p><p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 </p><p>Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵</p><p>活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p><h2 id="Dubbo-和-Dubbox-之间的区别？"><a href="#Dubbo-和-Dubbox-之间的区别？" class="headerlink" title="Dubbo 和 Dubbox 之间的区别？"></a>Dubbo 和 Dubbox 之间的区别？</h2><p>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</p><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="Dubbo-有哪些注册中心？"><a href="#Dubbo-有哪些注册中心？" class="headerlink" title="Dubbo 有哪些注册中心？"></a>Dubbo 有哪些注册中心？</h2><ul><li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li><li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li><li>Redis 注册中心：基于 Redis 实现，采用 key&#x2F;map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布&#x2F;订阅模式通知数据变更。</li><li>Simple 注册中心。</li></ul><p>推荐使用 Zookeeper 作为注册中心</p><h2 id="Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h2><p>可以通讯。启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="Dubbo集群提供了哪些负载均衡策略？"><a href="#Dubbo集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo集群提供了哪些负载均衡策略？"></a>Dubbo集群提供了哪些负载均衡策略？</h2><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><p>默认为 Random 随机调用。</p><h2 id="Dubbo的集群容错方案有哪些？"><a href="#Dubbo的集群容错方案有哪些？" class="headerlink" title="Dubbo的集群容错方案有哪些？"></a>Dubbo的集群容错方案有哪些？</h2><ul><li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2″ 来设置 大并行数。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><p>默认的容错方案是 Failover Cluster。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Dubbo-配置文件是如何加载到-Spring-中的？"><a href="#Dubbo-配置文件是如何加载到-Spring-中的？" class="headerlink" title="Dubbo 配置文件是如何加载到 Spring 中的？"></a>Dubbo 配置文件是如何加载到 Spring 中的？</h2><p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler， NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p><h2 id="说说核心的配置有哪些？"><a href="#说说核心的配置有哪些？" class="headerlink" title="说说核心的配置有哪些？"></a>说说核心的配置有哪些？</h2><table><thead><tr><th>标签</th><th>用途</th><th>解释</th></tr></thead><tbody><tr><td></td><td>服务配置</td><td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td></tr><tr><td></td><td>引用配置</td><td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td></tr><tr><td></td><td>协议配置</td><td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td></tr><tr><td></td><td>应用配置</td><td>用于配置当前应用信息，不管该应用是提供者还是消费者</td></tr><tr><td></td><td>模块配置</td><td>用于配置当前模块信息，可选</td></tr><tr><td></td><td>模块配置</td><td>用于配置当前模块信息，可选</td></tr><tr><td></td><td>注册中心配置</td><td>用于配置连接注册中心相关信息</td></tr><tr><td></td><td>监控中心配置</td><td>用于配置连接监控中心相关信息，可选</td></tr><tr><td></td><td>提供方配置</td><td>当   ProtocolC onfig 和 ServiceCo nfig 某属  性没有配置时，采用此缺省值，可选</td></tr><tr><td></td><td>消费方配置</td><td>当   Reference  Config 某属性没有配置时，采用此缺省值，可选</td></tr><tr><td></td><td>方法配置</td><td>用于   ServiceCo nfig 和 Reference Config 指  定方法级的配置信息</td></tr><tr><td></td><td>参数配置</td><td>用于指定方法参数配置</td></tr></tbody></table><h2 id="Dubbo-超时设置有哪些方式？"><a href="#Dubbo-超时设置有哪些方式？" class="headerlink" title="Dubbo 超时设置有哪些方式？"></a>Dubbo 超时设置有哪些方式？</h2><p>Dubbo 超时设置有两种方式：</p><ul><li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><h2 id="服务调用超时会怎么样？"><a href="#服务调用超时会怎么样？" class="headerlink" title="服务调用超时会怎么样？"></a>服务调用超时会怎么样？</h2><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="Dubbo-使用的是什么通信框架"><a href="#Dubbo-使用的是什么通信框架" class="headerlink" title="Dubbo 使用的是什么通信框架?"></a>Dubbo 使用的是什么通信框架?</h2><p>默认使用 Netty 作为通讯框架。</p><h2 id="Dubbo-支持哪些协议，它们的优缺点有哪些？"><a href="#Dubbo-支持哪些协议，它们的优缺点有哪些？" class="headerlink" title="Dubbo 支持哪些协议，它们的优缺点有哪些？"></a>Dubbo 支持哪些协议，它们的优缺点有哪些？</h2><ul><li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用 dubbo协议。</li><li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现</li><li>Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP </li><li>协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li><li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li><li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li><li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li><li>Memcache：基于 Memcache实现的 RPC 协议。</li></ul><p>Redis：基于 Redis 实现的RPC协议。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Dubbo-用到哪些设计模式？"><a href="#Dubbo-用到哪些设计模式？" class="headerlink" title="Dubbo 用到哪些设计模式？"></a>Dubbo 用到哪些设计模式？</h2><p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。</p><p>工厂模式</p><p>Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。</p><p>ServiceConfig中有个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1private static final Protocol protocol =</span><br><span class="line">2ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtensi</span><br><span class="line">3on();</span><br></pre></td></tr></table></figure><p>Dubbo 里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了</p><p>JDKSPI 的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在</p><p>classpath下增加个文件就可以了，代码零侵入。另外，像上面的 Adaptive 实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试比较麻烦，需要分析出实际调用的实现类。</p><p>装饰器模式</p><p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的 </p><p>buildInvokerChain 完成的，具体是将注解中含有 group&#x3D;provider 的 Filter 实现，按照 order 排序，   后的调用顺序是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 EchoFilter ‐&gt; ClassLoaderFilter ‐&gt; GenericFilter ‐&gt; ContextFilter ‐&gt;</span><br><span class="line">2 ExecuteLimitFilter ‐&gt; TraceFilter ‐&gt; TimeoutFilter ‐&gt; MonitorFilter ‐&gt;</span><br><span class="line">3 ExceptionFilter</span><br></pre></td></tr></table></figure><p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 </p><p>ClassLoader，这是典型的装饰器模式。</p><p>观察者模式</p><p>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，运行 NotifyListener 的 notify 方法，执行监听器方法。</p><p>动态代理模式</p><p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的key。</p><h1 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h1><h2 id="服务上线怎么兼容旧版本？"><a href="#服务上线怎么兼容旧版本？" class="headerlink" title="服务上线怎么兼容旧版本？"></a>服务上线怎么兼容旧版本？</h2><p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p><h2 id="Dubbo-telnet-命令能做什么？"><a href="#Dubbo-telnet-命令能做什么？" class="headerlink" title="Dubbo telnet 命令能做什么？"></a>Dubbo telnet 命令能做什么？</h2><p>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。</p><p>Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令</p><h2 id="Dubbo-支持服务降级吗？"><a href="#Dubbo-支持服务降级吗？" class="headerlink" title="Dubbo 支持服务降级吗？"></a>Dubbo 支持服务降级吗？</h2><p>以通过 dubbo:reference 中设置 mock&#x3D;“return null”。mock 的值也可以</p><p>修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p><h2 id="Dubbo-如何优雅停机？"><a href="#Dubbo-如何优雅停机？" class="headerlink" title="Dubbo 如何优雅停机？"></a>Dubbo 如何优雅停机？</h2><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill </p><p>-9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="Dubbo-SPI-和-Java-SPI-区别？"><a href="#Dubbo-SPI-和-Java-SPI-区别？" class="headerlink" title="Dubbo SPI 和 Java SPI 区别？"></a>Dubbo SPI 和 Java SPI 区别？</h2><p>JDK SPI：</p><p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p><p>DUBBO SPI：</p><p>1、     对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p><p>2、     延迟加载，可以一次只加载自己想要加载的扩展实现。</p><p>3、     增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p><p>4、     Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring </p><p>Bean。其他</p><h2 id="Dubbo-支持分布式事务吗？"><a href="#Dubbo-支持分布式事务吗？" class="headerlink" title="Dubbo 支持分布式事务吗？"></a>Dubbo 支持分布式事务吗？</h2><p>目前暂时不支持，可与通过 tcc-transaction 框架实现介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架</p><p>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。</p><h2 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h2><p>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量</p><p>其实比普通的配置文件就多了一个标签 cache&#x3D;“true”</p><p>Dubbo 必须依赖的包有哪些？</p><p>Dubbo 必须依赖 JDK，其他为可选。</p><p>Dubbo 支持哪些序列化方式？</p><p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><h2 id="Dubbo-在安全方面有哪些措施？"><a href="#Dubbo-在安全方面有哪些措施？" class="headerlink" title="Dubbo 在安全方面有哪些措施？"></a>Dubbo 在安全方面有哪些措施？</h2><ul><li>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</li><li>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</li></ul><h2 id="服务调用是阻塞的吗？"><a href="#服务调用是阻塞的吗？" class="headerlink" title="服务调用是阻塞的吗？"></a>服务调用是阻塞的吗？</h2><p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p><h2 id="服务提供者能实现失效踢出是什么原理？"><a href="#服务提供者能实现失效踢出是什么原理？" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h2><p>服务失效踢出基于 zookeeper 的临时节点原理。</p><h2 id="同一个服务多个注册的情况下可以直-连某一个服务吗？"><a href="#同一个服务多个注册的情况下可以直-连某一个服务吗？" class="headerlink" title="同一个服务多个注册的情况下可以直()连某一个服务吗？"></a>同一个服务多个注册的情况下可以直()连某一个服务吗？</h2><p>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。</p><h2 id="Dubbo-服务降级，失败重试怎么做？"><a href="#Dubbo-服务降级，失败重试怎么做？" class="headerlink" title="Dubbo 服务降级，失败重试怎么做？"></a>Dubbo 服务降级，失败重试怎么做？</h2><p>可以通过 dubbo:reference 中设置 mock&#x3D;“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 </p><p>“接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p><h2 id="Dubbo-使用过程中都遇到了些什么问题？"><a href="#Dubbo-使用过程中都遇到了些什么问题？" class="headerlink" title="Dubbo 使用过程中都遇到了些什么问题？"></a>Dubbo 使用过程中都遇到了些什么问题？</h2><p>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="为什么要有RPC"><a href="#为什么要有RPC" class="headerlink" title="为什么要有RPC"></a>为什么要有RPC</h2><p>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，</p><p>RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。  后就是   近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p><p>socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。</p><p>RPC一般配合netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。</p><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/RPC.jpg" alt="RPC"></p><p>简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式调用另一台机器</p><p>(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。</p><h2 id="PRC架构组件"><a href="#PRC架构组件" class="headerlink" title="PRC架构组件"></a>PRC架构组件</h2><p>一个基本的RPC架构里面应该至少包含以下4个组件：</p><p>1、     客户端（Client）:服务调用方（服务消费者）</p><p>2、     客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端</p><p>3、     服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理</p><p>4、     服务端（Server）:服务的真正提供者</p><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/RPC%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6.jpg" alt="RPC架构组件"></p><p>具体调用过程：</p><p>1、     服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；</p><p>2、     客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；</p><p>3、     客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</p><p>4、     服务端存根（server stub）收到消息后进行解码（反序列化操作）；</p><p>5、     服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；</p><p>6、     本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；</p><p>7、     服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；</p><p>8、     客户端存根（client stub）接收到消息，并进行解码（反序列化）；</p><p>9、     服务消费方得到 终结果；而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码&#x2F;解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。</p><h2 id="RPC和SOA、SOAP、REST的区别"><a href="#RPC和SOA、SOAP、REST的区别" class="headerlink" title="RPC和SOA、SOAP、REST的区别"></a>RPC和SOA、SOAP、REST的区别</h2><p>1、REST</p><p>可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单, 学习成本低效率高,但是安全性较低。</p><p>2、SOAP</p><p>SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。</p><p>它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。</p><p>3、SOA</p><p>面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B&#x2F;S模型、XML（标准通用标记语言的子集）&#x2F;Web Service技术之后的自然延伸。</p><p>4、REST 和 SOAP、RPC 有何区别呢?</p><p>没什么太大区别，他们的本质都是提供可支持分布式的基础服务， 大的区别在于他们各自的的特点所带来的不同应用场景 。</p><h2 id="RPC框架需要解决的问题？"><a href="#RPC框架需要解决的问题？" class="headerlink" title="RPC框架需要解决的问题？"></a>RPC框架需要解决的问题？</h2><p>1、     如何确定客户端和服务端之间的通信协议？</p><p>2、     如何更高效地进行网络通信？</p><p>3、     服务端提供的服务如何暴露给客户端？</p><p>4、     客户端如何发现这些暴露的服务？</p><p>5、     如何更高效地对请求对象和响应结果进行序列化和反序列化操作？</p><h2 id="RPC的实现基础？"><a href="#RPC的实现基础？" class="headerlink" title="RPC的实现基础？"></a>RPC的实现基础？</h2><p>1、     需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；</p><p>2、     需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；</p><p>3、     可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；</p><p>4、     如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；</p><h2 id="RPC使用了哪些关键技术？"><a href="#RPC使用了哪些关键技术？" class="headerlink" title="RPC使用了哪些关键技术？"></a>RPC使用了哪些关键技术？</h2><p>1、动态代理</p><p>生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到 Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。</p><p>2、序列化和反序列化在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。</p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。</li></ul><p>目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。</p><p>1、NIO通信</p><p>出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 </p><p>IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。</p><p>2、服务注册中心</p><p>可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。</p><h2 id="主流RPC框架有哪些"><a href="#主流RPC框架有哪些" class="headerlink" title="主流RPC框架有哪些"></a>主流RPC框架有哪些</h2><p>1、RMI</p><p>利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化。</p><p>2、Hessian</p><p>是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。</p><p>3、protobuf-rpc-pro是一个Java类库，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于 Netty 底层的 NIO 技术。支持 TCP 重用&#x2F; keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。</p><p>4、Thrift</p><p>是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述</p><p>文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。</p><p>初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook 贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法</p><p>来调用java语言的服务，跨越语言的C&#x2F;S RPC调用。底层通讯基于SOCKET。</p><p>5、Avro</p><p>出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。</p><p>6、Dubbo</p><p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高</p><p>性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p><h2 id="RPC的实现原理架构图"><a href="#RPC的实现原理架构图" class="headerlink" title="RPC的实现原理架构图"></a>RPC的实现原理架构图</h2><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/RPC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.jpg" alt="RPC的实现原理"></p><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/RPC%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.jpg" alt="RPC的基本原理"></p><p>PS：这张图非常重点，是PRC的基本原理，请大家一定记住！也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>比如说，A服务器想调用B服务器上的一个方法：</p><p>User getUserByName(String userName)</p><p>1、建立通信首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。</p><p>主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p><p>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</p><p>2、服务寻址要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。</p><p>通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。</p><p>可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用</p><p>Redis或者Zookeeper来注册服务等等。</p><p><img src="/14-Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/RPC.jpg" alt="RPC"></p><p>2.1、   从服务提供者的角度看：当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。</p><p>2.2、   从调用者的角度看：服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；服务调用者下线的时候，则取消订阅。</p><p>3、网络传输3.1、序列化</p><p>当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p><p>3.2、反序列化</p><p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方</p><p>式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,</p><p>通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p><p>4、服务调用</p><p>B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，  后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/13-ZooKeeper%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/13-ZooKeeper%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-ZooKeeper-是什么？"><a href="#1-ZooKeeper-是什么？" class="headerlink" title="1. ZooKeeper 是什么？"></a>1. ZooKeeper 是什么？</h2><p>ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性 服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布&#x2F;订阅、 负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和 分布式队列等功能。 </p><p>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性 能高效、功能稳定的系统提供给用户。 </p><p>Zookeeper 保证了如下分布式一致性特性： </p><p>（1）顺序一致性 </p><p>（2）原子性 </p><p>（3）单一视图 </p><p>（4）可靠性 </p><p>（5）实时性（最终一致性） </p><p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了 监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这 些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。</p><p>因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞 吐会下降。 </p><p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每 个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper  Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中 会带有这个zookeeper 最新的 zxid。 </p><h2 id="2-ZooKeeper-提供了什么？"><a href="#2-ZooKeeper-提供了什么？" class="headerlink" title="2. ZooKeeper 提供了什么？"></a>2. ZooKeeper 提供了什么？</h2><ul><li>文件系统 </li><li>通知机制</li></ul><h2 id="3-Zookeeper-文件系统"><a href="#3-Zookeeper-文件系统" class="headerlink" title="3. Zookeeper 文件系统"></a>3. Zookeeper 文件系统</h2><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统 不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存 放数据而目录节点不行。 </p><p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构， 这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限 为1M。 </p><h2 id="4-Zookeeper-怎么保证主从节点的状态同步？"><a href="#4-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4. Zookeeper 怎么保证主从节点的状态同步？"></a>4. Zookeeper 怎么保证主从节点的状态同步？</h2><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。 实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模 式和广播模式。 </p><p>恢复模式 </p><p>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出 来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状 态同步保证了 leader 和 server 具有相同的系统状态。 </p><p>广播模式 </p><p>一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息 了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在 恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader  崩溃了或者 leader 失去了大部分的 followers 支持。 </p><h2 id="5-四种类型的数据节点-Znode"><a href="#5-四种类型的数据节点-Znode" class="headerlink" title="5. 四种类型的数据节点 Znode"></a>5. 四种类型的数据节点 Znode</h2><p>（1）PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于 Zookeeper 上 </p><p>（2）EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点 都会被移除。 </p><p>（3）PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维 护的自增整型数字。 </p><p>（4）EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的 自增整型数字。 </p><h2 id="6-Zookeeper-Watcher-机制-–-数据变更通知"><a href="#6-Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="6. Zookeeper Watcher 机制 – 数据变更通知"></a>6. Zookeeper Watcher 机制 – 数据变更通知</h2><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服 务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事 件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类 型做出业务上的改变。 </p><p>工作机制： </p><p>（1）客户端注册 watcher </p><p>（2）服务端处理 watcher </p><p>（3）客户端回调 watcher </p><p>Watcher 特性总结：</p><p>（1）一次性 </p><p>无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其 从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务 端的压力都非常大。</p><p> （2）客户端串行执行 客户端 Watcher 回调的过程是一个串行同步的过程。 </p><p>（3）轻量 </p><p>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的 具体内容。 </p><p>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher  对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了 标记。 </p><p>（4）watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是 异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通 信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于  Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知 它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节 点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。 </p><p>（5）注册 watcher getData、exists、getChildren </p><p>（6）触发 watcher create、delete、setData </p><p>（7）当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件 触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client  重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通 常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未 创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后 在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。 </p><h2 id="7-客户端注册-Watcher-实现"><a href="#7-客户端注册-Watcher-实现" class="headerlink" title="7. 客户端注册 Watcher 实现"></a>7. 客户端注册 Watcher 实现</h2><p>（1）调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象 </p><p>（2）标记请求 request，封装 Watcher 到 WatchRegistration </p><p>（3）封装成 Packet 对象，发服务端发送 request </p><p>（4）收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管 理</p><p>（5）请求返回，完成注册。</p><h2 id="8-服务端处理-Watcher-实现"><a href="#8-服务端处理-Watcher-实现" class="headerlink" title="8. 服务端处理 Watcher 实现"></a>8. 服务端处理 Watcher 实现</h2><p>（1）服务端接收 Watcher 并存储<br>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节 点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接， 实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在 WatcherManager 的 WatchTable 和 watch2Paths 中去。 </p><p>（2）Watcher 触发<br>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例： </p><p>2.1 封装 WatchedEvent 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点 路径封装成一个 WatchedEvent 对象 </p><p>2.2 查询 Watcher 从 WatchTable 中根据节点路径查找 Watcher 2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher 2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从 这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了） </p><p>（3）调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件 通知。</p><h2 id="9-客户端回调-Watcher"><a href="#9-客户端回调-Watcher" class="headerlink" title="9. 客户端回调 Watcher"></a>9. 客户端回调 Watcher</h2><p>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调  Watcher。 </p><p>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效 了。 </p><h2 id="10-ACL-权限控制机制"><a href="#10-ACL-权限控制机制" class="headerlink" title="10. ACL 权限控制机制"></a>10. ACL 权限控制机制</h2><p>UGO（User&#x2F;Group&#x2F;Others） </p><p>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种 粗粒度的文件系统权限控制模式。</p><p>ACL（Access Control List）访问控制列表 </p><p>包括三个方面： </p><p>**权限模式（Scheme） **</p><p>（1）IP：从 IP 地址粒度进行权限控制 </p><p>（2）Digest：最常用，用类似于 username:password 的权限标识来进行权限 配置，便于区分不同应用来进行权限控制 </p><p>（3）World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个 权限标识“world:anyone” </p><p>（4）Super：超级用户 </p><p>**授权对象 **</p><p>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。 </p><p>**权限 Permission **</p><p>（1）CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点 </p><p>（2）DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点 </p><p>（3）READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数 据内容或子节点列表等 </p><p>（4）WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作 </p><p>（5）ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关 设置操作</p><h1 id="11-Chroot-特性"><a href="#11-Chroot-特性" class="headerlink" title="11. Chroot 特性"></a>11. Chroot 特性</h1><p>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p><p>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</p><h1 id="12-会话管理"><a href="#12-会话管理" class="headerlink" title="12. 会话管理"></a>12. 会话管理</h1><p>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。分配原则：每个会话的“下次超时时间点”（ExpirationTime）</p><p>计算公式：</p><p>ExpirationTime_ &#x3D; currentTime + sessionTimeout</p><p>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) *</p><p>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间间隔，默认 tickTime</p><h1 id="13-服务器角色"><a href="#13-服务器角色" class="headerlink" title="13. 服务器角色"></a>13. 服务器角色</h1><p>Leader</p><p>（1）  事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p><p>（2）  集群内部各服务的调度者</p><p>Follower</p><p>（1）  处理客户端的非事务请求，转发事务请求给 Leader 服务器</p><p>（2）  参与事务请求 Proposal 的投票</p><p>（3）  参与 Leader 选举投票</p><p>Observer</p><p>（1）3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础</p><p>上提升集群的非事务处理能力</p><p>（2）  处理客户端的非事务请求，转发事务请求给 Leader 服务器</p><p>（3）  不参与任何形式的投票</p><h1 id="14-Zookeeper-下-Server-工作状态"><a href="#14-Zookeeper-下-Server-工作状态" class="headerlink" title="14. Zookeeper 下 Server 工作状态"></a>14. Zookeeper 下 Server 工作状态</h1><p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、 OBSERVING。</p><p>（1）  LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p><p>（2）  FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p><p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p><h1 id="15-数据同步"><a href="#15-数据同步" class="headerlink" title="15. 数据同步"></a>15. 数据同步</h1><p>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入数据同步环节。数据同步流程：（均以消息传递的方式进行）</p><p>Learner 向 Learder 注册</p><p>数据同步同步确认</p><p>Zookeeper 的数据同步通常分为四类：</p><p>（1）  直接差异化同步（DIFF 同步）</p><p>（2）  先回滚再差异化同步（TRUNC+DIFF 同步）</p><p>（3）  仅回滚同步（TRUNC 同步）（4）全量同步（SNAP 同步）</p><p>在进行数据同步前，Leader 服务器会完成数据同步初始化： peerLastZxid：</p><p>∙ 从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该Learner 服务器最后处理的 ZXID）</p><p>minCommittedLog：</p><p>∙ Leader 服务器 Proposal 缓存队列 committedLog 中最小 </p><p>ZXIDmaxCommittedLog：</p><p>∙ Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID直接差异化同步（DIFF 同步）</p><p>∙ 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog之间先回滚再差异化同步（TRUNC+DIFF 同步）</p><p>∙ 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID仅回滚同步（TRUNC 同步）</p><p>∙ 场景：peerLastZxid 大于 maxCommittedLog 全量同步（SNAP 同步）</p><p>∙ 场景一：peerLastZxid 小于 minCommittedLog</p><p>∙ 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等于 lastProcessZxid</p><h1 id="16-zookeeper-是如何保证事务的顺序一致性的？"><a href="#16-zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="16. zookeeper 是如何保证事务的顺序一致性的？"></a>16. zookeeper 是如何保证事务的顺序一致性的？</h1><p>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 </p><p>epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h1 id="17-分布式集群中为什么会有-Master主节点？"><a href="#17-分布式集群中为什么会有-Master主节点？" class="headerlink" title="17. 分布式集群中为什么会有 Master主节点？"></a>17. 分布式集群中为什么会有 Master主节点？</h1><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p><h1 id="18-zk-节点宕机如何处理？"><a href="#18-zk-节点宕机如何处理？" class="headerlink" title="18. zk 节点宕机如何处理？"></a>18. zk 节点宕机如何处理？</h1><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p><p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p><p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在</p><p>ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><p>所以</p><p>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)</p><p>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1) 19. zookeeper 负载均衡和 nginx 负载均衡区别</p><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</p><h1 id="20-Zookeeper-有哪几种几种部署模式？"><a href="#20-Zookeeper-有哪几种几种部署模式？" class="headerlink" title="20. Zookeeper 有哪几种几种部署模式？"></a>20. Zookeeper 有哪几种几种部署模式？</h1><p>Zookeeper 有三种部署模式：</p><ol><li><p>单机部署：一台集群上运行；</p></li><li><p>集群部署：多台集群运行；</p></li><li><p>伪集群部署：一台集群启动多个 Zookeeper 实例运行。</p></li></ol><h1 id="21-集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#21-集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="21. 集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>21. 集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h1><p>集群规则为 2N+1 台，N&gt;0，即 3 台。可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h1 id="22-集群支持动态添加机器吗？"><a href="#22-集群支持动态添加机器吗？" class="headerlink" title="22. 集群支持动态添加机器吗？"></a>22. 集群支持动态添加机器吗？</h1><p>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：</p><p>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。</p><p>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</p><p>3.5 版本开始支持动态扩容。</p><ol start="23"><li><h1 id="Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</h1></li></ol><p>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况</p><p>下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</p><p>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p><h1 id="24-Zookeeper-的-java-客户端都有哪些？"><a href="#24-Zookeeper-的-java-客户端都有哪些？" class="headerlink" title="24. Zookeeper 的 java 客户端都有哪些？"></a>24. Zookeeper 的 java 客户端都有哪些？</h1><p>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</p><h1 id="25-chubby-是什么，和-zookeeper-比你怎么看？"><a href="#25-chubby-是什么，和-zookeeper-比你怎么看？" class="headerlink" title="25. chubby 是什么，和 zookeeper 比你怎么看？"></a>25. chubby 是什么，和 zookeeper 比你怎么看？</h1><p>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby的开源实现，使用 zab 协议，paxos 算法的变种。</p><h1 id="26-说几个-zookeeper-常用的命令。"><a href="#26-说几个-zookeeper-常用的命令。" class="headerlink" title="26. 说几个 zookeeper 常用的命令。"></a>26. 说几个 zookeeper 常用的命令。</h1><p>常用命令：ls get set create delete 等。</p><h1 id="27-ZAB-和-Paxos-算法的联系与区别？"><a href="#27-ZAB-和-Paxos-算法的联系与区别？" class="headerlink" title="27. ZAB 和 Paxos 算法的联系与区别？"></a>27. ZAB 和 Paxos 算法的联系与区别？</h1><p>相同点：</p><p>（1）  两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</p><p>（2）  Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交</p><p>（3）  ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 </p><p>Leader周期，Paxos 中名字为 Ballot 不同点：</p><p>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。</p><h1 id="28-Zookeeper-的典型应用场景"><a href="#28-Zookeeper-的典型应用场景" class="headerlink" title="28. Zookeeper 的典型应用场景"></a>28. Zookeeper 的典型应用场景</h1><p>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。</p><p>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p><p>（1）  数据发布&#x2F;订阅</p><p>（2）  负载均衡</p><p>（3）  命名服务</p><p>（4）  分布式协调&#x2F;通知</p><p>（5）  集群管理</p><p>（6）  Master 选举</p><p>（7）  分布式锁</p><p>（8）  分布式队列数据发布&#x2F;订阅介绍数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。</p><p>目的动态获取数据（配置信息）实现数据（配置信息）的集中式管理和数据的动态更新设计模式</p><p>Push 模式</p><p>Pull 模式</p><p>数据（配置信息）特性</p><p>（1）  数据量通常比较小</p><p>（2）  数据内容在运行时会发生动态更新</p><p>（3）  集群中各机器共享，配置一致</p><p>如：机器列表信息、运行时开关配置、数据库配置信息等基于 Zookeeper 的实现方式</p><p>∙ 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点</p><p>∙ 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher</p><p>∙ 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</p><p>负载均衡</p><p>zk 的命名服务命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><p>分布式通知和协调</p><p>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。</p><p>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p><p>zk 的命名服务（文件系统）命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><p>zk 的配置管理（文件系统、通知机制）程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置。</p><p>Zookeeper 集群管理（文件系统、通知机制）</p><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。</p><p>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。</p><p>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有</p><p>了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 master 就好。</p><p>Zookeeper 分布式锁（文件系统、通知机制）</p><p>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><p>对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode的方式来实现。所有客户端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放出锁。</p><p>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺</p><p>序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。</p><p>Zookeeper 队列管理（文件系统、通知机制）两种类型的队列：</p><p>（1）  同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p><p>（2）  队列按照 FIFO 方式进行入队和出队操作。</p><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p><p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时 Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下</p><p>Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p><h1 id="29-Zookeeper-都有哪些功能？"><a href="#29-Zookeeper-都有哪些功能？" class="headerlink" title="29. Zookeeper 都有哪些功能？"></a>29. Zookeeper 都有哪些功能？</h1><ol><li><p>集群管理：监控节点存活状态、运行请求等；</p></li><li><p>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；</p></li><li><p>分布式锁：Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线</p></li></ol><p>线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。</p><p>Zookeeper 可以对分布式锁进行控制。</p><ol start="4"><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ol><h1 id="30-说一下-Zookeeper-的通知机制？"><a href="#30-说一下-Zookeeper-的通知机制？" class="headerlink" title="30. 说一下 Zookeeper 的通知机制？"></a>30. 说一下 Zookeeper 的通知机制？</h1><p>client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p><h1 id="31-Zookeeper-和-Dubbo-的关系？"><a href="#31-Zookeeper-和-Dubbo-的关系？" class="headerlink" title="31. Zookeeper 和 Dubbo 的关系？"></a>31. Zookeeper 和 Dubbo 的关系？</h1><p>Zookeeper的作用：</p><p>zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器</p><p>挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。</p><p>zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。</p><p>dubbo：</p><p>是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。</p><p>注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。</p><p>zookeeper和dubbo的关系：</p><p>Dubbo 的将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有 ZooKeeper，Memcached，Redis 等。</p><p>引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 群配合相应的 </p><p>Web 应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时</p><p>候，向 ZooKeeper 上的指定节点 &#x2F;dubbo&#x2F;${serviceName}&#x2F;providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。</p><p><img src="/13-ZooKeeper%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/ZooKeeper.jpg" alt="ZooKeeper"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许 可）高性能非关系型（NoSQL）的键值对数据库。 </p><p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值 支持五种数据类型：字符串、列表、集合、散列表、有序集合。 </p><p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快， 因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已<br>知性能快的Key-Value DB。</p><p>另外，Redis 也经常用来做分布式锁。除此之 外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </p><h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>**优点 **</p><ul><li>读写性能优异， Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。 </li><li>支持数据持久化，支持AOF和RDB两种持久化方式。 </li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并 后的原子性执行。 </li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等 数据结构。 </li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>**缺点 **</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。 </li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求 失败，需要等待机器重启或者手动切换前端的IP才能恢复。 </li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一 致的问题，降低了系统的可用性。 </li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避 免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的 浪费。</li></ul><h2 id="为什么要用-Redis-x2F-为什么要用缓存"><a href="#为什么要用-Redis-x2F-为什么要用缓存" class="headerlink" title="为什么要用 Redis &#x2F;为什么要用缓存"></a>为什么要用 Redis &#x2F;为什么要用缓存</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。 </p><p>高性能： </p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上 读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候 就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如 果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%AB%98%E6%80%A7%E8%83%BD.png" alt="高性能"></p><p>高并发： </p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑 把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这 里而不用经过数据库。</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%AB%98%E5%B9%B6%E5%8F%91.png" alt="高并发"></p><h2 id="为什么要用-Redis-而不用-map-x2F-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-x2F-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map&#x2F;guava 做缓存?"></a>为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava  实现的是本地缓存，主要的特点是轻量以及快速，生命周期随着 jvm 的销毁 而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具 有一致性。 </p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实 例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。 </p><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存 中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)； </li><li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计 的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者 多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁 操作，没有因为可能出现死锁而导致的性能消耗； </li><li>使用多路 I&#x2F;O 复用模型，非阻塞 IO； </li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协 议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的 话，会浪费一定的时间去移动和请求；</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分 的使用要求 数据类型 可以存储 的值 操作 应用场景</p><table><thead><tr><th align="center">数据类型</th><th align="left">可以存储 的值</th><th align="left">操作</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="center">STRING</td><td align="left">字符串、 整数或者 浮点数</td><td align="left">对整个字 符串或者 字符串的 其中一部 分执行操 作 对整数和 浮点数执 行自增或 者自减操 作</td><td align="left">做简单的 键值对缓 存</td></tr><tr><td align="center">LIST</td><td align="left">列表</td><td align="left">从两端压 入或者弹 出元素 对单个或 者多个元 素进行修 剪， 只保留一 个范围内 的元素</td><td align="left">存储一些 列表型的 数据结 构，类似 粉丝列 表、文章 的评论列 表之类的 数据</td></tr><tr><td align="center">SET</td><td align="left">无序集合</td><td align="left">添加、获 取、移除 单个元素 检查一个 元素是否 存在于集 合中</td><td align="left">交集、并 集、差集 的操作， 比如交 集，可以 把两个人 的粉丝列</td></tr><tr><td align="center">HASH</td><td align="left">包含键值 对的无序 散列表</td><td align="left">添加、获 取、移除 单个键值 对 获取所有 键值对  检查某个 键是否存 在</td><td align="left">结构化的 数据，比 如一个对 象</td></tr><tr><td align="center">ZSET</td><td align="left">有序集合</td><td align="left">添加、获 取、删除 元素 根据分值 范围或者 成员来获 取元素  计算一个 键的排名</td><td align="left">去重但可 以排序， 如获取排 名前几名 的用户</td></tr></tbody></table><h2 id="7Redis的应用场景"><a href="#7Redis的应用场景" class="headerlink" title="7Redis的应用场景"></a>7Redis的应用场景</h2><h3 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h3><p>计数器 </p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数 据库的读写性能非常高，很适合存储频繁读写的计数量。 </p><p>缓存 </p><p>将热点数据放到内存中，设置内存的大使用量以及淘汰策略来保证缓存的命中率。 </p><p>会话缓存 </p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存 储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务 器，从而更容易实现高可用性以及可伸缩性。 </p><p>全页缓存（FPC） </p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例， Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以 快速度加载你曾浏览过的页面。 </p><p>查找表 </p><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了  Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效， 因为缓存不作为可靠的数据来源。 </p><p>消息队列(发布&#x2F;订阅功能) </p><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过好使用  Kafka、RabbitMQ 等消息中间件。 </p><p>分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可 以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提 供的 RedLock 分布式锁实现。 </p><p>其它 </p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有 序性操作，从而实现排行榜等功能。 </p><h3 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a>总结二</h3><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 </p><p>数据类型说明string字符串，简单的k-v存储hashhash格式，value为field和 value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末 尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有 序的set </p><p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 </p><p>string——适合简单的k-v存储，类似于memcached的存储结构，短信验证 码，配置信息等，就用这种类型来存储。 </p><p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情， 个人信息详情，新闻详情等。</p><p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省 市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：新 的***，消息队列等。</p><p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set 牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人 共同的好友等。 </p><p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的 值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很 多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅 有利于提升开发效率，也能有效利用Redis的性能。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 </p><h2 id="9Redis-的持久化机制是什么？各自的优缺点？"><a href="#9Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="9Redis 的持久化机制是什么？各自的优缺点？"></a>9Redis 的持久化机制是什么？各自的优缺点？</h2><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: </p><h3 id="RDB：是Redis-DataBase缩写快照"><a href="#RDB：是Redis-DataBase缩写快照" class="headerlink" title="RDB：是Redis DataBase缩写快照"></a>RDB：是Redis DataBase缩写快照</h3><p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保 存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来 定义快照的周期。</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/RDB.png" alt="RDB"></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>只有一个文件 dump.rdb，方便持久化。 </li><li>容灾性好，一个文件可以保存到安全的磁盘。 </li><li>性能大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是  IO 大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了  redis 的高性能 </li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候) </li><li>AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命 令请 求协议的格式完全持久化存储)保存为 aof 文件。</li></ol><h3 id="AOF：持久化"><a href="#AOF：持久化" class="headerlink" title="AOF：持久化"></a>AOF：持久化</h3><p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录 到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/AOF.png" alt="AOF"></p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一 次 命令操作就记录到 aof 文件中一次。 </li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-checkaof 工具解决数据一致性问题。 </li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命 令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。 </li><li>数据集大的时候，比 rdb 启动效率低。</li></ol><h3 id="优缺点是什么？"><a href="#优缺点是什么？" class="headerlink" title="优缺点是什么？"></a>优缺点是什么？</h3><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据。 </li><li>AOF比RDB更安全也更大 </li><li>RDB性能比AOF好 </li><li>如果两个都配了优先加载AOF</li></ul><h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><ul><li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载 入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集 要比RDB文件保存的数据集要完整。 </li><li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用RDB持久化。 </li><li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生 成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据 集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免 AOF程序的bug。 </li><li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任 何持久化方式。</li></ul><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><p>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p><p>如果Redis被当做一个持久化存储使用，必须使用固定的keys-tonodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p><h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过</p><p>期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p><p>过期策略通常有以下三种：</p><p> 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><p>​          惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。</p><p>该策略可以  大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定</p><p>时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到 优的平衡效果。</p><p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该</p><p>Redis集群中保存的所有键。)</p><p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p><h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><p>EXPIRE和PERSIST命令。</p><h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li><p>定时去清理过期的缓存；</p></li><li><p>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p></li></ol><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</p><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><h2 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p>全局的键空间选择性移除</p><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</p><p> allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除  近 少使用的key。（这个是最常用的）</p><p> allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p><p>设置过期时间的键空间选择性移除</p><p> volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除   近  少使用的key。</p><p> volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</p><p> volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p>总结</p><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><h3 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h3><p>内存。</p><h2 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表</p><p>（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面线程模型</p><h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处</p><p>理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p><p>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>​         当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入</p><p>（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I&#x2F;O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 </p><p>Redis 内部单线程设计的简单性。</p><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支</p><p>持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><p>\1. 事务开始 MULTI</p><p>\2. 命令入队</p><p>\3. 事务执行 EXEC</p><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p><h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><p>\1.  redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</p><p>\2.  如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</p><p>\3.  如果在一个事务中出现运行错误，那么正确的命令会被执行。</p><p> WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><p> MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p><p> EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p><p> 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</p><p>​          UNWATCH命令可以取消watch对所有key的监控。</p><h2 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h2><p>原子性（Atomicity）</p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p>一致性（Consistency）</p><p>事务前后数据的完整性必须保持一致。</p><p>隔离性（Isolation）</p><p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p><p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><h2 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h2><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p><h2 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h2><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><p> 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p><p> 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐集群方案哨兵模式</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5.jpg" alt="集群哨兵"></p><p>哨兵的介绍</p><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p><p>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</p><p>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p><p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><p> 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</p><p> 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p><p>哨兵的核心知识</p><p>  哨兵至少需要 3 个实例，来保证自己的健壮性。</p><p> 哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</p><p> 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p><h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Redis_Cluster%E6%96%B9%E6%A1%88.jpg" alt="Redis_Cluster方案"></p><p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？简介</p><p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis </p><p>Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个</p><p>槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p><p>方案说明</p><ol><li><p>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值) 区间的数据，默认分配了16384 个槽位</p></li><li><p>每份数据分片会存储在多个互为主从的多节点上</p></li><li><p>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</p></li><li><p>同一分片多个节点间的数据不保持一致性</p></li><li><p>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</p></li><li><p>扩容时时需要需要把旧节点的数据迁移一部分到新节点</p></li></ol><p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p>节点间的内部通信机制</p><p>基本通信原理</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p><p>分布式寻址算法</p><p>hash 算法（大量缓存重建）</p><p>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） redis cluster 的 hash slot 算法优点</p><p>无中心架构，支持动态扩容，对业务透明</p><p>具备Sentinel的监控和自动Failover(故障转移)能力</p><p>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可高性能，客户端直连redis运维也很复杂，数据迁移需要人工干预只能使用0号数据库</p><p>不支持批量操作(pipeline管道操作) 分布式逻辑和存储模块耦合等基于客户端分配</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E9%85%8D.jpg" alt="客户端分配"></p><p>简介</p><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持</p><p>Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool 优点</p><p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强缺点</p><p>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</p><p>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化基于代理服务器分片</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%BB%A3%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%89%87.jpg" alt="代里服务器分片"></p><p>简介客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点， 后将结果回复给客户端特征</p><p>透明接入，业务程序不用关心后端Redis实例，切换成本低</p><p>Proxy 的逻辑和存储的逻辑是隔离的代理层多了一次转发，性能有所损耗业界开源方案</p><p>Twtter开源的Twemproxy 豌豆荚开源的Codis</p><h2 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h2><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多</p><p>从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png" alt="主从架构"></p><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -(redis­master­slave)&gt; 水平扩容支撑读高并发 redis replication 的核心机制</p><p> redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</p><p>一个 master node 是可以配置多个 slave node 的； slave node 也可以连接其他的 slave node；</p><p>slave node 做复制的时候，不会 block master node 的正常工作；</p><p>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</p><p> slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</p><p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><p>redis 主从复制的核心原理当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 full </p><p>resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 </p><p>RDB 快照文件，</p><p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p><p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="主从复制原理"></p><ol><li><p>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</p></li><li><p>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令存起来</p></li><li><p>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从</p></li></ol><p>Redis</p><ol start="4"><li><p>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</p></li><li><p>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</p></li></ol><p>缺点</p><p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p><h2 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品生产环境中的 redis 是怎么部署的？</p><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署</p><p>了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器 多是 25 万读写请求&#x2F;s。</p><p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的</p><p>是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>5 台机器对外提供读写，一共有 50g 内存。</p><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p><h2 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h2><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p>Redis集群之间是如何复制的？</p><p>异步复制</p><p>Redis集群最大节点个数是多少？</p><p>16384个</p><p>Redis集群如何选择数据库？</p><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h2><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个</p><p>CPU，你可以考虑一下分片（shard）。</p><h2 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h2><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你  多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h2 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h2><p> 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个 redis节点读取。大多数客户端已经实现了客户端分区。</p><p> 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</p><p> 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</p><h2 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h2><p> 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p><p>同时操作多个key,则不能使用Redis事务.</p><p>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The </p><p>partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</p><p> 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis 实例和主机同时收集RDB &#x2F; AOF文件。</p><p> 分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis 节点，能做到  大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p><h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户</p><p>端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则</p><p>SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。<img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/img.jpg" alt="img"></p><p>使用SETNX完成同步锁的流程及事项如下(img)：使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用SETNX命令总是返回</p><p>0而进入死锁状态，需要为该key设置一个“合理”的过期时间释放锁，使用DEL命令将锁数据删除</p><h2 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h2><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是 后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号 小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><h2 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h2><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容， 好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 </p><p>Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ol><li><p>安全特性：互斥访问，即永远只有一个 client 能拿到锁</p></li><li><p>避免死锁： 终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</p></li><li><p>容错性：只要大部分 Redis 节点存活就可以正常提供服务缓存异常缓存雪崩</p></li></ol><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方案</p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>一般并发量不是特别多的时候，使用   多的解决方案是加锁排队。</p></li><li><p>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p></li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方案</p><ol><li><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p></li><li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-</p></li></ol><p>value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p><ol start="3"><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力附加</li></ol><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p><p>Bitmap： 典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p>布隆过滤器（推荐）</p><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p><p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p><p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash</p><p>函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是</p><p>Bloom-Filter的基本思想。</p><p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案</p><p>1.设置热点数据永远不过期。</p><p>2.加互斥锁，互斥锁缓存预热</p><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！解决方案</p><ol><li><p>直接写个缓存刷新页面，上线时手工操作一下；</p></li><li><p>数据量不大，可以在项目启动的时候自动进行加载；</p></li><li><p>定时刷新缓存；</p></li></ol><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>缓存降级的  终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ol><li><p>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p></li><li><p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p></li><li><p>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的 大阀值，此时可以根据情况自动降级或者人工降级；</p></li><li><p>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p></li></ol><p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h2 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h2><p>热点数据，缓存才有价值对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p><p>数据更新前至少读取两次，缓存才有意义。这个是  基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p><p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享</p><p>数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到</p><p>Redis缓存，减少数据库压力。</p><h2 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h2><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>解决方案对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其</p><p>他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询常用工具</p><p>Redis支持的Java客户端都有哪些？官方推荐用哪个？</p><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, </p><p>ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, </p><p>Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, </p><p>ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, </p><p>HyperLogLog)。</p><h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支</p><p>持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</p><p>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h2><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p><table><thead><tr><th>对比参数</th><th>Redis</th><th>Memcac hed</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td>1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td>数据存储类型</td><td>1. String 2. List 3.    Set 4.   Hash 5.   Sort Set   【俗称  ZSet】</td><td>1.    文本型   2.    二进制类型</td></tr><tr><td>查询【操作】类型</td><td>1. 批量操作 2. 事务支持 3. 每个类型不同的  CRUD</td><td>1.常用的  CRUD 2. 少量的其他命令</td></tr><tr><td>附加功能</td><td>1.  发布&#x2F;订阅模式 2. 主从分区 3. 序列化  支持 4. 脚本支持  【Lua脚本】</td><td>1. 多线程服务支持</td></tr><tr><td>网络IO模型</td><td>1. 单线程的多路 IO 复用模型</td><td>1. 多线程，非阻塞IO模式</td></tr><tr><td>事件库</td><td>自封转简易事件库 AeEvent</td><td>贵族血统的  LibEvent 事件库</td></tr><tr><td>持久化支持</td><td>1. RDB 2.   AOF</td><td>不支持</td></tr><tr><td>集群模式</td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td></td><td></td><td></td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用  的 value 交换到磁盘</td><td>Memcach ed 的数据则会一直在内存中，  Memcach  ed 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128   bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr><tr><td></td><td>复杂数据</td><td>纯key-  value，数据量非常大，并发量非常大的业务</td></tr><tr><td>适用场景</td><td>结构，有持久化，高可用需求，value 存储内容较大</td><td></td></tr></tbody></table><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>(2) redis的速度比memcached快很多</p><p>(3) redis可以持久化其数据</p><h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况， 好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。</p><table><thead><tr><th>问题场景</th><th>描述</th><th>解决</th></tr></thead><tbody><tr><td>先写缓存，再写数据库，缓存写成功，数据库写失败</td><td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td><td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td></tr><tr><td>先写数据库，再写缓存，数据库写成功，缓存写失败</td><td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td><td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td></tr><tr><td>需要缓存异步刷新</td><td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补</td><td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td></tr><tr><td></td><td>救措施）时候</td><td></td></tr></tbody></table><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol><li><p>Master 好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</p></li><li><p>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p></li><li><p>为了主从复制的速度和连接的稳定性，Slave和Master  好在同一个局域网内。</p></li><li><p>尽量避免在压力较大的主库上增加从库</p></li><li><p>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p></li><li><p>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果</p></li></ol><p>Master挂了，可以立马启用Slave1做Master，其他不变。</p><h2 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h2><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p><h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p><p>Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h2 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h2><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过 pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p><h2 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h2><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p><h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><ol><li><p>一个客户端运行了新的命令，添加了新的数据。</p></li><li><p>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</p></li><li><p>一个新的命令被执行，等等。</p></li><li><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p></li></ol><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h2 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h2><p>LRU算法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><h2 id="1-什么是Linux"><a href="#1-什么是Linux" class="headerlink" title="1. 什么是Linux"></a>1. 什么是Linux</h2><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix 的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工 具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网 络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 </p><h2 id="2-Unix和Linux有什么区别？"><a href="#2-Unix和Linux有什么区别？" class="headerlink" title="2. Unix和Linux有什么区别？"></a>2. Unix和Linux有什么区别？</h2><p>Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很 多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然 而，事实并非如此，以下是两者的区别。 </p><ol><li>开源性 Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知 识产权保护的传统商业软件，使用需要付费授权使用。 </li><li>跨平台性 Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系 统跨平台性能较弱，大多需与硬件配套使用。 </li><li>可视化界面 Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。 </li><li>硬件环境 Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛 刻，按照难度较大。 </li><li>用户群体 Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是 安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使 用，如Sun等。</li></ol><p>相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因 是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实 现全部的Unix特性，开源免费的特性，更容易普及使用！ </p><h2 id="3-什么是-Linux-内核？"><a href="#3-什么是-Linux-内核？" class="headerlink" title="3. 什么是 Linux 内核？"></a>3. 什么是 Linux 内核？</h2><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要 时分配硬件，并根据需要执行软件。 </p><p>系统内存管理 </p><p>应用程序管理 </p><p>硬件设备管理 </p><p>文件系统管理 </p><h2 id="4-Linux的基本组件是什么？"><a href="#4-Linux的基本组件是什么？" class="headerlink" title="4. Linux的基本组件是什么？"></a>4. Linux的基本组件是什么？</h2><p>就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和 GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面 都附带其他功能，所有代码都可以免费下载。 </p><h2 id="5-Linux-的体系结构"><a href="#5-Linux-的体系结构" class="headerlink" title="5. Linux 的体系结构"></a>5. Linux 的体系结构</h2><p>从大的方面讲，Linux 体系结构可以分为两块：</p><p><img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Linux%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Linux体系结构"></p><ul><li>用户空间(User Space) ：用户空间又包括用户的应用程序(User  Applications)、C 库(C Library) 。 </li><li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call  Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel  Code) 。</li></ul><p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p><ul><li>现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问 的寄存器不同。 </li><li>Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li></ul><p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成 用户空间到内核空间的转移：1）系统调用；2）硬件中断。 </p><h2 id="6-BASH和DOS之间的基本区别是什么？"><a href="#6-BASH和DOS之间的基本区别是什么？" class="headerlink" title="6. BASH和DOS之间的基本区别是什么？"></a>6. BASH和DOS之间的基本区别是什么？</h2><p>BASH和DOS控制台之间的主要区别在于3个方面： </p><ul><li>BASH命令区分大小写，而DOS命令则不区分; </li><li>在BASH下，&#x2F; character是目录分隔符，\作为转义字符。在DOS下，&#x2F;用作命令 参数分隔符，\是目录分隔符 </li><li>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字 符。BASH没有遵循这样的惯例。</li></ul><h2 id="7-Linux-开机启动过程？"><a href="#7-Linux-开机启动过程？" class="headerlink" title="7. Linux 开机启动过程？"></a>7. Linux 开机启动过程？</h2><p>**了解即可。 **</p><ol><li>主机加电自检，加载 BIOS 硬件信息。 </li><li>读取 MBR 的引导文件(GRUB、LILO)。 </li><li>引导 Linux 内核。 </li><li>运行第一个进程 init (进程号永远为 1 )。 </li><li>进入相应的运行级别。 </li><li>运行终端，输入用户名和密码。</li></ol><h2 id="8-Linux系统缺省的运行级别？"><a href="#8-Linux系统缺省的运行级别？" class="headerlink" title="8. Linux系统缺省的运行级别？"></a>8. Linux系统缺省的运行级别？</h2><ul><li>关机。 </li><li>单机用户模式。 </li><li>字符界面的多用户模式(不支持网络)。 </li><li>字符界面的多用户模式。 </li><li>未分配使用。 </li><li>图形界面的多用户模式。 </li><li>重启。</li></ul><h2 id="9-Linux-使用的进程间通信方式？"><a href="#9-Linux-使用的进程间通信方式？" class="headerlink" title="9. Linux 使用的进程间通信方式？"></a>9. Linux 使用的进程间通信方式？</h2><p>**了解即可，不需要太深入。 **</p><ol><li>管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li><li>信号(signal) 。 </li><li>消息队列。 </li><li>共享内存。 </li><li>信号量。 </li><li>套接字(socket) 。</li></ol><h2 id="10-Linux-有哪些系统日志文件？"><a href="#10-Linux-有哪些系统日志文件？" class="headerlink" title="10. Linux 有哪些系统日志文件？"></a>10. Linux 有哪些系统日志文件？</h2><p>**比较重要的是 <code>/var/log/messages </code>日志文件。 **<br>    该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入 侵。<br>    另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。 </p><h1 id="Linux系统安装多个桌面环境有帮助吗？"><a href="#Linux系统安装多个桌面环境有帮助吗？" class="headerlink" title="Linux系统安装多个桌面环境有帮助吗？"></a>Linux系统安装多个桌面环境有帮助吗？</h1><p>通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。</p><h1 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h1><p>交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p><h1 id="什么是root帐户"><a href="#什么是root帐户" class="headerlink" title="什么是root帐户"></a>什么是root帐户</h1><p>root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</p><h1 id="什么是LILO？"><a href="#什么是LILO？" class="headerlink" title="什么是LILO？"></a>什么是LILO？</h1><p>LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。什么是BASH？</p><p>BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始</p><p>Bourne Shell（由&#x2F; bin &#x2F; sh表示）的替代品。它结合了原始版本的Bourne </p><p>Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。</p><h1 id="什么是CLI？"><a href="#什么是CLI？" class="headerlink" title="什么是CLI？"></a>什么是CLI？</h1><p>命令行界面（英语<strong>：command-line interface</strong>，缩写]：CLI）是在图形用</p><p>户界面得到普及之前使用  为广泛的用户界面，它通常不支持鼠标，用户通过键</p><p>盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面</p><p>（CUI）。</p><p>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。</p><p>因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</p><h1 id="什么是GUI？"><a href="#什么是GUI？" class="headerlink" title="什么是GUI？"></a>什么是GUI？</h1><p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p><p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</p><h1 id="开源的优势是什么？"><a href="#开源的优势是什么？" class="headerlink" title="开源的优势是什么？"></a>开源的优势是什么？</h1><p>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这  终使社区中的每个人受益。</p><h1 id="GNU项目的重要性是什么？"><a href="#GNU项目的重要性是什么？" class="headerlink" title="GNU项目的重要性是什么？"></a>GNU项目的重要性是什么？</h1><p>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</p><h1 id="磁盘、目录、文件"><a href="#磁盘、目录、文件" class="headerlink" title="磁盘、目录、文件"></a>磁盘、目录、文件</h1><h2 id="简单-Linux-文件系统？"><a href="#简单-Linux-文件系统？" class="headerlink" title="简单 Linux 文件系统？"></a>简单 Linux 文件系统？</h2><p>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱</p><p>动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</p><p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是</p><p>Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><p>Linux 支持 5 种文件类型，如下图所示：<img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.jpg" alt="文件类型"></p><h2 id="Linux-的目录结构是怎样的？"><a href="#Linux-的目录结构是怎样的？" class="headerlink" title="Linux 的目录结构是怎样的？"></a>Linux 的目录结构是怎样的？</h2><p>这个问题，一般不会问。更多是实际使用时，需要知道。</p><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，  顶层是其根目录：</p><p><img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="Linux的目录结构"></p><p>常见目录说明：</p><ul><li>&#x2F;bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li><li>&#x2F;etc： 存放系统管理和配置文件；</li><li>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示；</li><li>**&#x2F;usr **： 用于存放系统应用程序；</li><li>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把</li><li>tomcat等都安装到这里；</li><li>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级o）；</li><li>&#x2F;sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li>&#x2F;dev： 用于存放设备文件；</li><li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li>&#x2F;boot： 存放用于系统引导时使用的各种文件；</li><li>**&#x2F;lib **： 存放着和系统运行相关的库文件 ；</li><li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；</li><li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h2 id="什么是-inode-？"><a href="#什么是-inode-？" class="headerlink" title="什么是 inode ？"></a>什么是 inode ？</h2><p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。</p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的 小存储单位叫做”扇区”（Sector）。每个扇区储存</p><p>512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的 小单位。”块”的大小， 常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</p><p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p><p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p><ul><li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中 重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li><li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构</li></ul><h2 id="什么是硬链接和软链接？"><a href="#什么是硬链接和软链接？" class="headerlink" title="什么是硬链接和软链接？"></a>什么是硬链接和软链接？</h2><p>1）     硬链接</p><p>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</p><ul><li>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。</li></ul><p>2）     软链接软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p><ul><li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li></ul><p>实际场景下，基本是使用软链接。总结区别如下：</p><ul><li>硬链接不可以跨分区，软件链可以跨分区。</li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ul><p>RAID 是什么?</p><p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p><p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p><p>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="一台-Linux-系统初始化环境后需要做一些什么安全工作？"><a href="#一台-Linux-系统初始化环境后需要做一些什么安全工作？" class="headerlink" title="一台 Linux 系统初始化环境后需要做一些什么安全工作？"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h2><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p><p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p><p>2、服务器使用密钥登陆，禁止密码登陆。</p><p> 3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p><p>4、   装 fail2ban 这种防止 SSH 暴力破击的软件。</p><p>5、   设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p><p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p><p>6、   只允许有需要的服务器可以访问外网，其它全部禁止。</p><p>7、   做好软件层面的防护。</p><p>7.1 设置 nginx_waf 模块防止 SQL 注入。</p><p>7.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</p><h2 id="什么叫-CC-攻击？什么叫-DDOS-攻击？"><a href="#什么叫-CC-攻击？什么叫-DDOS-攻击？" class="headerlink" title="什么叫 CC 攻击？什么叫 DDOS 攻击？"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h2><ul><li>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</li><li>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</li></ul><p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p><p>怎么预防 CC 攻击和 DDOS 攻击？防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p><p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p><h2 id="什么是网站数据库注入？"><a href="#什么是网站数据库注入？" class="headerlink" title="什么是网站数据库注入？"></a>什么是网站数据库注入？</h2><ul><li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li><li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li><li>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li></ul><p>如何过滤与预防？</p><p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>本小节为选读。我也不太会写 Shell 脚本，都是写的时候，在网络上拼拼凑凑。。。</p><h2 id="Shell-脚本是什么？"><a href="#Shell-脚本是什么？" class="headerlink" title="Shell 脚本是什么？"></a>Shell 脚本是什么？</h2><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p><p>什么是默认登录 Shell ？在 Linux 操作系统，”&#x2F;bin&#x2F;bash” 是默认登录 Shell，是在创建用户时分配的。</p><p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1## chsh &lt;用户名&gt; ‐s &lt;新shell&gt;</span><br><span class="line">2## chsh ThinkWon ‐s /bin/sh</span><br></pre></td></tr></table></figure><p>在 Shell 脚本中，如何写入注释？</p><p>注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 # 开头。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 ## This is a command</span><br><span class="line">3  echo “I am logged in as $USER”</span><br></pre></td></tr></table></figure><h2 id="语法级"><a href="#语法级" class="headerlink" title="语法级"></a>语法级</h2><p>可以在 Shell 脚本中使用哪些类型的变量？</p><p>在 Shell 脚本，我们可以使用两种类型的变量：</p><ul><li><p>系统定义变量<br>系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 set 命令查看。</p></li><li><p>用户定义变量<br>用户变量由系统用户来生成和定义，变量的值可以通过命令 “echo $&lt;变量名&gt;” 查看。<br>Shell脚本中 $? 标记的用途是什么？在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 if 条件中使用 $? 可以来检查前一命令的结束状态。</p></li><li><p>如果结束状态是 0 ，说明前一个命令执行成功。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1root@localhost:~## ls /usr/bin/shar</span><br><span class="line">2/usr/bin/shar</span><br><span class="line">3root@localhost:~## echo $?</span><br><span class="line">40</span><br></pre></td></tr></table></figure></li><li><p>如果结束状态不是0，说明命令执行失败。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1root@localhost:~## ls /usr/bin/share</span><br><span class="line">2ls: cannot access /usr/bin/share: No such file or directory 3 root@localhost:~## echo $?</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure></li></ul><p>Bourne Shell(bash) 中有哪些特殊的变量？下面的表列出了 Bourne Shell 为命令行设置的特殊变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1内建变量 解释</span><br><span class="line">2$0 命令行中的脚本名字</span><br><span class="line">3$1 第一个命令行参数</span><br><span class="line">4$2 第二个命令行参数</span><br><span class="line">5….. …….</span><br><span class="line">6$9 第九个命令行参数</span><br><span class="line">7$## 命令行参数的数量</span><br><span class="line">8$* 所有命令行参数，以空格隔开</span><br></pre></td></tr></table></figure><p>如何取消变量或取消变量赋值？ unset 命令用于取消变量或取消变量赋值。语法如下所示：</p><p><code>1 ## unset &lt;变量名&gt;</code></p><p>Shell 脚本中 if 语法如何嵌套?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1  if [ 条件 ]</span><br><span class="line">2  then</span><br><span class="line">3  命令1</span><br><span class="line">4  命令2</span><br><span class="line">5 …..</span><br><span class="line">6  else</span><br><span class="line">7  if [ 条件 ]</span><br><span class="line">8  then</span><br><span class="line">9  命令1</span><br><span class="line">10  命令2</span><br><span class="line">11  ….</span><br><span class="line">12  else</span><br><span class="line">13  命令1</span><br><span class="line">14  命令2</span><br><span class="line">15  …..</span><br><span class="line">16  fi</span><br><span class="line">17  fi</span><br></pre></td></tr></table></figure><p>在 Shell 脚本中如何比较两个数字？在 if-then 中使用测试命令（ -gt 等）来比较两个数字。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 x=10</span><br><span class="line">3 y=20</span><br><span class="line">4 if [ $x ‐gt $y ]</span><br><span class="line">5  then</span><br><span class="line">6  echo “x is greater than y”</span><br><span class="line">7  else</span><br><span class="line">8  echo “y is greater than x”</span><br><span class="line">9 fi</span><br></pre></td></tr></table></figure><p>Shell 脚本中 case 语句的语法?</p><p>基础语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1case 变量 in</span><br><span class="line">2值1)</span><br><span class="line">3命令1</span><br><span class="line">4命令2</span><br><span class="line">5…..</span><br><span class="line">6最后命令</span><br><span class="line">!!</span><br><span class="line">7</span><br><span class="line">8值2)</span><br><span class="line">9命令1</span><br><span class="line">10命令2</span><br><span class="line">11……</span><br><span class="line">12最后命令</span><br><span class="line">13;;</span><br><span class="line">14esac</span><br></pre></td></tr></table></figure><p>Shell 脚本中 for 循环语法？基础语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  for 变量 in 循环列表</span><br><span class="line">2 do</span><br><span class="line">3  命令1</span><br><span class="line">4  命令2</span><br><span class="line">5 ….</span><br><span class="line">6  最后命令</span><br><span class="line">7  done</span><br></pre></td></tr></table></figure><p>Shell 脚本中 while 循环语法？如同 for 循环，while 循环只要条件成立就重复它的命令块。不同于 for循环，while 循环会不断迭代，直到它的条件不为真。基础语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1while [ 条件 ]</span><br><span class="line">2do</span><br><span class="line">3命令…</span><br><span class="line">4done</span><br></pre></td></tr></table></figure><p>do-while 语句的基本格式？</p><p>do-while 语句类似于 while 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 do-while 语句的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1do</span><br><span class="line">2&#123;</span><br><span class="line">3命令</span><br><span class="line">4&#125; while (条件)</span><br></pre></td></tr></table></figure><p>Shell 脚本中 break 命令的作用？</p><p>break 命令一个简单的用途是退出执行中的循环。我们可以在 while 和 until 循环中使用 break 命令跳出循环。 Shell 脚本中 continue 命令的作用？ continue 命令不同于 break 命令，它只跳出当前循环的迭代，而不是整个循环。 continue 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p><p>如何使脚本可执行?</p><p>使用 chmod 命令来使脚本可执行。例子如下：chmod a+x myscript.sh 。</p><p>#!&#x2F;bin&#x2F;bash 的作用？</p><p>#!&#x2F;bin&#x2F;bash 是 Shell 脚本的第一行，称为释伴（shebang）行。</p><p>这里 # 符号叫做 hash ，而 ! 叫做 bang。它的意思是命令通过 &#x2F;bin&#x2F;bash 来执行。</p><p>如何调试 Shell脚本？</p><p>使用 -x’ 数（sh -x myscript.sh）可以调试 Shell脚本。另一个种方法是使用 -nv 参数(sh -nv myscript.sh)。</p><p>如何将标准输出和错误输出同时重定向到同一位置?</p><p>方法一：2&gt;&amp;1 (如## ls &#x2F;usr&#x2F;share&#x2F;doc &gt; out.txt 2&gt;&amp;1 ) 。</p><p>方法二：&amp;&gt; (如## ls &#x2F;usr&#x2F;share&#x2F;doc &amp;&gt; out.txt ) 。</p><p>在 Shell 脚本中，如何测试文件？</p><p>test 命令可以用来测试文件。基础用法如下表格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1Test 用法</span><br><span class="line">2‐d 文件名 如果文件存在并且是目录，返回true</span><br><span class="line">3‐e 文件名 如果文件存在，返回true</span><br><span class="line">4‐f 文件名 如果文件存在并且是普通文件，返回true</span><br><span class="line">5‐r 文件名 如果文件存在并可读，返回true</span><br><span class="line">6‐s 文件名 如果文件存在并且不为空，返回true</span><br><span class="line">7‐w 文件名 如果文件存在并可写，返回true</span><br><span class="line">8‐x 文件名 如果文件存在并可执行，返回true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Shell 脚本如何定义函数呢？</p><p>函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1$ diskusage () &#123; df ‐h ; &#125;</span><br><span class="line">2译注：下面是我给的shell函数语法，原文没有</span><br><span class="line">3[ function ] 函数名 [()]</span><br><span class="line">4&#123;</span><br><span class="line">5命令;</span><br><span class="line">6[return int;]</span><br><span class="line">7&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何让 Shell 就脚本得到来自终端的输入?</p><p>read 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1## vi /tmp/test.sh</span><br><span class="line">!/</span><br><span class="line">2#bin/bash</span><br><span class="line">3echo ‘Please enter your name’</span><br><span class="line">4read name</span><br><span class="line">5echo “My Name is $name”</span><br><span class="line">6## ./test.sh</span><br><span class="line">7Please enter your name</span><br><span class="line">8ThinkWon</span><br><span class="line">9My Name is ThinkWon</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何执行算术运算？</p><p>有两种方法来执行算术运算：</p><p>1、使用 expr 命令：## expr 5 + 2 。</p><p> 2、用一个美元符号和方括号（$[ 表达式 ]）：test&#x3D;$[16 + 4] ; test&#x3D;$[16 + 4] </p><h2 id="编程题-。"><a href="#编程题-。" class="headerlink" title="编程题(。)"></a>编程题(。)</h2><p>判断一文件是不是字符设备文件，如果是将其拷贝到 &#x2F;dev 目录下？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2  read ‐p &quot;Input file name: &quot; FILENAME</span><br><span class="line">3 if [ ‐c &quot;$FILENAME&quot; ];then</span><br><span class="line">4cp $FILENAME /dev</span><br><span class="line">5 fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> #!/bin/bash</span><br><span class="line">2  groupadd class1</span><br><span class="line">3 for((i=1;i&lt;31;i++))</span><br><span class="line">4 do</span><br><span class="line">5   if [ $i ‐le 10 ];then</span><br><span class="line">6   useradd ‐g class1 std0$i</span><br><span class="line">7   else</span><br><span class="line">8   useradd ‐g class1 std$i</span><br><span class="line">9   fi</span><br><span class="line">10  done</span><br></pre></td></tr></table></figure><p>编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 for((i=1;i&lt;51;i++))</span><br><span class="line">3 do</span><br><span class="line">4   userdel ‐r stud$i</span><br><span class="line">5  done</span><br></pre></td></tr></table></figure><p>写一个 sed 命令，修改 &#x2F;tmp&#x2F;input.txt 文件的内容？</p><p>要求：</p><p>删除所有空行。</p><p>一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 &#96;000111112222 的一行改为 0000AAA11111BBB2222 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1[root@~]## cat ‐n /tmp/input.txt</span><br><span class="line">21 000011111222</span><br><span class="line">32</span><br><span class="line">43 000011111222222</span><br><span class="line">54 11111000000222</span><br><span class="line">65</span><br><span class="line">76</span><br><span class="line">87 111111111111122222222222</span><br><span class="line">98 2211111111</span><br><span class="line">109 112222222</span><br><span class="line">1110 1122</span><br><span class="line">1211</span><br><span class="line">13</span><br><span class="line">14## 删除所有空行命令</span><br><span class="line">15[root@~]## sed &#x27;/^$/d&#x27; /tmp/input.txt</span><br><span class="line">16000011111222</span><br><span class="line">17000011111222222</span><br><span class="line">1811111000000222</span><br><span class="line">19111111111111122222222222</span><br><span class="line">202211111111</span><br><span class="line">21112222222</span><br><span class="line">221122</span><br><span class="line">23</span><br><span class="line">24## 插入指定的字符</span><br><span class="line">25[root@~]## sed &#x27;s#\(11111\)#AAA\1BBB#g&#x27; /tmp/input.txt</span><br><span class="line">260000AAA11111BBB222</span><br><span class="line">270000AAA11111BBB222222</span><br><span class="line">28AAA11111BBB000000222</span><br><span class="line">29AAA11111BBBAAA11111BBB11122222222222</span><br><span class="line">3022AAA11111BBB111</span><br><span class="line">31112222222</span><br><span class="line">321122</span><br></pre></td></tr></table></figure><p>实战如何选择 Linux 操作系统版本?</p><p>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</p><p>根据具体要求：</p><p>安全性要求较高，则选择 Debian 或者 FreeBSD 。</p><p>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</p><p>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</p><p> 【重点】根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS </p><p>更侧重服务器领域，并且无版权约束。</p><p>CentOS 7 系列，也慢慢使用的会比较多了。</p><h2 id="如何规划一台-Linux-主机，步骤是怎样？"><a href="#如何规划一台-Linux-主机，步骤是怎样？" class="headerlink" title="如何规划一台 Linux 主机，步骤是怎样？"></a>如何规划一台 Linux 主机，步骤是怎样？</h2><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p><p>不同的用途，机器的配置会有所不同。</p><p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p><p> 3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p><h2 id="请问当用户反馈网站访问慢，你会如何处理？"><a href="#请问当用户反馈网站访问慢，你会如何处理？" class="headerlink" title="请问当用户反馈网站访问慢，你会如何处理？"></a>请问当用户反馈网站访问慢，你会如何处理？</h2><p>有哪些方面的因素会导致网站网站访问慢？</p><p>1、服务器出口带宽不够用</p><ul><li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li><li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li></ul><p> 2、服务器负载过大，导致响应不过来</p><p>可以从两个方面入手分析：</p><ul><li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li><li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li></ul><p>3、数据库瓶颈</p><ul><li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li></ul><p>4、网站开发代码没有优化好</p><ul><li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li></ul><p>针对网站访问慢，怎么去排查？</p><p> 1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p><p> 2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p><p> 3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。  </p><p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。怎么去解决？</p><p>1、   如果是出口带宽问题，那么久申请加大出口带宽。</p><p>2、   如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</p><p>3、   如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</p><p>4、   申请购买 CDN 服务，加载用户的访问。</p><p>5、   如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</p><h2 id="Linux-性能调优都有哪几种方法？"><a href="#Linux-性能调优都有哪几种方法？" class="headerlink" title="Linux 性能调优都有哪几种方法？"></a>Linux 性能调优都有哪几种方法？</h2><p>1、Disabling daemons (关闭 daemons)。</p><p>2、Shutting down the GUI (关闭 GUI)。</p><p>3、Changing kernel parameters (改变内核参数)。</p><p>4、Kernel parameters (内核参数)。</p><p>5、Tuning the processor subsystem (处理器子系统调优)。</p><p>6、Tuning the memory subsystem (内存子系统调优)。</p><p>7、Tuning the file system (文件系统子系统调优)。</p><p>8、Tuning the network subsystem（网络子系统调优)。</p><h2 id="文件管理命令-cat-命令"><a href="#文件管理命令-cat-命令" class="headerlink" title="文件管理命令 cat 命令"></a>文件管理命令 cat 命令</h2><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>cat 主要有三大功能：</p><p>1.一次显示整个文件:</p><p><code>cat filename</code></p><p>2.从键盘创建一个文件</p><p><code>cat &gt; filename</code></p><p>只能创建新文件,不能编辑已有文件</p><p>3.将几个文件合并为一个文件:</p><p><code>cat file1 file2 &gt; file</code></p><ul><li>-b 对非空输出行号</li><li>-n 输出所有行号实例：</li></ul><p>（1）  把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p><p><code>1  cat ‐n log2012.log log2013.log</code></p><p>（2）  把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p><p><code>1  cat ‐b log2012.log log2013.log log.log</code></p><p>（3）  使用 here doc 生成新文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1cat &gt;log.txt &lt;&lt;EOF</span><br><span class="line">2&gt;Hello</span><br><span class="line">3&gt;World</span><br><span class="line">4&gt;PWD=$(pwd)</span><br><span class="line">5&gt;EOF</span><br><span class="line">6ls ‐l log.txt</span><br><span class="line">7cat log.txt</span><br><span class="line">8Hello</span><br><span class="line">9World</span><br><span class="line">=/</span><br><span class="line">10PWD opt/soft/test</span><br></pre></td></tr></table></figure><p>（4）  反向列示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1tac log.txt</span><br><span class="line">=/</span><br><span class="line">2PWD opt/soft/test</span><br><span class="line">3World</span><br><span class="line">4Hello</span><br></pre></td></tr></table></figure><h2 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h2><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p><p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p><p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。</p><p>以文件 log2012.log 为例：</p><p><code>1 ‐rw‐r‐‐r‐‐ 1 root root 296K 11‐13 06:03 log2012.log</code></p><p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1‐c 当发生改变时，报告处理信息</span><br><span class="line">2‐R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure><p>权限范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1u ：目录或者文件的当前的用户</span><br><span class="line">2g ：目录或者文件的当前的群组</span><br><span class="line">3o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">4a ：所有的用户及群组</span><br></pre></td></tr></table></figure><p>权限代号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1r ：读权限，用数字4表示</span><br><span class="line">2w ：写权限，用数字2表示</span><br><span class="line">3x ：执行权限，用数字1表示</span><br><span class="line">4‐ ：删除权限，用数字0表示</span><br><span class="line">5s ：特殊权限</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  增加文件 t.log 所有用户可执行权限</p><p><code>1  chmod a+x t.log</code></p><p>（2）  撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p><p><code>1  chmod u=r t.log ‐c</code></p><p>（3）  给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行</p><p>(5)的权限，给其他用户分配执行(1)的权限</p><p><code>1  chmod 751 t.log ‐c（或者：chmod u=rwx,g=rx,o=x t.log ‐c)</code></p><p>（4）  将 test 目录及其子目录所有文件添加可读权限</p><p><code>1  chmod u+r,g+r,o+r ‐R text/ ‐c</code></p><h2 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h2><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1‐c 显示更改的部分的信息</span><br><span class="line">2‐R 处理指定目录及子目录</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  改变拥有者和群组 并显示改变信息</p><p><code>1  chown ‐c mail:mail log2012.log</code></p><p>（1）  改变文件群组</p><p><code>1  chown ‐c :mail t.log</code></p><p>（2）  改变文件夹及子文件目录属主及属组为 mail</p><p><code>1  chown ‐cR mail: test/</code></p><h2 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h2><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1‐i 提示</span><br><span class="line">2‐r 复制目录及目录内所有项目</span><br><span class="line">3‐a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p><p><code>1  cp ‐ai a.txt test</code></p><p>（2）  为 a.txt 建议一个链接（快捷方式）</p><p><code>1  cp ‐s a.txt link_a.txt</code></p><h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><p>用于在文件树中查找文件，并作出相应的处理。</p><p>命令格式：</p><p><code>1 find pathname ‐options [‐print ‐exec ‐ok ...]</code></p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</span><br><span class="line">2‐print： find命令将匹配的文件输出到标准输出。</span><br><span class="line">3‐exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;comm and&#x27; &#123; &#125; \;，注意&#123; &#125;和\；之间的空格。</span><br><span class="line">4‐ok： 和‐exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure><p>命令选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1‐name 按照文件名查找文件</span><br><span class="line">2‐perm 按文件权限查找文件</span><br><span class="line">3‐user 按文件属主查找文件</span><br><span class="line">4‐group 按照文件所属的组来查找文件。</span><br><span class="line">5‐type 查找某一类型的文件，诸如：</span><br><span class="line">6b ‐ 块设备文件</span><br><span class="line">7d ‐ 目录</span><br><span class="line">8c ‐ 字符设备文件</span><br><span class="line">9l ‐ 符号链接文件</span><br><span class="line">10p ‐ 管道文件</span><br><span class="line">11f ‐ 普通文件</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  查找 48 小时内修改过的文件</p><p><code>1  find ‐atime ‐2</code></p><p>（2）  在当前目录查找 以 .log 结尾的文件。 . 代表当前目录</p><p><code>1  find ./ ‐name &#39;*.log&#39;</code></p><p>（3）  查找 &#x2F;opt 目录下 权限为 777 的文件</p><p><code>1  find /opt ‐perm 777</code></p><p>（4）  查找大于 1K 的文件</p><p><code>1  find ‐size +1000c</code></p><p>查找等于 1000 字符的文件</p><p><code>1 find ‐size 1000c</code></p><p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以</p><p>这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。</p><h2 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h2><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。常用参数：</p><p><code>1 ‐n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</code></p><p>实例：</p><p>（1）  显示 1.log 文件中前 20 行</p><p><code>1  head 1.log ‐n 20</code></p><p>（2）  显示 1.log 文件前 20 字节</p><p><code>1  head ‐c 20 log2014.log</code></p><p>（3）  显示 t.log  后 10 行</p><p><code>1  head ‐n ‐10 t.log</code></p><h2 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h2><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。常用命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1‐i 忽略搜索时的大小写</span><br><span class="line">2‐N 显示每行的行号</span><br><span class="line">3‐o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">4‐s 显示连续空行为一行</span><br><span class="line">5/字符串：向下搜索“字符串”的功能</span><br><span class="line">6?字符串：向上搜索“字符串”的功能</span><br><span class="line">7n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">8N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">9‐x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">10b 向后翻一页</span><br><span class="line">11d 向后翻半页</span><br><span class="line">12h 显示帮助界面</span><br><span class="line">13Q 退出less 命令</span><br><span class="line">14u 向前滚动半页</span><br><span class="line">15y 向前滚动一行</span><br><span class="line">16空格键 滚动一行</span><br><span class="line">17回车键 滚动一页</span><br><span class="line">18[pagedown]： 向下翻动一页</span><br><span class="line">19[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  ps 查看进程信息并通过 less 分页显示</p><p><code>1  ps ‐aux | less ‐N</code></p><p>（2）  查看多个文件</p><p><code>1  less 1.log 2.log</code></p><p>可以使用 n 查看下一个，使用 p 查看前一个。</p><h2 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h2><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p><p>链接分类：软件链接及硬链接软链接：</p><p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</p><p>2.软链接可以 跨文件系统 ，硬链接不可以</p><p>3.软链接可以对一个不存在的文件名进行链接</p><p>4.软链接可以对目录进行链接硬链接:</p><p>1.硬链接，以文件副本的形式存在。但不占用实际空间。</p><p>2.不允许给目录创建硬链接</p><p>3.硬链接只有在同一个文件系统中才能创建需要注意：</p><p> 第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</p><p> 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p><p> 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且  后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且  后的目的地并非是一个已存在的目录，则会出现错误信息。</p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1‐b 删除，覆盖以前建立的链接</span><br><span class="line">2‐s 软链接（符号链接）</span><br><span class="line">3‐v 显示详细处理过程</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  给文件创建软链接，并显示操作信息</p><p><code>1  ln ‐sv source.log link.log</code></p><p>（2）  给文件创建硬链接，并显示操作信息</p><p><code>1  ln ‐v source.log link1.log</code></p><p>（3）  给目录创建软链接</p><p><code>1  ln ‐sv /opt/soft/test/test3 /opt/soft/test/test5</code></p><h2 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h2><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb </p><p>程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 </p><p>locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是  近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 </p><p>(etc&#x2F;crontab)。</p><p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1‐l num（要显示的行数）</span><br><span class="line">2‐f 将特定的档案系统排除在外，如将proc排除在外</span><br><span class="line">3‐r 使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  查找和 pwd 相关的所有文件(文件名中包含 pwd）</p><p><code>1  locate pwd</code></p><p>（2）  搜索 etc 目录下所有以 sh 开头的文件</p><p><code>1  locate /etc/sh</code></p><p>（3）  查找 &#x2F;var 目录下，以 reason 结尾的文件</p><p><code>1  locate ‐r &#39;^/var.*reason$&#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</code></p><h2 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h2><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而 基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1  +n 从笫 n 行开始显示</span><br><span class="line">2  ‐n 定义屏幕大小为n行</span><br><span class="line">3  +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</span><br><span class="line">4  ‐c 从顶部清屏，然后显示</span><br><span class="line">5  ‐d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">6  ‐l 忽略Ctrl+l（换页）字符</span><br><span class="line">7  ‐p 通过清除窗口而不是滚屏来对文件进行换页，与‐c选项相似</span><br><span class="line">8  ‐s 把连续的多个空行显示为一行</span><br><span class="line">9  ‐u 把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure><p>常用操作命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1  Enter 向下 n 行，需要定义。默认为 1 行</span><br><span class="line">2  Ctrl+F 向下滚动一屏</span><br><span class="line">3  空格键 向下滚动一屏</span><br><span class="line">4  Ctrl+B 返回上一屏</span><br><span class="line">5  = 输出当前行的行号</span><br><span class="line">6  :f 输出文件名和当前行的行号</span><br><span class="line">7  V 调用vi编辑器</span><br><span class="line">8  !命令 调用Shell，并执行命令</span><br><span class="line">9  q 退出more</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  显示文件中从第3行起的内容</p><p><code>1  more +3 text.txt</code></p><p>（2）  在所列出文件目录详细信息，借助管道使每次显示 5 行</p><p><code>1  ls ‐l |more ‐5</code></p><p>按空格显示下 5 行。</p><h2 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h2><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p><p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p><p>实例：</p><p>（1）  将文件 test.log 重命名为 test1.txt</p><p><code>1  mv test.log test1.txt</code></p><p>（2）  将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p><p><code>1  mv llog1.txt log2.txt log3.txt /test3</code></p><p>（3）  将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p><p><code>1  mv ‐i log1.txt log2.txt</code></p><p>（4）  移动当前文件夹下的所有文件到上一级目录</p><p><code>1  mv * ../</code></p><h2 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h2><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p><p><code>1 rm[选项] 文件…</code></p><p>实例：</p><p>（1）  删除任何 .log 文件，删除前逐一询问确认：</p><p><code>1  rm ‐i *.log</code></p><p>（2）  删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p><p><code>1  rm ‐rf test</code></p><p>（3）  删除以 -f 开头的文件</p><p><code>1  rm ‐‐ ‐f*</code></p><h2 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h2><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1‐f 循环读取（常用于查看递增的日志文件）</span><br><span class="line">2‐n&lt;行数&gt; 显示行数（从后向前）</span><br></pre></td></tr></table></figure><p>（1）循环读取逐渐增加的文件内容</p><p><code>1 ping 127.0.0.1 &gt; ping.log &amp;</code></p><p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p><p><code>1 tail ‐f ping.log</code></p><h2 id="（查看日志）-touch-命令"><a href="#（查看日志）-touch-命令" class="headerlink" title="（查看日志） touch 命令"></a>（查看日志） touch 命令</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 touch [‐acfm][‐d&lt;日期时间&gt;][‐r&lt;参考文件或目录&gt;] [‐t&lt;日期时间&gt;][‐‐help][‐‐ver sion][文件或目录…]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li><li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li><li>r 使用参考档的时间记录，与 –file 的效果一样。</li><li>d 设定时间与日期，可以使用各种不同的格式。</li><li>t 设定档案的时间记录，格式与 date 指令相同。</li><li>–no-create 不会建立新档案。</li><li>–help 列出指令格式。</li><li>–version 列出版本讯息。</li></ul><p>实例</p><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p><p><code>1 $ touch testfile #修改文件的时间属性</code></p><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1$ ls ‐l testfile #查看文件的时间属性</span><br><span class="line">2#原来文件的修改时间为16:09</span><br><span class="line">3‐rw‐r‐‐r‐‐ 1 hdd hdd 55 2011‐08‐22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1$ touch testfile #修改文件时间属性为当前系统时间</span><br><span class="line">2$ ls ‐l testfile #查看文件的时间属性</span><br><span class="line">3#修改后文件的时间属性为当前系统时间</span><br><span class="line">4‐rw‐r‐‐r‐‐ 1 hdd hdd 55 2011‐08‐22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p><p><code>1 $ touchfile#创建一个名为“file”的新的空白文件</code></p><h2 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a>vim 命令</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>打开文件并跳到第 10 行：vim +10 filename.txt 。</p><p>打开文件跳到第一个匹配的行：vim +&#x2F;search-term filename.txt 。</p><p>以只读模式打开文件：vim -R &#x2F;etc&#x2F;passwd 。</p><p>基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。简单的说，我们可以将这三个模式想成底下的图标来表示：<img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Vim%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.jpg" alt="Vim工作模式"></p><h2 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h2><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、</p><p>man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1‐b 定位可执行文件。</span><br><span class="line">2‐m 定位帮助文件。</span><br><span class="line">3‐s 定位源代码文件。</span><br><span class="line">4‐u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  查找 locate 程序相关文件</p><p><code>1  whereislocate</code></p><p>（2）  查找 locate 的源码文件</p><p><code>1  whereis ‐s locate</code></p><p>（3）  查找 lcoate 的帮助文件</p><p><code>1  whereis ‐m locate</code></p><h2 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h2><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1which 查看可执行文件的位置。</span><br><span class="line">2whereis 查看文件的位置。</span><br><span class="line">3locate 配合数据库查看文件位置。</span><br><span class="line">4find 实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure><p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>常用参数：</p><p><code>1 ‐n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</code></p><p>实例：</p><p>（1）  查看 ls 命令是否存在，执行哪个</p><p><code>1  whichls</code></p><p>（2）  查看 which</p><p><code>1  whichwhich</code></p><p>（3）  查看 cd</p><p><code>1  which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</code></p><p>查看当前 PATH 配置：</p><p>&#96;1 echo$PATH</p><p>或使用 env 查看所有环境变量及对应值文档编辑命令 grep 命令</p><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p><p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>命令格式：</p><p><code> grep [option] pattern file|dir</code></p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1‐A n ‐‐after‐context显示匹配字符后n行</span><br><span class="line">2‐B n ‐‐before‐context显示匹配字符前n行</span><br><span class="line">3‐C n ‐‐context 显示匹配字符前后n行</span><br><span class="line">4‐c ‐‐count 计算符合样式的列数</span><br><span class="line">5‐i 忽略大小写</span><br><span class="line">6‐l 只列出文件内容符合指定的样式的文件名称</span><br><span class="line">7‐f 从文件中读取关键词</span><br><span class="line">8‐n 显示匹配内容的所在文件中行数</span><br><span class="line">9‐R 递归查找文件夹</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>grep 的规则表达式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ^ #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。 2 $ #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。</span><br><span class="line">3. #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。</span><br><span class="line">4* #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。</span><br><span class="line">5.* #一起用代表任意字符。</span><br><span class="line">6[] #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。</span><br><span class="line">7[^] #匹配一个不在指定范围内的字符，如：&#x27;[^A‐FH‐Z]rep&#x27;匹配不包含A‐R和T‐Z的一个</span><br><span class="line">字母开头，紧跟rep的行。</span><br><span class="line">8\(..\) #标记匹配字符，如&#x27;\(love\)&#x27;，love被标记为1。</span><br><span class="line">9\&lt; #锚定单词的开始，如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行。</span><br><span class="line">10\&gt; #锚定单词的结束，如&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行。</span><br><span class="line">11x\&#123;m\&#125; #重复字符x，m次，如：&#x27;0\&#123;5\&#125;&#x27;匹配包含5个o的行。</span><br><span class="line">12x\&#123;m,\&#125; #重复字符x,至少m次，如：&#x27;o\&#123;5,\&#125;&#x27;匹配至少有5个o的行。</span><br><span class="line">13x\&#123;m,n\&#125; #重复字符x，至少m次，不多于n次，如：&#x27;o\&#123;5,10\&#125;&#x27;匹配5‐‐10个o的行。</span><br><span class="line">14\w #匹配文字和数字字符，也就是[A‐Za‐z0‐9]，如：&#x27;G\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。</span><br><span class="line">15\W #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。</span><br><span class="line">16\b #单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：（1）查找指定进程</p><p><code>1 ps ‐ef |grep svn</code></p><p>（2）  查找指定进程个数</p><p><code>1  ps ‐ef |grep svn ‐c</code></p><p>（3）  从文件中读取关键词</p><p><code>1  cat test1.txt |grep ‐f key.log</code></p><p>（4）  从文件夹中递归查找以grep开头的行，并只列出文件</p><p><code>1  grep ‐lR &#39;^grep&#39; /tmp</code></p><p>（5）  查找非x开关的行内容</p><p><code>1  grep&#39;^[^x]&#39; test.txt</code></p><p>（6）  显示包含 ed 或者 at 字符的内容行</p><p><code>1  grep ‐E &#39;ed|at&#39; test.txt</code></p><h2 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h2><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出命令格式：</p><p><code>1 wc [option] file..</code></p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1‐c 统计字节数</span><br><span class="line">2‐l 统计行数</span><br><span class="line">3‐m 统计字符数</span><br><span class="line">4‐w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  查找文件的 行数 单词数 字节数 文件名</p><p><code>1  wc text.txt</code></p><p>结果：</p><p><code>1 7 8 70 test.txt</code></p><p>（2）  统计输出结果的行数</p><p><code>1  cat test.txt |wc ‐l</code></p><h1 id="磁盘管理命令-cd-命令"><a href="#磁盘管理命令-cd-命令" class="headerlink" title="磁盘管理命令 cd 命令"></a>磁盘管理命令 cd 命令</h1><p>cd(changeDirectory) 命令语法：</p><p><code>1 cd [目录名]</code></p><p>说明：切换当前目录至 dirName。</p><p>实例：（1）进入要目录</p><p><code>1 cd /</code></p><p>（2）  进入 “home” 目录</p><p><code>1  cd ~</code></p><p>（3）  进入上一次工作路径</p><p><code>1  cd ‐</code></p><p>（4）  把上个命令的参数作为cd参数使用。</p><p><code>1  cd!$</code></p><h2 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h2><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显</p><p>示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 </p><p>POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1‐a 全部文件系统列表</span><br><span class="line">2‐h 以方便阅读的方式显示信息</span><br><span class="line">3‐i 显示inode信息</span><br><span class="line">4‐k 区块为1024字节</span><br><span class="line">5‐l 只显示本地磁盘</span><br><span class="line">6‐T 列出文件系统类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  显示磁盘使用情况</p><p>1  df ‐l</p><p>（2）  以易读方式列出所有文件系统及其类型</p><p>1  df ‐haT</p><h2 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h2><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：命令格式：</p><p>1 du [选项] [文件]</p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1‐a 显示目录中所有文件大小</span><br><span class="line">2‐k 以KB为单位显示文件大小</span><br><span class="line">3‐m 以MB为单位显示文件大小</span><br><span class="line">4‐g 以GB为单位显示文件大小</span><br><span class="line">5‐h 以易读方式显示文件大小</span><br><span class="line">6‐s 仅显示总计</span><br><span class="line">7‐c或‐‐total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  以易读方式显示文件夹内及子文件夹大小</p><p><code>1  du ‐h scf/</code></p><p>（2）  以易读方式显示文件夹内所有文件大小</p><p><code>1  du ‐ah scf/</code></p><p>（3）  显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p><p><code>1  du ‐hc test/ scf/</code></p><p>（4）  输出当前目录下各个子目录所使用的空间</p><p><code>1  du ‐hc ‐‐max‐depth=1 scf/</code></p><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限) 查看目录信息等等。</p><p>常用参数搭配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1ls ‐a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="line">2ls ‐A 列出除.及..的其它文件</span><br><span class="line">3ls ‐r 反序排列</span><br><span class="line">4ls ‐t 以文件修改时间排序</span><br><span class="line">5ls ‐S 以文件大小排序</span><br><span class="line">6ls ‐h 以易读大小显示</span><br><span class="line">7ls ‐l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p><p><code>1  ls ‐lhrt</code></p><p>(2) 按大小反序显示文件详细信息</p><p><code>1  ls ‐lrS</code></p><p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p><p><code>1 ls ‐l t*</code></p><p>(4) 列出文件绝对路径（不包含隐藏文件）</p><p><code>1  ls|sed&quot;s:^:</code>pwd<code>/:&quot;</code></p><p>(5) 列出文件绝对路径（包含隐藏文件）</p><p><code>1  find$pwd ‐maxdepth 1 |xargsls ‐ld</code></p><h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><p>mkdir 命令用于创建文件夹。</p><p>可用选项：</p><p>-m: 对新建目录设置存取权限，也可以用 chmod 命令设置;</p><p> -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</p><p>实例：</p><p>（1）  当前工作目录下创建名为 t的文件夹</p><p><code>1 mkdir t</code></p><p>（2）  在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建：</p><p> <code>1 mkdir ‐p /tmp/test/t1/t  </code></p><h2 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h2><p>pwd 命令用于查看当前工作目录路径。</p><p>实例：</p><p>（1）  查看当前路径</p><p><code>1 pwd</code></p><p>（2）  查看软链接的实际路径</p><p><code>1 pwd</code></p><h2 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h2><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p>注意：不能删除非空目录实例：</p><p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p><p>  <code>1 rmdir ‐p parent/child/child11  </code></p><h2 id="网络通讯命令-ifconfig-命令"><a href="#网络通讯命令-ifconfig-命令" class="headerlink" title="网络通讯命令 ifconfig 命令"></a>网络通讯命令 ifconfig 命令</h2><ul><li>ifconfig 用于查看和配置 Linux 系统的网络接口。</li><li>查看所有网络接口及其状态：ifconfig -a 。</li><li>使用 up 和 down 命令启动或停止某个接口：ifconfig eth0 up 和 ifconfig eth0 down 。</li></ul><p>iptables 命令</p><p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于</p><p>我们开发来说，主要掌握如何开放端口即可。例如：</p><p> 把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝： iptables -I INPUT -s 192.168.1.101 -p tcp –dport 80 -j REJECT 。 </p><p> 开启 80 端口，因为web对外都是这个端口</p><p>iptables -A INPUT -p tcp –dport 80 -j ACCEP</p><p>​                    1</p><p> 另外，要注意使用 iptables save 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p><h2 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h2><p>Linux netstat命令用于显示网络状态。</p><p>利用netstat指令可让你得知整个Linux系统的网络情况。语法</p><p>  <code>1 netstat [‐acCeFghilMnNoprstuvVwx][‐A&lt;网络类型&gt;][‐‐ip]</code></p><p>参数说明：</p><ul><li>-a或–all 显示所有连线中的Socket。</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li><li>-c或–continuous 持续列出网络状态。</li><li>-C或–cache 显示路由器配置的快取信息。</li><li>-e或–extend 显示网络其他相关信息。</li><li>-F或–fib 显示FIB。</li><li>-g或–groups 显示多重广播功能群组组员名单。</li><li>-h或–help 在线帮助。</li><li>-i或–interfaces 显示网络界面信息表单。</li><li>-l或–listening 显示监控中的服务器的Socket。</li><li>-M或–masquerade 显示伪装的网络连线。</li><li>-n或–numeric 直接使用IP地址，而不通过域名服务器。</li><li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。</li><li>-o或–timers 显示计时器。</li><li>-p或–programs 显示正在使用Socket的程序识别码和程序名称。</li><li>-r或–route 显示Routing Table。</li><li>-s或–statistice 显示网络工作信息统计表。</li><li>-t或–tcp 显示TCP传输协议的连线状况。</li><li>-u或–udp 显示UDP传输协议的连线状况。</li><li>-v或–verbose 显示指令执行过程。</li><li>-V或–version 显示版本信息。</li><li>-w或–raw 显示RAW传输协议的连线状况。</li><li>-x或–unix 此参数的效果和指定”-A unix”参数相同。</li><li>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</li></ul><p>实例如何查看系统都开启了哪些端口？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1[root@centos6 ~ 13:20 #55]# netstat ‐lnp</span><br><span class="line">2Active Internet connections (only servers)</span><br><span class="line">3Proto Recv‐Q Send‐Q Local Address Foreign Address State PID/Program name</span><br><span class="line">4tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1035/sshd</span><br><span class="line">5tcp 0 0 :::22 :::* LISTEN 1035/sshd</span><br><span class="line">6udp 0 0 0.0.0.0:68 0.0.0.0:* 931/dhclient 7 Active UNIX domain sockets (only servers)</span><br><span class="line">8Proto RefCnt Flags Type State I‐Node PID/Program name Path</span><br><span class="line">9unix 2 [ ACC ] STREAM LISTENING 6825 1/init @/com/ubuntu/upstart</span><br><span class="line">10unix 2 [ ACC ] STREAM LISTENING 8429 1003/dbus‐daemon /var/run/dbus/syst em_bus_socket</span><br></pre></td></tr></table></figure><p>如何查看网络连接状况？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1[root@centos6 ~ 13:22 #58]# netstat ‐an</span><br><span class="line">2Active Internet connections (servers and established)</span><br><span class="line">3Proto Recv‐Q Send‐Q Local Address Foreign Address State</span><br><span class="line">4tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN</span><br><span class="line">5tcp 0 0 192.168.147.130:22 192.168.147.1:23893 ESTABLISHED</span><br><span class="line">6tcp 0 0 :::22 :::* LISTEN</span><br><span class="line">7udp 0 0 0.0.0.0:68 0.0.0.0:*</span><br></pre></td></tr></table></figure><p>如何统计系统当前进程连接数？输入命令 netstat -an | grep ESTABLISHED | wc -l 。输出结果 177 。一共有 177 连接数。用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 </p><p>ESTABLISHED 状态链接的个数？严格来说，这个题目考验的是对 awk 的使用。</p><p>首先，使用 netstat -an|grep ESTABLISHED 命令。结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 tcp 0 0 120.27.146.122:80 113.65.18.33:62721 ESTABLISHED 2 tcp 0 0 120.27.146.122:80 27.43.83.115:47148 ESTABLISHED</span><br><span class="line">3tcp 0 0 120.27.146.122:58838 106.39.162.96:443 ESTABLISHED</span><br><span class="line">4tcp 0 0 120.27.146.122:52304 203.208.40.121:443 ESTABLISHED</span><br><span class="line">5tcp 0 0 120.27.146.122:33194 203.208.40.122:443 ESTABLISHED</span><br><span class="line">6tcp 0 0 120.27.146.122:53758 101.37.183.144:443 ESTABLISHED</span><br><span class="line">7tcp 0 0 120.27.146.122:27017 23.105.193.30:50556 ESTABLISHED</span><br></pre></td></tr></table></figure><h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><p>Linux ping命令用于检测主机。</p><p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。指定接收包的次数</p><p><code>1 ping ‐c 2 www.baidu.com</code></p><h2 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h2><p>Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 telnet [‐8acdEfFKLrx][‐b&lt;主机别名&gt;][‐e&lt;脱离字符&gt;][‐k&lt;域名&gt;][‐l&lt;用户名称&gt;][n&lt;记录文件&gt;][‐S&lt;服务类型&gt;][‐X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>8 允许使用8位字符资料，包括输入与输出。 -a 尝试自动登入远端系统。</li><li>-b&lt;主机别名&gt; 使用别名指定远端主机名称。</li><li>-c 不读取用户专属目录里的.telnetrc文件。</li><li>-d 启动排错模式。</li><li>-e&lt;脱离字符&gt; 设置脱离字符。</li><li>-E 滤除脱离字符。</li><li>-f 此参数的效果和指定”-F”参数相同。</li><li>-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li><li>-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li><li>-K 不自动登入远端主机。</li><li>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</li><li>-L 允许输出8位字符资料。</li><li>-n&lt;记录文件&gt; 指定文件记录相关信息。</li><li>-r 使用类似rlogin指令的用户界面。</li><li>-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</li><li>-x 假设主机有支持数据加密的功能，就使用它。</li><li>-X&lt;认证形态&gt; 关闭指定的认证形态。</li></ul><p>实例</p><p>登录远程主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1# 登录IP为 192.168.0.5 的远程主机</span><br><span class="line">2telnet 192.168.0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统管理命令-date-命令"><a href="#系统管理命令-date-命令" class="headerlink" title="系统管理命令 date 命令"></a>系统管理命令 date 命令</h2><p>显示或设定系统的日期与时间。</p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1‐d&lt;字符串&gt;  显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class="line">2‐s&lt;字符串&gt;  根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class="line">3‐u  显示GMT。</span><br><span class="line">4%H 小时(00‐23)</span><br><span class="line">5%I 小时(00‐12)</span><br><span class="line">6%M 分钟(以00‐59来表示)</span><br><span class="line">7%s 总秒数。起算时间为1970‐01‐01 00:00:00 UTC。</span><br><span class="line">8%S 秒(以本地的惯用法来表示) 9 %a 星期的缩写。</span><br><span class="line">10%A 星期的完整名称。</span><br><span class="line">11%d 日期(以01‐31来表示)。</span><br><span class="line">12%D 日期(含年月日)。</span><br><span class="line">13%m 月份(以01‐12来表示)。</span><br><span class="line">14%y 年份(以00‐99来表示)。</span><br><span class="line">15%Y 年份(以四位数来表示)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  显示下一天</p><p><code>1 date +%Y%m%d ‐‐date=&quot;+1 day&quot; //显示下一天的日期</code></p><p>（2）  -d参数使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  date ‐d &quot;nov 22&quot; 今年的 11 月 22 日是星期三</span><br><span class="line">2  date ‐d &#x27;2 weeks&#x27; 2周后的日期</span><br><span class="line">3  date ‐d &#x27;next monday&#x27; (下周一的日期)</span><br><span class="line">4  date ‐d next‐day +%Y%m%d（明天的日期）或者：date ‐d tomorrow +%Y%m%d</span><br><span class="line">5  date ‐d last‐day +%Y%m%d(昨天的日期) 或者：date ‐d yesterday +%Y%m%d</span><br><span class="line">6  date ‐d last‐month +%Y%m(上个月是几月)</span><br><span class="line">7  date ‐d next‐month +%Y%m(下个月是几月)</span><br></pre></td></tr></table></figure><h2 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h2><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1‐b 以Byte显示内存使用情况</span><br><span class="line">2‐k 以kb为单位显示内存使用情况</span><br><span class="line">3‐m 以mb为单位显示内存使用情况</span><br><span class="line">4‐g 以gb为单位显示内存使用情况</span><br><span class="line">5‐s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">6‐t 显示内存使用总合</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  显示内存使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1free</span><br><span class="line">2free ‐k</span><br><span class="line">3free ‐m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）  以总和的形式显示内存的使用信息</p><p><code>1  free ‐t</code></p><p>（2）  周期性查询内存使用情况</p><p><code>1  free ‐s 10</code></p><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进</p><p>程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1‐l 信号，若果不加信号的编号参数，则使用“‐l”参数会列出全部的信号名称</span><br><span class="line">2‐a 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line">3‐p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line">4‐s 指定发送信号</span><br><span class="line">5‐u 指定用户</span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）先使用ps查找进程pro1，然后用kill杀掉</p><p>1 kill ‐9 $(ps ‐ef |grep pro1)</p><h2 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h2><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top linux上进程有5种状态:</p><ol><li><p>运行(正在运行或在运行队列中等待)</p></li><li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p></li><li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p></li><li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p></li><li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运</p></li></ol><p>行)</p><p>ps 工具标识进程的5种状态码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1D 不可中断 uninterruptible sleep (usually IO)</span><br><span class="line">2R 运行 runnable (on run queue)</span><br><span class="line">3S 中断 sleeping</span><br><span class="line">4T 停止 traced or stopped</span><br><span class="line">5Z 僵死 a defunct (”zombie”) process</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1‐A 显示所有进程</span><br><span class="line">2a 显示所有进程</span><br><span class="line">3‐a 显示同一终端下所有进程</span><br><span class="line">4c 显示进程真实名称</span><br><span class="line">5e 显示环境变量</span><br><span class="line">6f 显示进程间的关系</span><br><span class="line">7r 显示当前终端运行的进程</span><br><span class="line">8‐aux 显示所有包含其它使用的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  显示当前所有进程环境变量及进程间关系</p><p><code>1  ps ‐ef</code></p><p>（2）  显示当前所有进程</p><p><code>1  ps ‐A</code></p><p>（3）  与grep联用查找某进程</p><p><code>1  ps ‐aux |grep apache</code></p><p>（4）  找出与 cron 与 syslog 这两个服务有关的 PID 号码</p><p><code>1  ps aux |grep&#39;(cron|syslog)&#39;</code></p><h2 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a>rpm 命令</h2><p>Linux rpm 命令用于管理套件。</p><p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 </p><p>Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1# 查看系统自带jdk</span><br><span class="line">2rpm ‐qa | grep jdk</span><br><span class="line">3# 删除系统自带jdk</span><br><span class="line">4rpm ‐e ‐‐nodeps 查看jdk显示的数据</span><br><span class="line">5# 安装jdk</span><br><span class="line">6rpm ‐ivh jdk‐7u80‐linux‐x64.rpm</span><br></pre></td></tr></table></figure><h2 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h2><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1‐c 显示完整的进程命令</span><br><span class="line">2‐s 保密模式</span><br><span class="line">3‐p &lt;进程号&gt; 指定进程显示</span><br><span class="line">4‐n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1top ‐ 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35</span><br><span class="line">2Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie</span><br><span class="line">3Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st</span><br><span class="line">4Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers</span><br><span class="line">5Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached</span><br><span class="line">6PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">728894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前五行是当前系统情况整体的统计信息区。</p><p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5 分钟、15分钟的负载情况。</p><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p>第二行，Tasks — 任务（进程），具体信息说明如下：系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep）， stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p>第三行，cpu状态信息，具体属性说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15.9%us — 用户空间占用CPU的百分比。</span><br><span class="line">23.4% sy — 内核空间占用CPU的百分比。</span><br><span class="line">30.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class="line">490.4% id — 空闲CPU百分比</span><br><span class="line">50.0% wa — IO等待占用CPU的百分比</span><br><span class="line">60.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class="line">70.2% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure><p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p>第四行，内存状态，具体信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">132949016k total — 物理内存总量（32GB）</span><br><span class="line">214411180k used — 使用中的内存总量（14GB）</span><br><span class="line">318537836k free — 空闲内存总量（18GB）</span><br><span class="line">4  169884k buffers — 缓存的内存量 （169M）</span><br></pre></td></tr></table></figure><p>第五行，swap交换分区信息，具体信息说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  32764556k total — 交换区总量（32GB）</span><br><span class="line">2  0k used — 使用的交换区总量（0K）</span><br><span class="line">3  32764556k free — 空闲交换区总量（32GB）</span><br><span class="line">4  3612636k cached — 缓冲的交换区总量（3.6GB）</span><br></pre></td></tr></table></figure><p>第六行，空行。</p><p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1PID — 进程id</span><br><span class="line">2USER — 进程所有者</span><br><span class="line">3PR — 进程优先级</span><br><span class="line">4NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">5VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">6RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">7SHR — 共享内存大小，单位kb</span><br><span class="line">8S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line">9%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class="line">10%MEM — 进程使用的物理内存百分比</span><br><span class="line">11TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">12COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure><p>top 交互命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 h 显示top交互命令帮助信息</span><br><span class="line">2c 切换显示命令名称和完整命令行</span><br><span class="line">3m 以内存使用率排序</span><br><span class="line">4 P 根据CPU使用百分比大小进行排序</span><br><span class="line">5T 根据时间/累计时间进行排序</span><br><span class="line">6  W 将当前设置写入~/.toprc文件中</span><br><span class="line">7o或者O 改变显示项目的顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="yum-命令"><a href="#yum-命令" class="headerlink" title="yum 命令"></a>yum 命令</h2><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及</p><p>SUSE中的Shell前端软件包管理器。</p><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>1.列出所有可更新的软件清单命令：yum check-update</p><p>2.更新所有软件命令：yum update</p><p>3.仅安装指定的软件命令：yum install</p><p>4.仅更新指定的软件命令：yum update</p><p>5.列出所有可安裝的软件清单命令：yum list</p><p>6.删除软件包命令：</p><ul><li>yum remove 7.查找软件包 命令：</li><li>yum search 8.清除缓存命令:</li><li>yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul><p>实例</p><p>安装 pam-devel</p><p>1 [root@www ~]# yum install pam‐devel</p><h2 id="备份压缩命令-bzip2-命令"><a href="#备份压缩命令-bzip2-命令" class="headerlink" title="备份压缩命令 bzip2 命令"></a>备份压缩命令 bzip2 命令</h2><p>创建 *.bz2 压缩文件：bzip2 test.txt 。解压 *.bz2 文件：bzip2 -d test.txt.bz2 。</p><h2 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h2><p>创建一个 *.gz 的压缩文件：gzip test.txt 。解压 *.gz 文件：gzip -d test.txt.gz 。</p><p>显示压缩的比率：gzip -l *.gz 。</p><h2 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h2><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p><p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1‐c 建立新的压缩文件</span><br><span class="line">2‐f 指定压缩文件</span><br><span class="line">3‐r 添加文件到已经压缩文件包中</span><br><span class="line">4‐u 添加改了和现有的文件到压缩包中</span><br><span class="line">5‐x 从压缩包中抽取文件</span><br><span class="line">6‐t 显示压缩文件中的内容</span><br><span class="line">7‐z 支持gzip压缩</span><br><span class="line">8‐j 支持bzip2压缩</span><br><span class="line">9‐Z 支持compress解压文件</span><br><span class="line">10‐v 显示操作过程</span><br></pre></td></tr></table></figure><p>有关 gzip 及 bzip2 压缩:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1gzip 实例：压缩 gzip fileName .tar.gz 和.tgz 解压：gunzip filename.gz 或 gz ip ‐d filename.gz</span><br><span class="line">2对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz</span><br><span class="line">3</span><br><span class="line">4bz2实例：压缩 bzip2 ‐z filename .tar.bz2 解压：bunzip filename.bz2或bzip ‐d filename.bz2</span><br><span class="line">5对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例：</p><p>（1）  将文件全部打包成 tar 包</p><p><code>1  tar ‐cvf log.tar 1.log,2.log 或tar ‐cvf log.*</code></p><p>（2）  将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p><p><code>1  tar ‐zcvf /tmp/etc.tar.gz /etc</code></p><p>（3）  查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）</p><p><code>1  tar ‐ztvf /tmp/etc.tar.gz</code></p><p>（4）  要压缩打包 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai</p><p><code>1  tar ‐‐exclude /home/dmtsai ‐zcvf myfile.tar.gz /home/* /etc</code></p><h2 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h2><p>解压 *.zip 文件：unzip test.zip 。查看 *.zip 文件的内容：unzip -l jasper.zip 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Tomcat是什么？"><a href="#1-Tomcat是什么？" class="headerlink" title="1. Tomcat是什么？"></a>1. Tomcat是什么？</h2><p>Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放 源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问 用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 </p><h2 id="2-Tomcat的缺省端口是多少，怎么修改"><a href="#2-Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="2. Tomcat的缺省端口是多少，怎么修改"></a>2. Tomcat的缺省端口是多少，怎么修改</h2><p>找到Tomcat目录下的conf文件夹 </p><p>进入conf文件夹里面找到server.xml文件 </p><p>打开server.xml文件 </p><p>在server.xml文件里面找到下列信息 </p><p>把Connector标签的8080端口改成你想要的端口 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;Service name=&quot;Catalina&quot;&gt; </span><br><span class="line">2 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; </span><br><span class="line">3  connectionTimeout=&quot;20000&quot; </span><br><span class="line">4  redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="3-tomcat-有哪几种Connector-运行模式-优化-？"><a href="#3-tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="3. tomcat 有哪几种Connector 运行模式(优化)？"></a>3. tomcat 有哪几种Connector 运行模式(优化)？</h2><p>下面，我们先大致了解Tomcat Connector的三种运行模式。 </p><ul><li><strong>BIO：同步并阻塞</strong> 一个线程处理一个请求。缺点：并发量高时，线程数较 多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。<br><strong>配制项：</strong>protocol&#x3D;”HTTP&#x2F;1.1” </li><li><strong>NIO：同步非阻塞IO</strong> 利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一 个线程处理多个connection(多路复用)。<br>Tomcat8在Linux系统中默认使用这种方式。<br>Tomcat7必须修改Connector配置来启动。<br><strong>配制项：</strong>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol”<br><strong>备注：</strong>我们常用的Jetty，Mina，ZooKeeper等都是基于java nio实现. </li><li><strong>APR：</strong>即Apache Portable Runtime，从操作系统层面解决io阻塞问 题。<strong>AIO方式，异步非阻塞IO</strong>(Java NIO2又叫AIO) 主要与NIO的区别 主要是操作系统的底层区别.可以做个比喻:比作快递，NIO就是网购后要自 己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就 是快递员送货上门了(不用关注快递进度)。<br><strong>配制项：</strong>protocol&#x3D;”org.apache.coyote.http11.Http11AprProtocol”<br><strong>备注：</strong>需在本地服务器安装APR库。Tomcat7或Tomcat8在Win7或以上的系统 中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就 支持apr。</li></ul><h2 id="4-Tomcat有几种部署方式？"><a href="#4-Tomcat有几种部署方式？" class="headerlink" title="4. Tomcat有几种部署方式？"></a>4. Tomcat有几种部署方式？</h2><p>**在Tomcat中部署Web应用的方式主要有如下几种： **</p><ul><li>利用Tomcat的自动部署。<br>把web应用拷贝到webapps目录。Tomcat在启动时会加载目录下的应用，并将 编译后的结果放入work目录下。 </li><li>使用Manager App控制台部署。<br>在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个 web应用的路径或war文件。</li><li>修改conf&#x2F;server.xml文件部署。<br>修改conf&#x2F;server.xml文件，增加Context节点可以部署应用。 </li><li>增加自定义的Web部署文件。<br>在conf&#x2F;Catalina&#x2F;localhost&#x2F; 路径下增加 xyz.xml文件，内容是Context节点， 可以部署应用</li></ul><h2 id="5-tomcat容器是如何创建servlet类实例？用到了什么-原理？"><a href="#5-tomcat容器是如何创建servlet类实例？用到了什么-原理？" class="headerlink" title="5. tomcat容器是如何创建servlet类实例？用到了什么 原理？"></a>5. tomcat容器是如何创建servlet类实例？用到了什么 原理？</h2><ol><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml 文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个 应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候 也是在第一次请求时实例化） </li><li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或 为负数，则第一次请求实例化。</li></ol><h2 id="6-Tomcat工作模式"><a href="#6-Tomcat工作模式" class="headerlink" title="6. Tomcat工作模式"></a>6. Tomcat工作模式</h2><p>Tomcat作为servlet容器，有三种工作模式： </p><ol><li>独立的servlet容器，servlet容器是web服务器的一部分； </li><li>进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实 现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反 应速度快但伸缩性不足； </li><li>进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作 为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性 比进程内优； 进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</li></ol><ul><li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是 Apache, IIS, Nginx等； </li><li>Tomcat作为独立服务器：请求来自于web浏览器；</li></ul><p>面试时问到Tomcat相关问题的几率并不高，正式因为如此，很多人忽略了对 Tomcat相关技能的掌握，下面这一篇文章整理了Tomcat相关的系统架构，介 绍了Server、Service、Connector、Container之间的关系，各个模块的功 能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！</p><p>另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常 见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是 可以往Tomcat处理请求的这个过程去说的！掌握了Tomcat这些技能，面试官 一定会佩服你的！ </p><p>学了本章之后你应该明白的是：</p><ul><li>Server、Service、Connector、Container四大组件之间的关系和联系，以及他 们的主要功能点； </li><li>Tomcat执行的整体架构，请求是如何被一步步处理的； </li><li>Engine、Host、Context、Wrapper相关的概念关系； </li><li>Container是如何处理请求的； </li><li>Tomcat用到的相关设计模式；</li></ul><h2 id="7-Tomcat顶层架构"><a href="#7-Tomcat顶层架构" class="headerlink" title="7. Tomcat顶层架构"></a>7. Tomcat顶层架构</h2><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后 逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但 是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而 解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！ 先上一张Tomcat的顶层结构图（图A），如下：</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E9%A1%B6%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="Tomcat顶层结构"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一 个Server可以包含至少一个Service，即可以包含多个Service，用于具体提供服 务。 </p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出  Tomcat 的心脏就是这两个组件，他们的作用如下： </p><ul><li>Connector用于处理连接相关的事情，并提供Socket与Request请求和 Response响应相关的转化; </li><li>Container用于封装和管理Servlet，以及具体处理Request请求；</li></ul><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个 Service只有一个Container，但是可以有多个Connectors，这是因为一个服务 可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端 口的连接，示意图如下（Engine、Host、Context下面会说到）：</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Service_Service_Connector.png" alt="Service_Service_Connector"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可 以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生 命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由  Server 控制。 </p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的 server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的 server.xml配置文件（Tomcat版本为8.0）</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/server.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="server.xml配置文件"></p><p>详细的配置文件内容可以到Tomcat官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">Tomcat配置文件 </a></p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9B%BE%E8%A7%A3.png" alt="Tomcat配置文件图解"></p><p>Server标签设置的端口号为8005，shutdown&#x3D;”SHUTDOWN” ，表示在 8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个 Server有一个Service，当然还可以进行配置，一个Service有多个Connector， Service左边的内容都属于Container的，Service下边是Connector。</p><p>**Tomcat顶层架构小结 **</p><ol><li>Tomcat中只有一个Server，一个Server可以有多个Service，一个 Service可以有多个Connector和一个Container； </li><li>Server掌管着整个Tomcat的生死大权；</li><li>Service 是对外提供服务的； </li><li>Connector用于接受请求并将请求封装成Request和Response来具体 处理； </li><li>Container用于封装和管理Servlet，以及具体处理request请求；</li></ol><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大 多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大 部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下 Connector和Container。 </p><h2 id="8-Connector和Container的微妙关系"><a href="#8-Connector和Container的微妙关系" class="headerlink" title="8. Connector和Container的微妙关系"></a>8. Connector和Container的微妙关系</h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然 后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为 Request和Response来具体处理，Request和Response封装完之后再交由 Container进行处理，Container处理完请求之后再返回给Connector，最后在 由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理 完了！ </p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照 HTTP协议来封装的，所以Connector同时需要实现TCP&#x2F;IP协议和HTTP协议！ </p><p>Tomcat既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东 西我们首先就需要看一下Connector！ </p><p>Connector架构分析 </p><p>Connector用于接受请求并将请求封装成Request和Response，然后交给 Container进行处理，Container处理完之后在交给Connector返回给客户端。 因此，我们可以把Connector分为四个方面进行理解： </p><ol><li>Connector如何接受请求的？ </li><li>如何将请求封装成Request和Response的？ </li><li>封装完之后的Request和Response如何交给Container进行处理的？</li><li>Container处理完之后如何交给Connector并返回给客户端的？ 首先看一下Connector的结构图，如下所示：</li></ol><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Connector%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Connector结构图"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler 代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的， Http11NioProtocol使用的是NioSocket来连接的。 </p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。 </p><ol><li>Endpoint用来处理底层Socket的网络连接，Processor用于将 Endpoint接收到的Socket封装成Request，Adapter用于将Request交给 Container进行具体的处理。 </li><li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实 现TCP&#x2F;IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适 配到Servlet容器进行具体的处理。 </li><li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和 AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请 求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收 到的Socket，在内部调用Processor进行处理。</li></ol><p>至此，我们应该很轻松的回答1，2，3的问题了，但是4还是不知道，那么我们 就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果 返回给Connector的？</p><h2 id="9-Container架构分析"><a href="#9-Container架构分析" class="headerlink" title="9. Container架构分析"></a>9. Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Container 内部包含了4个子容器，结构图如下：</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Container%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90.png" alt="Container架构分析"></p><p>4个子容器的作用分别是： </p><ol><li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个 Engine； </li><li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加 站点； </li><li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个 WEB-INF目录以及下面的web.xml文件； </li><li>Wrapper：每一Wrapper封装着一个Servlet； 下面找一个Tomcat的文件目录对照一下，如下图所示：</li></ol><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="Tomcat文件目录"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置 下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着 主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。 </p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问， 例如：<a href="http://www.baidu.com,如果是host(webapps)下的其他应用,则可以使/">www.baidu.com，如果是Host（webapps）下的其他应用，则可以使</a> 用<a href="http://www.baidu.com/docs%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%BD%93%E7%84%B6%E9%BB%98%E8%AE%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A0%B9%E5%BA%94%E7%94%A8%EF%BC%88ROOT%EF%BC%89%E6%98%AF%E5%8F%AF%E4%BB%A5">www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以</a> 进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。 </p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行请 求处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下 边就开始探讨一下Container是如何进行处理的！</p><h2 id="10-Container如何处理请求的"><a href="#10-Container如何处理请求的" class="headerlink" title="10. Container如何处理请求的"></a>10. Container如何处理请求的</h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之 意） </p><p>Pipeline-Valve是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多 处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将 处理后的结果返回，再让下一个处理者继续处理。</p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主 要有以下两点： </p><p>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个 Valve叫做BaseValve，BaseValve是不可删除的； </p><p>在上层容器的管道的BaseValve中会调用下层容器的管道。 </p><p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别 </p><p>在：StandardEngineValve、StandardHostValve、StandardContextValve、 StandardWrapperValve。 </p><p>Pipeline的处理流程图如下：</p><p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Container%E5%9B%9B%E4%B8%AA%E5%AD%90%E5%AE%B9%E5%99%A8%E7%9A%84BaseValve.png" alt="Container四个子容器的BaseValve"></p><ul><li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处 理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管 道）； </li><li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等， 最后会执行StandardEngineValve，在StandardEngineValve中会调用 Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在 执行StandardHostValve，然后再依次调用Context的管道和Wrapper的 管道，最后执行到StandardWrapperValve。 </li><li>当执行到StandardWrapperValve的时候，会在 StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处 理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和 Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet 的service方法，这样请求就得到了处理！ </li><li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求， 这个时候就可以将返回的结果交给Connector了，Connector在通过 Socket的方式将结果返回给客户端。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h1><h2 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h2><h3 id="数据保存在内存"><a href="#数据保存在内存" class="headerlink" title="数据保存在内存"></a>数据保存在内存</h3><p>优点：存取速度快</p><p>缺点：数据不能永久保存</p><h3 id="数据保存在文件"><a href="#数据保存在文件" class="headerlink" title="数据保存在文件"></a>数据保存在文件</h3><p>优点：数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。</p><p>​2）查询数据不方便</p><h3 id="数据保存在数据库"><a href="#数据保存在数据库" class="headerlink" title="数据保存在数据库"></a>数据保存在数据库</h3><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p><h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>结构化查询语言(StructuredQueryLanguage)简称SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h2 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQLAB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS(RelationalDatabaseManagementSystem，关系数据库管理系统)应用软件之一。在Java企业级开发中非常常用，因为MySQL是开源免费的，并且方便扩展。</p><h2 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p><p>db权限表：记录各个帐号在各个数据库上的操作权限。</p><p>table_priv权限表：记录数据表级的操作权限。</p><p>columns_priv权限表：记录数据列级的操作权限。</p><p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p><h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p><ul><li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如altertable)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h2><table><thead><tr><th>分类</th><th>类型名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td>smallint</td><td>小的整数(16位二进制)</td><td></td></tr><tr><td>mediumint</td><td>中等大小的整数(24位二进制)</td><td></td></tr><tr><td>int(integer)</td><td>普通大小的整数(32位二进制)</td><td></td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td>double</td><td>双精度浮点数</td><td></td></tr><tr><td>decimal(m,d)</td><td>压缩严格的定点数</td><td></td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY1901~2155</td></tr><tr><td>time</td><td>HH:MM:SS-838:59:59~838:59:59</td><td></td></tr><tr><td>date</td><td>YYYYMM-DD1000-01-01~9999-12-3</td><td></td></tr><tr><td>datetime</td><td>YYYYMM-DDHH:MM:SS1000-01-0100:00:00~9999-12-3123:59:59</td><td></td></tr><tr><td>timestamp</td><td>YYYYMM-DDHH:MM:SS1970010100:00:01UTC~2038-01-1903:14:07UTC</td><td></td></tr><tr><td><strong>文本、二进制类型</strong></td><td><strong>CHAR(M)</strong></td><td>M为0~65535之间的整数</td></tr><tr><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td><td></td></tr><tr><td>TINYBLOB</td><td>允许长度0~255字节</td><td></td></tr><tr><td>BLOB</td><td>允许长度0~65535字节</td><td></td></tr><tr><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td><td></td></tr><tr><td>LONGBLOB</td><td>允许长度0~4294967295字节</td><td></td></tr><tr><td>TINYTEXT</td><td>允许长度0~255字节</td><td></td></tr><tr><td>TEXT</td><td>允许长度0~65535字节</td><td></td></tr><tr><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td><td></td></tr><tr><td>LONGTEXT</td><td>允许长度0~4294967295字节</td><td></td></tr><tr><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td><td></td></tr><tr><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td><td></td></tr></tbody></table><p><strong>整数类型</strong>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p><p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNEDZEROFILL属性配合使用才有意义。</p><p>例子，假定类型设定为INT(5)，属性为UNSIGNEDZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p><p><strong>实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p><strong>字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p><strong>使用策略：</strong></p><p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</p><p>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</p><p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p><p><strong>枚举类型（ENUM）</strong>，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p><p><strong>日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。</p><p>看到这里，这道真题是不是就比较容易回答了。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><h2 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h2><p>存储引擎Storageengine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>常用的存储引擎有以下：</p><p><strong>Innodb引擎：</strong>Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p><p><strong>MyIASM引擎(原本Mysql的默认引擎)：</strong>不提供事务的支持，也不支持行级锁和外键。</p><p><strong>MEMORY引擎：</strong>所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p><p><strong>MyISAM与InnoDB区别</strong></p><table><thead><tr><th>MyISAM</th><th>Innodb</th><th></th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份binlog，或者用mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据.MYD，索引.MYI</td><td>数据和索引是集中存储的，.ibd</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td></td></tr><tr><td>INSERT、UPDATE、DELETE</td><td>InnoDB更优</td><td></td></tr><tr><td>selectcount(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam是堆表</td><td>B+树索引，Innodb是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a><strong>MyISAM索引与InnoDB索引的区别？</strong></h2><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h2 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a><strong>InnoDB引擎的4大特性</strong></h2><ul><li>插入缓冲（insertbuffer)</li><li>二次写(doublewrite)</li><li>自适应哈希索引(ahi)</li><li>预读(readahead)</li></ul><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>如果没有特别的需求，使用默认的Innodb即可。<br>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。<br>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，<br>支持事务和外键。比如OA自动化办公系统。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它<br>们包含着对数据表里所有记录的引用指针。<br>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，<br>以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种<br>B+树。<br>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索<br>引形成目录。索引是一个文件，它是要占据物理空间的。</p><h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201111145020510.png" alt="image-20201111145020510"></p><p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选<br>的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1‐‐增加一个没有建立索引的字段</span><br><span class="line">2altertableinnodb1addsexchar(1);</span><br><span class="line">3‐‐按sex检索时可选的索引为null</span><br><span class="line">4EXPLAINSELECT*frominnodb1wheresex=&#x27;男&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.jpg" alt="09-MySQL数据库面试题（2020最新版）-重点"></p><blockquote><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引<br>（altertable表名addindex(字段名)），同样的SQL执行的效率，你会发现查询效率<br>会有明显的提升（数据量越大越明显）。</p></blockquote><p>orderby<br>当我们使用orderby将查询结果按照某个字段排序时，如果该字段没有建立索<br>引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取<br>到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需<br>要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过<br>多都会降低效率），更无论读到内存之后的排序了。<br>但是如果我们对该字段建立索引altertable表名addindex(字段名)，那么由于索引<br>本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如<br>果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那</p><p>取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能<br>的）<br>join<br>对join语句匹配关系（on）涉及的字段建立索引能够提高效率<br>索引覆盖<br>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原<br>始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。<br>因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几<br>率。<br>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在<br>于其体积小。</p><h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><p>**主键索引:**数据列不允许重复，不允许为NULL，<br>一个表只能有一个主键。</p><p>**唯一索引:**数据列不允许重复，允许为NULL值，<br>一个表允许多个列创建唯一索引。</p><ul><li>可以通过ALTERTABLEtable_nameADDUNIQUE(column);<br>创建唯一索引</li><li>可以通过ALTERTABLEtable_nameADDUNIQUE(column1,column2);<br>创建唯一组合索引</li></ul><p>**普通索引:**基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li><p>可以通过ALTERTABLEtable_nameADDINDEXindex_name(column);<br>创建普通索引</p></li><li><p>可以通过ALTERTABLEtable_nameADDINDEXindex_name(column1,column2,column3);<br>创建组合索引</p></li><li><p><strong>全文索引：</strong>是目前搜索引擎使用的一种关键技术。<br>可以通过ALTERTABLEtable_nameADDFULLTEXT(column);<br>创建全文索引</p></li></ul><h2 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有</p><p>Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；其余大部分场景，建议选择BTree索引。</p><p>1）B树索引mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持</p><p>BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B%E6%A0%91.jpg" alt="B树"></p><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度快</p><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字。</p><p>4.）B+树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是小关键码的叶节点。2）哈希索引简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在</p><p>mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生</p><p>Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.jpg" alt="哈希索引"></p><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li><p>把创建了索引的列的内容进行排序</p></li><li><p>对排序结果生成倒排表</p></li><li><p>在倒排表内容上拼上数据地址链</p></li><li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></li></ol><h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><p>索引算法有BTree算法和Hash算法</p><p>BTree算法</p><p>BTree是常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1‐‐只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">2select*fromuserwherenamelike&#x27;jack%&#x27;;</span><br><span class="line">3‐‐如果一通配符开头，或者没有使用常量，则不会使用索引，例如：</span><br><span class="line">4select*fromuserwherenamelike&#x27;%jack&#x27;;</span><br></pre></td></tr></table></figure><p>Hash算法</p><p>HashHash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><p>\1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列</p><p>\2.基数较小的类，索引效果较差，没有必要在此列建立索引</p><p>\3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p><p>\4.不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p><h3 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，好符合一下几个原则</p><p>1）左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a&#x3D;1andb&#x3D;2andc&gt;3andd&#x3D;4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立</p><p>(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。8）对于定义为text、image和bit的数据类型的列不要建立索引。创建索引的三种方式，删除索引</p><p>第一种方式：在执行CREATETABLE时创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1CREATETABLEuser_index2(</span><br><span class="line">2idINTauto_incrementPRIMARYKEY,</span><br><span class="line">3first_nameVARCHAR(16),</span><br><span class="line">4last_nameVARCHAR(16),</span><br><span class="line">5id_cardVARCHAR(18),</span><br><span class="line">6informationtext,</span><br><span class="line">7KEYname(first_name,last_name),</span><br><span class="line">8FULLTEXTKEY(information),</span><br><span class="line">9UNIQUEKEY(id_card));</span><br></pre></td></tr></table></figure><p>第二种方式：使用ALTERTABLE命令去增加索引</p><p><code>1ALTERTABLEtable_nameADDINDEXindex_name(column_list);</code></p><p>ALTERTABLE用来创建普通索引、UNIQUE索引或PRIMARYKEY索引。</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTERTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>第三种方式：使用CREATEINDEX命令创建</p><p><code>1CREATEINDEXindex_nameONtable_name(column_list);</code></p><p>CREATEINDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARYKEY索引）</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：altertable表名dropKEY索引名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1altertableuser_indexdropKEYname;</span><br><span class="line">2altertableuser_indexdropKEYid_card;</span><br><span class="line">3altertableuser_indexdropKEYinformation;</span><br></pre></td></tr></table></figure><p>删除主键索引：altertable表名dropprimarykey（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%88%A0%E9%99%A4%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg" alt="删除主键索引"></p><p>需要取消自增长再行删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1altertableuser_index</span><br><span class="line">2‐‐重新定义字段</span><br><span class="line">3MODIFYidint,</span><br><span class="line">4dropPRIMARYKEY</span><br></pre></td></tr></table></figure><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul><li>非空字段：应该指定列为NOTNULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><p>索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5次的磁盘I&#x2F;O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEXRANGESCAN)适用于两种情况:</p><p>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</p><p>基于非唯一性索引的检索</p><h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li><p>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</p></li><li><p>然后删除其中无用数据（此过程需要不到两分钟）</p></li><li><p>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分</p></li></ol><p>钟左右。</p><ol start="4"><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相</p><p>同。</p><p>实操的难度：在于前缀截取的长度。</p><p>我们可以利用selectcount(*)&#x2F;count(distinctleft(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p><h2 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h2><p>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中</p><p>使用最频繁的一列放在最左边。</p><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a&#x3D;1andb&#x3D;2andc&gt;3andd&#x3D;4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>&#x3D;和in可以乱序，比如a&#x3D;1andb&#x3D;2andc&#x3D;3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树</p><p>中，内部节点都是键，没有值，叶子节点同时存放键和值。</p><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="B树和B+树的区别"></p><h2 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h2><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h2 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h2><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应</p><p>的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。</p><p>对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然</p><p>后根据查询判断是否需要回表查询数据。</p><p>么可以看出他们有以下的不同：</p><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p><p>hash索引不支持使用索引进行排序，原理同上。</p><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函</p><p>数的不可预测。AAAA和AAAAB的索引没有相关性。</p><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索</p><p>引，覆盖索引等)的时候可以只通过索引完成查询。</p><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。</p><p>而不需要使用hash索引。</p><h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p><p>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般来说，索引本</p><p>身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结</p><p>点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读</p><p>写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p><p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p><p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p><p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以</p><p>有序的链表结构存储，这样可很好提高增删效率。</p><h2 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据</h2><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再</p><p>次进行回表查询。</p><h2 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h2><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>何时使用聚簇索引与非聚簇索引</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg" alt="何时使用聚簇索引"></p><h2 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h2><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了</p><p>索引，那么就不必再进行回表查询</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h2 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h2><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h2><p>关系性数据库需要遵循ACID规则，具体内容如下：</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/ACID%E8%A7%84%E5%88%99.jpg" alt="ACID规则"></p><p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作</p><p>要么全部完成，要么完全不起作用；</p><ol start="2"><li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的</li></ol><p>结果是相同的；</p><ol start="3"><li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各</li></ol><p>并发事务之间数据库是独立的；</p><ol start="4"><li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h2><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这</p><p>可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><h2 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复  读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ- UNCOM MITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-  COMMIT  TED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATA BLE- READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZ  ABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h2><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来</p><p>保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><h2 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h2><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修</p><p>改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不</p><p>释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p><h2 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h2><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p>行级锁，表级锁和页级锁对比</p><p>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，</p><p>并发度也最高。</p><p>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，</p><p>并发度最低。</p><p>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和</p><p>行锁之间，并发度一般</p><h2 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h2><h2 id="像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="像上面那样子进行锁定岂不是有点阻碍并发效率了"></a>像上面那样子进行锁定岂不是有点阻碍并发效率了</h2><p>从锁的类别上来讲，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h2 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h2><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id &#x3D; 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h2 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h2><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p>相关知识点：</p><ol><li><p>innodb对于行的查询使用next-key lock </p></li><li><p>Next-locking keying为了解决Phantom Problem幻读问题</p></li><li><p>当查询的索引含有唯一属性时，将next-key lock降级为record key</p></li><li><p>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</p></li><li><p>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</p></li></ol><h2 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h2 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><p>两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行</p><p>retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h2><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p><p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性</p><h2 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h2><p>视图的特点如下:</p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。视图的操作包括创建视图，查看视图，删除视图和修改视图。</li></ul><h2 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h2><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p><p>下面是视图的常见使用场景：重用SQL语句；</p><ul><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；使用表的组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据</li></ul><h2 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h2><ol><li><p>查询简单化。视图能简化用户的操作</p></li><li><p>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</p></li></ol><p>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</p><h2 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h2><ol><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的这些视图有如下特征：</p><ol><li>有UNIQUE等集合操作符的视图。<br>2.有GROUP BY子句的视图。<br>3.有诸如AVG\SUM\MAX等聚合函数的视图。<br>4.使用DISTINCT关键字的视图。<br>5.连接表的视图（其中有些例外）</li></ol></li></ol><h2 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h2><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理</p><h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p>优点</p><p>1）     存储过程是预编译过的，执行效率高。</p><p>2）     存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）     安全性高，执行存储过程需要有一定权限的用户。</p><p>4）     存储过程可以重复使用，减少数据库开发人员的工作量。</p><p>缺点</p><p>1）     调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。</p><p>2）     移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）     重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）     如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，   后如果用</p><p>户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h2 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h2><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete </li><li>After Delete</li></ul><h1 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h1><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER 主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，</p><p>DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，</p><p>COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等</p><h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><p> 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p>​             候选键：是  小超键，即没有冗余元素的超键。</p><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。</p><p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p>​            外键：在一个表中存在的另一个表的主键称此表的外键。</p><h2 id="SQL约束有哪几种？"><a href="#SQL约束有哪几种？" class="headerlink" title="SQL约束有哪几种？"></a>SQL约束有哪几种？</h2><p>SQL 约束有哪几种？</p><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p><p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p><p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p><p> FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p><p>​            CHECK: 用于控制字段的值范围。</p><h2 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h2><p>交叉连接（CROSS JOIN）</p><p>内连接（INNER JOIN）</p><p>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</p><p>联合查询（UNION与UNION ALL）</p><p>全连接（FULL JOIN）</p><p>交叉连接（CROSS JOIN）</p><p>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER </p><p>JOIN）SELECT * FROM A,B WHERE A.id&#x3D;B.id或者SELECT * FROM A INNER JOIN B </p><p>ON A.id&#x3D;B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p><p>​            </p><p>内连接分为三类</p><p>等值连接：ON A.id&#x3D;B.id 不等值连接：ON A.id &gt; B.id</p><p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id&#x3D;T2.pid</p><p>外连接（LEFT JOIN&#x2F;RIGHT JOIN） </p><p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联</p><p>条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN </p><p>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关</p><p>联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p><p>联合查询（UNION与UNION ALL）</p><p>SELECT * FROM A UNION SELECT * FROM B UNION …</p><p>1</p><p>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查</p><p>询的列数要相等，相同的记录行会合并如果使用UNION ALL，不会合并重复的记录行效率 UNION 高于 UNION ALL</p><p>全连接（FULL JOIN）</p><p>MySQL不支持全连接</p><p>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</p><p>SELECT * FROM A LEFT JOIN B ON A.id&#x3D;B.id UNION SELECT * FROM A RIGHT JOIN B ON A.id&#x3D;B.id</p><p>​            1</p><p>表连接面试题有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p><p>R表</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td></tr></tbody></table><p>S表</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td></tr></tbody></table><ol><li>交叉连接(笛卡尔积):</li></ol><p>select r.<em>,s.</em> from r,s</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c1</td><td>d1</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c2</td><td>d2</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c2</td><td>d2</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c4</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c4</td><td>d3</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c4</td><td>d3</td></tr></tbody></table><ol><li>内连接结果：</li></ol><p>select r.<em>,s.</em> from r inner join s on r.c&#x3D;s.c</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr></tbody></table><ol><li>左连接结果：</li></ol><p>select r.<em>,s.</em> from r left join s on r.c&#x3D;s.c</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr></tbody></table><ol><li>右连接结果：</li></ol><p>select r.<em>,s.</em> from r right join s on r.c&#x3D;s.c</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td><td></td><td></td><td></td></tr></tbody></table><ol><li>全表连接的结果（MySql不支持，Oracle支持）：</li></ol><p>select r.<em>,s.</em> from r full join s on r.c&#x3D;s.c</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr><tr><td>c4</td><td>d3</td><td></td><td></td><td></td></tr></tbody></table><h2 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h2><ol><li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果 </li><li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li></ol><h2 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a>子查询的三种情况</h2><ol><li>子查询是单行单列的情况：结果集是一个值，父查询使用：&#x3D;、 &lt;、 &gt; 等运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1‐‐ 查询工资最高的员工是谁？</span><br><span class="line">2select * from employee where salary=(select max(salary) from employee);</span><br></pre></td></tr></table></figure><ol start="2"><li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1‐‐ 查询工资最高的员工是谁？</span><br><span class="line">2select * from employee where salary=(select max(salary) from employee);</span><br></pre></td></tr></table></figure><ol start="3"><li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where 条件，用于select子句中做为子表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1‐‐ 1) 查询出2011年以后入职的员工信息</span><br><span class="line">2‐‐ 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span><br><span class="line">3select * from dept d, (select * from employee where join_date &gt;&#x27;2011‐1‐</span><br><span class="line">1&#x27;) e where e.dept_id = d.id;</span><br><span class="line">4‐‐ 使用表连接：</span><br><span class="line">5select d.*, e.* from dept d inner join employee e on d.id = e.dept_id whe re e.join_date &gt;&#x27;2011‐1‐1&#x27;</span><br></pre></td></tr></table></figure><h2 id="mysql中in和exists区别"><a href="#mysql中in和exists区别" class="headerlink" title="mysql中in和exists区别"></a>mysql中in和exists区别</h2><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop</p><p>循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><ol><li><p>如果查询的两个表大小相当，那么用in和exists差别不大。</p></li><li><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p></li><li><p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p></li></ol><h2 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h2><p>char的特点</p><p>char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；</p><p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法； </p><p>   对于char来说，   多能存放的字符个数为255，和编码无关 varchar的特点</p><p>varchar表示可变长字符串，长度是可变的；</p><p>插入的数据是多长，就按照多长来存储；</p><p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p><p> 对于varchar来说， 多能存放的字符个数为65532 总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><h2 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h2><p>多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排</p><p>序时会消耗更多内存，因为order by col采用fixed_length计算col长度</p><p>(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p><h2 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h2><p>是指显示字符的长度。20表示 大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p><h2 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h2><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和 int(20)存储和计算均一样；</p><h2 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h2><ul><li>int(10)的10表示显示的数据的长度，不是存储数据的大小； chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li></ul><p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位 char(10) 10位固定字符串，不足补空格   多10个字符</p><p>varchar(10) 10位可变字符串，不足补空格  多10个字符</p><ul><li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li><li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li></ul><h2 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h2><p>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</p><p>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</p><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><h3 id="三者都表示删除，但是三者有一些差别："><a href="#三者都表示删除，但是三者有一些差别：" class="headerlink" title="三者都表示删除，但是三者有一些差别："></a>三者都表示删除，但是三者有一些差别：</h3><table><thead><tr><th>Delete</th><th>Truncate</th><th>Drop</th><th></th></tr></thead><tbody><tr><td>类型</td><td>属于DML</td><td>属于DDL</td><td>属于DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用truncate。</p><h2 id="UNION与UNIONALL的区别？"><a href="#UNION与UNIONALL的区别？" class="headerlink" title="UNION与UNIONALL的区别？"></a>UNION与UNIONALL的区别？</h2><p>如果使用UNION ALL，不会合并重复的记录行 </p><p>效率 UNION 高于 UNION ALL</p><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="如何定位及优化SQL语句的性能问题？"><a href="#如何定位及优化SQL语句的性能问题？" class="headerlink" title="如何定位及优化SQL语句的性能问题？"></a>如何定位及优化SQL语句的性能问题？</h2><h2 id="创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h2><p>对于低性能的SQL语句的定位， 重要也是 有效的方法就是使用执行计划， MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.jpg" alt="执行计划"></p><p>执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>id相同执行顺序由上至下。</li><li>id不同，id值越大优先级越高，越先被执行。</li><li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul><p>select_type 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th>id</th><th>select_ty pe</th><th>descripti on</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>不包含任何子查询  或union等查询</td></tr><tr><td>2</td><td>PRIMARY</td><td>包含子查询  外层查询就显示为   PRIMARY</td></tr><tr><td>3</td><td>SUBQUER Y</td><td>在select或  where字句中包含的查询</td></tr><tr><td>4</td><td>DERIVED</td><td>from字句中包含的查询</td></tr><tr><td>5</td><td>UNION</td><td>出现在  union后的查询语句中</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION 中获取结果集，例如上文的</td></tr><tr><td></td><td></td><td>第三个例子</td></tr></tbody></table><p>table 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id </p><p>partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1create table tmp (</span><br><span class="line">2id int unsigned not null AUTO_INCREMENT,</span><br><span class="line">3name varchar(255),</span><br><span class="line">4PRIMARY KEY(id))</span><br><span class="line">5engine=innodb partition by key(id) partitions 5;</span><br></pre></td></tr></table></figure><p>type(非常重要，可以看到有没有走索引) 访问类型</p><p>ALL 扫描全表数据 index 遍历索引 range 索引范围查找 index_subquery 在子查询中使用 ref unique_subquery 在子查询中使用 eq_ref ref_or_null 对Null进行索引的优化的 ref fulltext 使用全文索引</p><p>ref 使用非唯一索引查找数据 eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</p><p>possible_keys 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p><p>key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。 TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p><p>key_length 索引长度</p><p>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows 返回估算的结果集数目，并不是一个准确的值。</p><p>extra 的信息非常丰富，常见的有：</p><ol><li><p>Using index 使用覆盖索引</p></li><li><p>Using where 使用了用where子句来过滤结果集</p></li><li><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p></li><li><p>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</p></li></ol><p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是</p><p>consts 好。 说明： 1） consts 单表中  多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p><h2 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h2><ol><li><p>应用服务器与数据库服务器建立一个连接</p></li><li><p>数据库进程拿到请求sql</p></li><li><p>解析并生成执行计划，执行</p></li><li><p>读取数据到内存并进行逻辑处理</p></li><li><p>通过步骤一的连接，发送结果到客户端</p></li><li><p>关掉连接，释放资源</p></li></ol><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/sql%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="sql的生命周期"></p><h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><ol><li><p>优化shema、sql语句+索引；</p></li><li><p>第二加缓存，memcached, redis；</p></li><li><p>主从复制，读写分离；</p></li><li><p>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p></li><li><p>水平切分，针对数据量大的表，这一步 麻烦， 能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，</p></li></ol><p>做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p><h2 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h2><p>超大的分页一般从两个方向上来解决.</p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种, 但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset</p><p>行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联：</p><p><code> SELECT a.* FROM 表1 a,(select id from 表1 where 条件 LIMIT 100000,20) b w here a.id=b.id</code></p><h2 id="mysql分页"><a href="#mysql分页" class="headerlink" title="mysql分页"></a>mysql分页</h2><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的  大数目。初始记录行的偏移量是 0(而不是 1)</p><p>mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 </p><p>​            1</p><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 </p><p>-1：</p><p>mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last. </p><p>​            1</p><p>如果只给定一个参数，它表示返回 大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行 </p><p>​            1</p><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p><p>开启慢查询日志</p><p>配置项：slow_query_log 可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为</p><p>OFF，可以使用set GLOBAL slow_query_log &#x3D; on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p><p>设置临界时间</p><p>配置项：long_query_time 查看：show VARIABLES like ‘long_query_time’，单位秒设置：set long_query_time&#x3D;0.5</p><p>实操时应该从长时间设置到短的时间，即将 慢的SQL优化掉</p><p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p><h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><h3 id="慢查询都怎么优化过？"><a href="#慢查询都怎么优化过？" class="headerlink" title="慢查询都怎么优化过？"></a>慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是 load了不需要的数据列？还是数据量太大？所以优化也是针对这三个方向来的，</p><p> 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p><p> 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p><p>​          如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p><h2 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h2><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p><p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><h2 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h2><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><h2 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h2><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar 来存储，这样可以节省空间且提高检索效率。</p><h2 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h2><p>访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据，可能是太多行或列确认MySQL服务器是否在分析大量不必要的数据行避免犯如下SQL语句错误</p><p>查询不需要的数据。解决办法：使用limit解决</p><p>多表关联返回全部列。解决办法：指定列名</p><p>总是返回全部列。解决办法：避免使用SELECT * 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存是否在扫描额外的记录。解决办法：</p><p>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</p><p> 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</p><p>改变数据库和表的结构，修改数据表范式</p><p>重写SQL语句，让优化器可以以更优的方式执行查询。</p><h2 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h2><p>一个复杂查询还是多个简单查询</p><p>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</p><p>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</p><p>切分查询将一个大的查询分为多个小的相同的查询</p><p>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</p><p>分解关联查询，让缓存的效率更高。</p><p>执行单个查询可以减少锁的竞争。</p><p>在应用层做关联更容易对数据库进行拆分。</p><p>查询效率会有大幅提升。</p><p>较少冗余记录的查询</p><h2 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h2><p> count(<em>)会忽略所有的列，直接统计所有列数，不要使用count(列名) MyISAM中，没有任何where条件的count(</em>)非常快。</p><p>当有where条件时，MyISAM的count统计不一定比其它引擎快。</p><p>可以使用explain查询近似值，用近似值替代count(*) 增加汇总表使用缓存</p><h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><p>确定ON或者USING子句中是否有索引。</p><p>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引</p><h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>用关联查询替代</p><p>优化GROUP BY和DISTINCT</p><p>这两种查询据可以使用索引来优化，是  有效的优化方法关联查询中，使用标识列分组的效率更高</p><p>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</p><p> WITH ROLLUP超级聚合，可以挪到应用程序处理</p><h2 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h2><p>LIMIT偏移量大的时候，查询效率较低</p><p>可以记录上次查询的   大ID，下次查询时直接根据该ID来查询</p><h2 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h2><p>UNION ALL的效率高于UNION</p><h2 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h2><p>解题方法对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p><p>SQL语句优化的一些方法？</p><p> 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p> 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><p><code>1 select id from t where num is null ‐‐ 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</code></p><p> 3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><p> 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><p><code>1 select id from t where num=10 or num=20 ‐‐ 可以这样查询：select id from t where num=10 union all select id from t where num=20</code></p><p>​            5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p><p><code>1 select id from t where num in(1,2,3) ‐‐ 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</code></p><p> 6.下面的查询也将导致全表扫描：select id from t where name like ‘% 李%’若要提高效率，可以考虑全文检索。</p><p> 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><p><code>1 select id from t where num=@num ‐‐可以改为强制查询使用索引：select id from t with (index(索引名)) where num=@num</code></p><p> 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><p><code>1 select id from t where num/2=100 ‐‐ 应改为:select id from t where num=100*2</code></p><p> 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><p><code>1 select id from t where substring(name,1,3)=’abc’ ‐‐ name以abc开头的id应改为: select id from t where name like ‘abc%’</code></p><p> 10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><p>系统的吞吐量瓶颈往往出现在数据库的访问速度上随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢数据是存放在磁盘上的，读写速度无法和内存相比优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p>将字段很多的表分解成多个表对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p>增加中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p>增加冗余字段设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p>注意：</p><p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题</p><h2 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h2><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整,比如说限制连接数等</p><h2 id="大表怎么优化？某个表有近千万数据，"><a href="#大表怎么优化？某个表有近千万数据，" class="headerlink" title="大表怎么优化？某个表有近千万数据，"></a>大表怎么优化？某个表有近千万数据，</h2><h2 id="CRUD比较慢，如何优化？分库分表了是怎么"><a href="#CRUD比较慢，如何优化？分库分表了是怎么" class="headerlink" title="CRUD比较慢，如何优化？分库分表了是怎么"></a>CRUD比较慢，如何优化？分库分表了是怎么</h2><h2 id="做的？分表分库了有什么问题？有用到中间"><a href="#做的？分表分库了有什么问题？有用到中间" class="headerlink" title="做的？分表分库了有什么问题？有用到中间"></a>做的？分表分库了有什么问题？有用到中间</h2><h2 id="件么？他们的原理知道么？"><a href="#件么？他们的原理知道么？" class="headerlink" title="件么？他们的原理知道么？"></a>件么？他们的原理知道么？</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</p></li><li><p>读&#x2F;写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p></li></ol><p>有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p><ol><li>垂直分区：</li></ol><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86.jpg" alt="垂直拆分"></p><p>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少</p><p>I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可</p><p>以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.jpg" alt="垂直分表"></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>1、    如果一个表中某些列常用，另外一些列不常用</p><p>2、    可以使数据行变小，一个数据页能存储更多数据，查询时减少I&#x2F;O次数</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p> 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差 对于应用层来说，逻辑算法增加开发成本管理冗余列，查询所有数据需要join操作</p><ol start="2"><li>水平分区：</li></ol><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA.jpg" alt="水平分区"></p><p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升</p><p>MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p><p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。</p><p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p><h3 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a>水平分表：</h3><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.jpg" alt="水平分表"></p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p> 1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p><p>​                    2、需要把数据存放在多个介质上。</p><p>水平切分的缺点</p><p> 1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p><p> 2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p><p>下面补充一下数据库分片的两种常见方案：</p><p> 客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-</p><p>JDBC 、阿里的TDDL是两种比较常用的实现。</p><p> 中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat </p><p>、360的Atlas、网易的DDB等等都是这种架构的实现。</p><p>分库分表后面临的问题</p><p> 事务支持 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><p>​           跨库join</p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p><p> 跨节点的count,order by,group by以及聚合函数问题 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p><p> 数据迁移，容量规划，扩容等问题 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是</p><p>十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了</p><p>Sharding扩容的难度。</p><p>ID问题</p><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行</p><p>SQL路由. 一些常见的主键生成策略</p><p>UUID 使用UUID作主键是   简单的方案，但是缺点也是非常明显的。由于</p><p>UUID非常的长，除占用大量存储空间外， 主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法</p><p>Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter 的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><p> 跨分片的排序分页般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了  终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，  后再返回给用户。如下图所示：</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%88%86%E7%89%87.jpg" alt="分片"></p><h2 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p>主从复制的作用</p><ol><li><p>主数据库出现问题，可以切换到从数据库。</p></li><li><p>可以进行数据库层面的读写分离。</p></li><li><p>可以在从数据库上进行日常备份。</p></li></ol><p>MySQL主从复制解决的问题</p><ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份负载均衡：降低单个服务器的压力高可用和故障切换：帮助应用程序避免单点失败升级测试：可以用更高版本的MySQL作为从库</li><li>MySQL主从复制工作原理</li><li>在主库上把数据更高记录到二进制日志从库将主库的日志复制到自己的中继日志</li><li>从库读取中继日志的事件，将其重放到从库数据中基本原理流程，3个线程以及之间的关联</li></ul><p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的 binlog中；从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p>从：sql执行线程——执行relay log中的语句；</p><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.jpg" alt="复制过程"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog文件中。</p><p>第二步：salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程 终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h2 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h2><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running&#x3D;NO，此时你需要按照前面提到的手动同步一下slave）。</p><p>方案一</p><p>使用mysql-proxy代理</p><p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用缺点：降低性能， 不支持事务方案二</p><p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过</p><p>mybatis plugin拦截sql语句，所有的insert&#x2F;update&#x2F;delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下</p><p>DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p><p>方案三</p><p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务. 缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理</p><h2 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h2><p>(1)备份计划视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p><p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 </p><p>mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p><p>(2)备份恢复时间</p><p>物理备份恢复快，逻辑备份恢复慢</p><p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><p>20G的2分钟（mysqldump）</p><p>80G的30分钟(mysqldump)</p><p>111G的30分钟（mysqldump)</p><p>288G的3小时（xtra)</p><p>3T的4小时（xtra)</p><p>逻辑导入时间一般是备份时间的5倍以上</p><p>(3)备份恢复失败如何处理首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p><p>(4)mysqldump和xtrabackup实现原理 mysqldump mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION </p><p>TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个</p><p>事务(START TRANSACTION &#x2F;*!40100 WITH CONSISTENTSNAPSHOT *&#x2F;)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data&#x3D;1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。  后完成 innodb 的备份后，会做一个 flush engine logs 的</p><p>操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢 后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p><p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p><h2 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h2><p>使用 myisamchk 来修复，具体步骤：</p><p>1）   修复前将mysql服务停止。</p><p>2）   打开命令行方式，然后进入到mysql的&#x2F;bin目录。</p><p>3）   执行myisamchk –recover 数据库所在路径&#x2F;*.MYI使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE </p><p>table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE </p><p>TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/08-Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/08-Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h2><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/JVM的主要组成部分.png" alt="JVM 的主要组成部分"></p><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、 Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据 区)、Native Interface(本地接口)。 </p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。 </li><li>Execution engine（执行引擎）：执行classes中的指令。 </li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。 </li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内 存。</li></ul><p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader） 再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方 法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作 系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将 字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他 语言的本地库接口（Native Interface）来实现整个程序的功能。 </p><p>**下面是Java程序运行机制详细说明 **</p><p>Java程序运行机制步骤 </p><p>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java； </p><p>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名 为.class； </p><p>运行字节码的工作是由解释器(java命令)来完成的。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/Java程序运行机制.png" alt="Java程序运行机制"></p><p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这 些.class文件加载到JVM中。 </p><p>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入 到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个  java.lang.Class对象，用来封装类在方法区内的数据结构。 </p><h2 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h2><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个 不同的数据区域。</strong>这些区域都有各自的用途，以及创建和销毁的时间，有些区域 随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销 毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/Java虚拟机内存区域.png" alt="Java虚拟机内存区域"></p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范，  Java 虚拟机规范规定的区域分为以下 5 个部分： </p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号 指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的 字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个 计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息； </li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚 拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的； </li><li>Java 堆（Java Heap）：Java 虚拟机中内存大的一块，是被所有线程共享 的，几乎所有的对象实例都在这里分配内存； </li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。</li></ul><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址， </p><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内存， </p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的 错误。 </p><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来 的对象也会相应的改变。 </p><p>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。 </p><h2 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h2><p>物理地址 </p><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩） 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性 能快。 </p><p>**内存分别 **</p><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般 堆大小远远大于栈。 </p><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。 </p><p>**存放的内容 **</p><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储 </p><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。<br>PS：</p><ol><li>静态变量放在方法区 </li><li>静态的对象还是放在堆。</li></ol><p>程序的可见度 </p><p>堆对于整个应用程序都是共享、可见的。 </p><p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p><h2 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。 </p><ul><li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进 栈，栈的删除称为出栈。 </li><li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进 栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。 </li><li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原 则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列 头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当 前栈中新的元素，即后插入（进栈）的元素，而先插入的被放在栈的底部，要到后才能删除。</li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p> 说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p><table><thead><tr><th>Header</th><th>解释</th></tr></thead><tbody><tr><td>使用new关键字</td><td>调用了构造函数</td></tr><tr><td>使用Class的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用Constructor类的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用clone方法</td><td>没有调用构造函数</td></tr><tr><td>使用反序列化</td><td>没有调用构造函数</td></tr></tbody></table><p>下面是对象创建的主要流程:</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/对象创建的主要流程.png" alt="对象创建的主要流程"></p><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有， 必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是 绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表 中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有 两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation  Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信 息、哈希码…)，后执行方法。 </p><h2 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java 堆是否规整，有两种方式： </p><ul><li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的 放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小 相等的距离，这样便完成分配内存工作。 </li><li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录 那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对 象，并在分配后更新列表记录。</li></ul><p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所 采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/内存分配的两种方式.png" alt="内存分配的两种方式"></p><h2 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h2><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的 位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还 没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个 问题有两种方案： </p><p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的 原子性）； </p><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆 中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,  TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并 分配新的 TLAB 时，才需要同步锁。通过-XX:+&#x2F;-UserTLAB参数来设定虚拟机是否使 用TLAB。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/内存分配时保证线程安全的两种方式.png" alt="内存分配时保证线程安全的两种方式"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>Java</strong>程序需要通过 <strong>JVM</strong> 栈上的引用访问堆中的具体对象。对象的访问方式取决 于 JVM 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。 </p><p>指针： 指向对象，代表一个对象在内存中的起始地址。 </p><p>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是 指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的 真实内存地址。 </p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中 包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所 示：</p><p> <img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/句柄访问.png" alt="句柄访问"></p><p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是 非常普遍的行为）时只会改变<strong>句柄</strong>中的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。 </p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么Java堆对象内 部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/直接指针.png" alt="直接指针"></p><p>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非 常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用 的就是这种方式。 </p><h2 id="内存溢出异常-Java会存在内存泄漏吗？请简单描述"><a href="#内存溢出异常-Java会存在内存泄漏吗？请简单描述" class="headerlink" title="内存溢出异常 Java会存在内存泄漏吗？请简单描述"></a>内存溢出异常 Java会存在内存泄漏吗？请简单描述</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收 掉，自动从内存中清除。 </p><p>但是， 即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因 很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景。</p><h1 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常**"></a><strong>内</strong>存溢出异常**</h1><p><strong>Java</strong>会存在内存泄漏吗？请简单描述**</p><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收 掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因 很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景。</p><p><strong>垃</strong>圾收集器**</p><p><strong>简述Java垃圾回收机制</strong></p><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行 执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会 执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没 有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p><strong>GC</strong>是什么？为什么要GC**</p><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误的内存</p><p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而达到自动</p><p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p><strong>垃圾回收的优点和原理。并考虑2种回收机制</strong></p><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时 不再考虑内存管理的问题。</p><p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的 对象才有“作用域”。</p><p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p><p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存 堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p><p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p><p><strong>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收 内存吗？有什么办法主动通知虚拟机进行垃圾回收？</strong> 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责任回收这些内存空间。</p><p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p><p><strong>Java</strong> <strong>中都有哪些引用类型？</strong></p><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用</li></ul><p>PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><p><strong>怎么判断对象是否可以被回收？</strong></p><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p><p>一般有两种方法来判断：</p><ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><p><strong>在Java中，对象什么时候可以被垃圾回收</strong></p><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被 回收了。</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全 垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代 也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原 因。</p><p><strong>JVM</strong>中的永久代中会发生垃圾回收吗**</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全 垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代 也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原 因。请参考下Java8：从永久代到元数据区</p><p>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存 区)</p><p><strong>说一下 JVM 有哪些垃圾回收算法？</strong></p><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清 除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年 代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><p><strong>标记</strong>-<strong>清</strong>除算法**</p><p>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收 集分为两个阶段：</p><ul><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。</li></ul><p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法 的基础上进行改进的。</p><p><strong>优</strong>点**：实现简单，不需要对象进行移动。</p><p><strong>缺</strong>点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p><p>标记-清除算法的执行的过程如下图所示</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/标记-清除算法.png" alt="标记-清除算法"></p><p><strong>复制算</strong>法**</p><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划 为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区 域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象 进行回收。</p><p><strong>优</strong>点<strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 <strong>缺</strong>点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。 复制算法的执行过程如下图所示</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/复制算法.png" alt="复制算法"></p><p><strong>标记</strong>-<strong>整</strong>理算法**</p><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年 代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除 算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎 片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理 算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使 他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未 用的内存都各自一边。</p><p><strong>优</strong>点**：解决了标记-清理算法存在的内存碎片问题。</p><p><strong>缺</strong>点**：仍需要进行局部对象移动，一定程度上降低了效率。</p><p>标记-整理算法的执行过程如下图所示</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/标记-整理算法.png" alt="标记-整理算法"></p><p><strong>分代收</strong>集<strong>算法</strong></p><p>当前商业虚拟机都采用<strong>分</strong>代<strong>收</strong>集<strong>的垃圾收集算法。分代收集算法，顾名思义是根 据对象的</strong>存活周期<strong>将内存划分为几块。一般包括</strong>年轻代<strong>、</strong>老年代** 和 <strong>永久代</strong>，如 图所示：</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/分代收集算法.png" alt="分代收集算法"></p><p><strong>说一下 JVM 有哪些垃圾回收器？</strong></p><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器 之间的连线表示它们可以搭配使用。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/垃圾回收器.png" alt="垃圾回收器"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不 高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集 器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代 或老年代。</li></ul><p><strong>详细介绍一下 CMS 垃圾回收器？</strong></p><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾 回收器非常适合。在启动 JVM 的参数加上“- XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会 被降低。</p><p><strong>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么 区别？</strong></p><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内 存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><p><strong>简述分代垃圾回收器是怎么工作的？</strong></p><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年 龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的 执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><p><strong>内</strong>存分配策略**</p><p><strong>简述java内存分配与回收策率以及Minor GC和Major GC</strong></p><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我 们介绍了内存回收，这里我们再来聊聊内存分配。</p><p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场 景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区， 如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直 接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种 垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵 循以下几种「普世」规则：</p><p><strong>对象优</strong>先<strong>在 Eden 区分配</strong></p><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行 分配时，虚拟机将会发起一次 Minor GC。如果本次 GC后还是没有足够的空 间，则将启用分配担保机制在老年代中分配内存。</p><p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中 发现 Major GC&#x2F;Full GC。</p><ul><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC&#x2F;Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象</strong>直<strong>接进入老年代</strong></p><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导 致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对 象。</p><p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象 直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><p><strong>长期存</strong>活<strong>对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对 象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升 到老年代。</p><p><strong>虚</strong>拟机类加载机制**</p><p><strong>简述java类加载机制?</strong></p><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初 始化，最终形成可以被虚拟机直接使用的java类型。</p><p><strong>描述一下JVM加载Class文件的原理机制</strong></p><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也 是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时 候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊 的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种 ：</p><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用 类装载器加载对应的类到jvm中，</p><p>2.显式装载， 通过class.forname() 等方法，显式加载需要的类</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证 程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候 才加载。这当然就是为了节省内存开销。</p><p><strong>什么是类加载器，类加载器有哪些?</strong></p><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器:</p><ol><li><p>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被 java程序直接引用。</p></li><li><p>扩展类加载器(extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找 并加载 Java 类。</p></li><li><p>系统类加载器（system class loader ）：它根据 Java 应用的类路径 （CLASSPATH ）来加载 Java 类。一般来说，Java 应用的类都是由它来 完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取 它。</p></li><li><p>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实</p></li></ol><p>现。</p><p><strong>说一下类装载的执行过程？</strong></p><p>类装载分为以下 5个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；</p><p>验证：检查加载的 class 文件的正确性；</p><p>准备：给类中的静态变量分配内存空间；</p><p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为 一个标示，而在直接引用直接指向内存中的地址；</p><p>初始化：对静态变量和静态代码块执行初始化工作。</p><p><strong>什么是双亲委派模型？</strong></p><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的 类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一 个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/双亲委派.png" alt="双亲委派"></p><p>类加载器分类：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚 拟机识别的类库；</p></li><li><p>其他类加载器：</p><ul><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径 （classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我 们没有自定义类加载器默认就是用这个加载器。</li></ul></li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载 这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如 此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无 法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加 载类。</p><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父 类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加 载。</p><p><strong>JVM</strong>调<strong>优</strong></p><p><strong>说一下 JVM 调优的工具？</strong></p><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序 死锁、监控内存的变化、gc 变化等。</li></ul><p><strong>常用的 JVM 调优的参数都有哪些？</strong></p><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4； -XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2； –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合； -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组</li><li>合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组 合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="1-MyBatis是什么？"><a href="#1-MyBatis是什么？" class="headerlink" title="1. MyBatis是什么？"></a>1. MyBatis是什么？</h2><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化  SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及 获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java  的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="2-ORM是什么"><a href="#2-ORM是什么" class="headerlink" title="2. ORM是什么"></a>2. ORM是什么</h2><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数 据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和 数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h2 id="3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时， 可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半 自动ORM映射工具。</p><h2 id="4-传统JDBC开发存在的问题"><a href="#4-传统JDBC开发存在的问题" class="headerlink" title="4. 传统JDBC开发存在的问题"></a>4. 传统JDBC开发存在的问题</h2><p>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池 解决这个问题。但是使用jdbc需要自己实现连接池。 </p><p>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大， 一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。 </p><p>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一 定，可能多也可能少，修改sql还要修改代码，系统不易维护。 </p><p>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</p><h2 id="5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><ol><li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接 池可解决此问题。<br>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</li><li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变 java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需 要和参数一一对应。<br>解决： Mybatis自动将java对象映射至sql语句。</li><li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记 录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象。</li></ol><h2 id="6-Mybatis优缺点"><a href="#6-Mybatis优缺点" class="headerlink" title="6. Mybatis优缺点"></a>6. Mybatis优缺点</h2><p>**优点 **</p><p>与传统的数据库访问技术相比，ORM有以下优点： </p><p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL语句，并可重用 </p><p>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接 </p><p>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数 据库MyBatis都支持） </p><p>**不同点 **</p><p>能够与Spring很好的集成</p><p><strong>缺点</strong></p><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底 有一定要求 </p><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 </p><h2 id="7-MyBatis框架适用场景"><a href="#7-MyBatis框架适用场景" class="headerlink" title="7. MyBatis框架适用场景"></a>7. MyBatis框架适用场景</h2><p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。 </p><p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。 </p><h2 id="8-Hibernate-和-MyBatis-的区别"><a href="#8-Hibernate-和-MyBatis-的区别" class="headerlink" title="8. Hibernate 和 MyBatis 的区别"></a>8. Hibernate 和 MyBatis 的区别</h2><p>**相同点 **</p><ul><li>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</li></ul><p>**不同点 **</p><p>**映射关系 **</p><p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单 </p><p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂 </p><p><strong>SQL优化和移植性</strong></p><p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性， 此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但 会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 </p><p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。 开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优 化容易。 </p><p><strong>开发难易程度和学习成本</strong></p><p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如： 办公自动化系统</p><p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互 联网电子商务系统</p><p><strong>总结</strong></p><p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p><p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p><h1 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h1><h2 id="9-MyBatis编程步骤是什么样的？"><a href="#9-MyBatis编程步骤是什么样的？" class="headerlink" title="9. MyBatis编程步骤是什么样的？"></a>9. MyBatis编程步骤是什么样的？</h2><ol><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ol><h2 id="10-请说说MyBatis的工作原理"><a href="#10-请说说MyBatis的工作原理" class="headerlink" title="10. 请说说MyBatis的工作原理"></a>10. 请说说MyBatis的工作原理</h2><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis  的工作原理如下图</p><p><img src="/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/MyBatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="MyBatis工作原理"></p><p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了  MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句， 需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加 载多个映射文件，每个文件对应数据库中的一张表。</p><p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所 有方法。</p><p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据  SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement  类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信 息。</p><p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和  POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过 程。</p><p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型 和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p><p><strong>MyBatis的功能架构是怎样的</strong></p><p>我们把Mybatis的功能架构分为三层：</p><p>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层 一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p><p>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的 目的是根据调用的请求完成一次数据库操作。</p><p>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这 些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的 支撑。</p><p>MyBatis的框架架构设计是怎么样的</p><p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成 Configuration这个类，就是图中的红框。</p><p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的 配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL 语句、结果映射配置），存储在内存中。</p><p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是 Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的 MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以 得到最终要执行的SQL语句和参数。</p><p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p><p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、 JavaBean或者基本数据类型，并将最终结果返回。</p><p><strong>为什么需要预编译</strong></p><p>定义：</p><p>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编 译，这样 DBMS 执行 SQL 时，就不需要重新编译。 </p><p><strong>为什么需要预编译</strong></p><p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以 优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编 译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时 预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓 存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis 默认情况下，将对所有的 SQL 进行预编译。</p><p><strong>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></p><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、 BatchExecutor。</p><p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使 用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添 加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行 executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 <strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也 可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参 数，如SqlSession openSession(ExecutorType execType) 。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句 （prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p><p><strong>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p><p>Mybatis仅支持association关联对象和collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在Mybatis配置文件中，可以配置是否 启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法， 比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独 发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 <strong>映射器</strong></p><p>#{}和${}的区别</p><p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</p><p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用 PreparedStatement的set方法来赋值。</p><p>Mybatis在处理时，是原值传入，就是把 {}时，是原值传入，就是把时，是原值传入，就是 把{}替换成变量的值，相当于JDBC中的Statement编译</p><p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上 单引号 ‘’</p><p>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p><p>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</p><p>模糊查询like语句该怎么写</p><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p><p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引 号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p><p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p><p>（4）使用bind标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;listUserLikeUsername&quot; resultType=&quot;com.jourwon.pojo.User&quot;&gt;</span><br><span class="line">2 &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt;</span><br><span class="line">3 select id,sex,age,username,password from person where username LIKE #</span><br><span class="line">&#123;pattern&#125;</span><br><span class="line">4 &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在mapper中如何传递多个参数 </p><p>方法1：顺序传参法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(String name, int deptId);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的数字代表传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。 </p><p>方法2：@Param注解传参法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptI</span><br><span class="line">d&quot;) deptId);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，推荐使用。 </p><p>方法3：Map传参法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(Map&lt;String, Object&gt; params);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;UserResu</span><br><span class="line">ltMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是Map里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。 </p><p>方法4：Java Bean传参法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(User user);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot;</span><br><span class="line">resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br><span class="line">7 &lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot;</span><br><span class="line">resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是User类里面的成员属性。</p><p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑 处理方便，推荐使用。</p><p><strong>Mybatis如何执行批量操作</strong></p><p>使用foreach标签</p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的 属性主要有item，index，collection，open，separator，close。</p><p>item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；</p><p>index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用； open　　表示该语句以什么开始，常用“(”；</p><p>separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</p><p>close　　表示以什么结束，常用“)”。</p><p>在使用foreach的时候最关键的也是最容易出错的就是collection 属性，该属性是必须指定 的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： </p><p>如果传入的是单参数且参数类型是一个List的时候，collection 属性值为list</p><p>如果传入的是单参数且参数类型是一个array数组的时候，collection 的属性值为array 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以 封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个 Map的，</p><p>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己 封装的map里面的key</p><p>具体用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 批量保存(foreach插入多条数据两种方法)</span><br><span class="line">2 int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); ‐‐&gt;</span><br><span class="line">3 &lt;!‐‐ MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 ‐‐&gt; //推荐</span><br><span class="line">使用</span><br><span class="line">4 &lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">5 INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">6 VALUES</span><br><span class="line">7 &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">8 (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">9 &lt;/foreach&gt;</span><br><span class="line">10 &lt;/insert&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="line">2 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true ‐‐</span><br><span class="line">&gt;</span><br><span class="line">3 &lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">4 &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;</span><br><span class="line">5 INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">6 VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">7 &lt;/foreach&gt;</span><br><span class="line">8 &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>使用ExecutorType.BATCH</strong></p><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一 个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行 所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作 时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求 的</p><p>具体用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1 //批量保存方法测试</span><br><span class="line">2 @Test</span><br><span class="line">3 public void testBatch() throws IOException&#123;</span><br><span class="line">4 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">5 //可以执行批量操作的sqlSession</span><br><span class="line">6 SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATC</span><br><span class="line">H);</span><br><span class="line">7</span><br><span class="line">8 //批量保存执行前时间</span><br><span class="line">9 long start = System.currentTimeMillis();</span><br><span class="line">10 try &#123;</span><br><span class="line">11 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">12 for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">13 mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0,</span><br><span class="line">5), &quot;b&quot;, &quot;1&quot;));</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 openSession.commit();</span><br><span class="line">17 long end = System.currentTimeMillis();</span><br><span class="line">18 //批量保存执行后的时间</span><br><span class="line">19 System.out.println(&quot;执行时长&quot; + (end ‐ start));</span><br><span class="line">20 //批量 预编译sql一次==》设置参数==》10000次==》执行1次 677</span><br><span class="line">21 //非批量 （预编译=设置参数=执行 ）==》10000次 1121</span><br><span class="line">22</span><br><span class="line">23 &#125; finally &#123;</span><br><span class="line">24 openSession.close();</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br></pre></td></tr></table></figure><p>mapper和mapper.xml如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 public interface EmployeeMapper &#123;</span><br><span class="line">2 //批量保存员工</span><br><span class="line">3 Long addEmp(Employee employee);</span><br><span class="line">4 &#125;</span><br><span class="line">1 &lt;mapper namespace=&quot;com.jourwon.mapper.EmployeeMapper&quot;</span><br><span class="line">2 &lt;!‐‐批量保存员工 ‐‐&gt;</span><br><span class="line">3 &lt;insert id=&quot;addEmp&quot;&gt;</span><br><span class="line">4 insert into employee(lastName,email,gender)</span><br><span class="line">5 values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">6 &lt;/insert&gt;</span><br><span class="line">7 &lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>如何获取生成的主键</strong></p><p>对于支持主键自增的数据库（MySQL）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot; &gt;</span><br><span class="line">2 insert into user(</span><br><span class="line">3 user_name, user_password, create_time)</span><br><span class="line">4 values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=</span><br><span class="line">TIMESTAMP&#125;)</span><br><span class="line">5 &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那 么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体 或者Map 来获取主键值。通过 getUserId获取主键</p><p>不支持主键自增的数据库（Oracle）</p><p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主 键。</p><p>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的 数据库，也适用于提供主键自增功能的数据库</p><p>＜selectKey＞一般的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;BEFOR</span><br><span class="line">E&quot;&gt;</span><br><span class="line">2 &lt;/selectKey&gt;</span><br></pre></td></tr></table></figure><p>属性 描述</p><p>keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列， 也可以是逗号分隔的属性名称列表。</p><p>keyColmn </p><p>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以</p><p>是逗号分隔的属性名称列表。</p><p>resultType </p><p>结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用</p><p>作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性 的 Object 或一个 Map。</p><p>order </p><p>值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 </p><p>keyProperty 然后执行插入语句。如果为AFTER则相反。</p><p>statementType </p><p>使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED </p><p>和 CALLABLE 语句的映射类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;insert id=&quot;insertUser&quot; &gt;</span><br><span class="line">2 &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;userId&quot;</span><br><span class="line">order=&quot;BEFORE&quot;&gt;</span><br><span class="line">3 SELECT USER_ID.nextval as id from dual</span><br><span class="line">4 &lt;/selectKey&gt;</span><br><span class="line">5 insert into user(</span><br><span class="line">6 user_id,user_name, user_password, create_time)</span><br><span class="line">7 values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=</span><br><span class="line">TIMESTAMP&#125;)</span><br><span class="line">8 &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就 可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时 keyProperty&#x3D;“任意自定义变量名”，resultType 可以不写。</p><p>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后 将值作为主键插入到数据库中。</p><p>扩展</p><p>如果Mysql 使用selectKey的方式获取主键，需要注意下面两点：</p><p>order ： AFTER</p><p>获取递增主键值 ：SELECT LAST_INSERT_ID()</p><p>当实体类中的属性名和表中的字段名不一样 ，怎么办</p><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一 致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultType=&quot;com.jourwon.pojo.Or</span><br><span class="line">der&quot;&gt;</span><br><span class="line">2 select order_id id, order_no orderno ,order_price price form orders wher</span><br><span class="line">e order_id=#&#123;id&#125;;</span><br><span class="line">3 &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>第2种： 通过来映射字段名和实体类属性名的一一对应的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderResultMap&quot;&gt;</span><br><span class="line">2 select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">3 &lt;/select&gt;</span><br><span class="line">4</span><br><span class="line">5 &lt;resultMap type=&quot;com.jourwon.pojo.Order&quot; id=&quot;orderResultMap&quot;&gt;</span><br><span class="line">6 &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">7 &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&gt;</span><br><span class="line">8</span><br><span class="line">9 &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的</span><br><span class="line">属性–&gt;</span><br><span class="line">10 &lt;result property =&quot;orderno&quot; column =&quot;order_no&quot;/&gt;</span><br><span class="line">11 &lt;result property=&quot;price&quot; column=&quot;order_price&quot; /&gt;</span><br><span class="line">12 &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure><p><strong>Mapper</strong> <strong>编写有哪几种方式？</strong></p><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接 口，mapper 接口实现类、mapper.xml 文件。</p><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;mappers&gt;</span><br><span class="line">2 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">3 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">4 &lt;/mappers&gt;</span><br></pre></td></tr></table></figure><p>（2）定义 mapper 接口</p><p>（3）实现类集成 SqlSessionDaoSupport</p><p>mapper 方法中可以 this.getSqlSession() 进行数据增删改查。 </p><p>（4）spring 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean id=&quot; &quot; class=&quot;mapper 接口的实现&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;sqlSessionFactory&quot;</span><br><span class="line">3 ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">4 &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;mappers&gt;</span><br><span class="line">2 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">3 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">4 &lt;/mappers&gt;</span><br></pre></td></tr></table></figure><p>（2）定义 mapper 接口：</p><p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p><p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致 </p><p>（5）Spring 中定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;mapperInterface&quot; value=&quot;mapper 接口地址&quot; /&gt;</span><br><span class="line">3 &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">4 &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第三种：使用 mapper 扫描器：</p><p>（1）mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； </p><p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行 配置。</p><p>（2）定义 mapper 接口：</p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录 （3）配置 mapper 扫描器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;basePackage&quot; value=&quot;mapper 接口包地址</span><br><span class="line">3 &quot;&gt;&lt;/property&gt;</span><br><span class="line">4 &lt;property name=&quot;sqlSessionFactoryBeanName&quot;</span><br><span class="line">5 value=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">6 &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p><p><strong>什么是MyBatis的接口绑定？有哪些实现方式？</strong></p><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们 直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的 选择和设置。</p><p>接口绑定有两种实现方式</p><p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语 句来绑定；</p><p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为 接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用 xml绑定，一般用xml绑定的比较多。</p><p><strong>使用MyBatis的mapper接口调用时有哪些要求</strong>？</p><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p><p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的 类型相同。</p><p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型 相同。</p><p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p><p><strong>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口 的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</strong></p><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace 的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就 是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法 名拼接字符串作为key值，可唯一定位一个MappedStatement，举例： com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为 com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。 在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为 一个MappedStatement对象。</p><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成 代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将sql执行结果返回。</p><p><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></p><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置</p><p>namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没 有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id 就可以重复，namespace不同，namespace+id自然也就不同。</p><p><strong>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong></p><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在 Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素 会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其 每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、 <delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql 对象。</p><p><strong>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</p><p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME， 对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智 能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常 工作。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性 逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><p><strong>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</strong> 还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、 <selectKey>，加上动态sql的9个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中<sql>为sql片段标签， 通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p><p><strong>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义 在A标签的后面，还是说必须定义在A标签的前面？</strong></p><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在 任何地方，Mybatis都可以正确识别。</p><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存 在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标 签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><p><strong>高级查询</strong></p><p><strong>MyBatis实现一对一，一对多有几种方式，怎么操作的？</strong></p><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面 的association，collection节点配置一对一，一对多的类就可以完成</p><p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据， 也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p><p><strong>Mybatis是否可以映射Enum枚举类？</strong></p><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列 上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和 getResult()接口方法。</p><p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至 javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占 位符参数和获取列查询结果。</p><p><strong>动态SQL</strong></p><p><strong>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</strong> Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断 和动态拼接sql的功能，Mybatis提供了9种动态sql标签 trim|where|set|foreach|if|choose|when|otherwise|bind 。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态sql的功能。</p><p><strong>插件模块</strong></p><p><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></p><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非 物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分 页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法 内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页 参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><p><strong>简述Mybatis的插件运行原理，以及如何编写一个插件。</strong></p><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、 Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对 象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体 就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要 拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 </p><p><strong>缓存</strong></p><p><strong>Mybatis的一级、二级缓存</strong></p><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session， 当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓 存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默 认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接 口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的 进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring概述-10"><a href="#Spring概述-10" class="headerlink" title="Spring概述(10)"></a>Spring概述(10)</h1><h2 id="1-什么是spring"><a href="#1-什么是spring" class="headerlink" title="1. 什么是spring?"></a>1. 什么是spring?</h2><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早由<strong>Rod Johnson</strong>创建，目的是为了解 决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提 供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应 用程序的开发。 Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发。</strong></p><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能 的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency  injection，DI）和面向切面编程（aspect-oriented programming， AOP）</strong>。</p><p> 为了降低Java开发的复杂性，Spring采取了以下4种关键策略 </p><ul><li>基于POJO的轻量级和最小侵入性编程； </li><li>通过依赖注入和面向接口实现松耦合； </li><li>基于切面和惯例进行声明式编程； </li><li>通过切面和模板减少样板式代码。</li></ul><h2 id="2-Spring框架的设计目标，设计理念，和核心是什么"><a href="#2-Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="2. Spring框架的设计目标，设计理念，和核心是什么"></a>2. Spring框架的设计目标，设计理念，和核心是什么</h2><p><strong>Spring设计目标：</strong>Spring为开发者提供一个一站式轻量级应用开发平台； </p><p><strong>Spring设计理念：</strong>在JavaEE开发中，支持POJO和JavaBean开发方式，使应用 面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现 对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器， 实现解耦； </p><p><strong>Spring框架的核心：</strong>IoC容器和AOP模块。通过IoC容器管理POJO对象以及他 们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。 IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的 功能分离出来形成可重用的功能组件。 </p><h2 id="3-Spring的优缺点是什么？"><a href="#3-Spring的优缺点是什么？" class="headerlink" title="3. Spring的优缺点是什么？"></a>3. Spring的优缺点是什么？</h2><p>**优点 **</p><ul><li>方便解耦，简化开发<br>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring管理。 </li><li>AOP编程的支持<br>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等 功能。 </li><li>声明式事务的支持<br>只需要通过配置就可以完成对事务的管理，而无需手动编程。 </li><li>方便程序的测试<br>Spring对Junit4支持，可以通过注解方便的测试Spring程序。 </li><li>方便集成各种优秀框架<br>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持 （如：Struts、Hibernate、MyBatis等）。 </li><li>降低JavaEE API的使用难度<br>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用 等），都提供了封装，使这些API应用难度大大降低。</li></ul><p>**缺点 **</p><ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全 </li><li>Spring依赖反射，反射影响性能 </li><li>使用门槛升高，入门Spring需要较长时间</li></ul><h2 id="4-Spring有哪些应用场景"><a href="#4-Spring有哪些应用场景" class="headerlink" title="4. Spring有哪些应用场景"></a>4. Spring有哪些应用场景</h2><p><strong>应用场景：</strong>JavaEE企业应用开发，包括SSH、SSM等 </p><p><strong>Spring价值：</strong></p><ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化； </li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离 开来； </li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性 和可测试性；</li></ul><h2 id="5-Spring由哪些模块组成？"><a href="#5-Spring由哪些模块组成？" class="headerlink" title="5. Spring由哪些模块组成？"></a>5. Spring由哪些模块组成？</h2><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被 分别整合在<strong>核心容器（Core Container） 、 AOP（Aspect Oriented Programming） 和设备支持（Instrmentation） 、数据访问与集成（Data Access&#x2F;Integeration） 、  Web、 消息（Messaging） 、 Test</strong>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p><p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201020183306246.png" alt="image-20201020183306246"></p><ul><li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of  Control，IOC）和依赖注入（Dependency Injection，DI）功能。 </li><li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管 理对象称为Bean。 </li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框 架式的对象访问方法。 </li><li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂 商特有的错误代码解析， 用于简化JDBC。 </li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。 </li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet  listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。 </li><li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进 行单元测试和集成测试。</li></ul><h2 id="6-Spring-框架中都用到了哪些设计模式？"><a href="#6-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="6. Spring 框架中都用到了哪些设计模式？"></a>6. Spring 框架中都用到了哪些设计模式？</h2><ol><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实 例； </li><li>单例模式：Bean默认为单例模式。</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生 成技术； </li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate,  JmsTemplate, JpaTemplate。 </li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中 listener的实现–ApplicationListener。</li></ol><h2 id="7-详细讲解一下核心容器（spring-context应用上下文-模-块"><a href="#7-详细讲解一下核心容器（spring-context应用上下文-模-块" class="headerlink" title="7. 详细讲解一下核心容器（spring context应用上下文) 模 块"></a>7. 详细讲解一下核心容器（spring context应用上下文) 模 块</h2><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以 spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为 一个容器。 </p><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和 依赖从真正的应用代码中分离。最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件 中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。 </p><h2 id="8-Spring框架中有哪些不同类型的事件"><a href="#8-Spring框架中有哪些不同类型的事件" class="headerlink" title="8. Spring框架中有哪些不同类型的事件"></a>8. Spring框架中有哪些不同类型的事件</h2><p>Spring 提供了以下5种标准的事件： </p><ol><li>上下文更新事件（ContextRefreshedEvent）：在调用 ConfigurableApplicationContext 接口中的refresh()方法时被触发。 </li><li>上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触 发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 </li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被 关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个 http请求（request）结束触发该事件。如果一个bean实现了 ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean 会自动被通知。</li></ol><h2 id="9-Spring-应用程序有哪些不同组件？"><a href="#9-Spring-应用程序有哪些不同组件？" class="headerlink" title="9. Spring 应用程序有哪些不同组件？"></a>9. Spring 应用程序有哪些不同组件？</h2><p>Spring 应用一般有以下组件： </p><ul><li>接口 - 定义功能。 </li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。 </li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。 </li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。 </li><li>用户程序 - 它使用接口。</li></ul><h2 id="10-使用-Spring-有哪些方式？"><a href="#10-使用-Spring-有哪些方式？" class="headerlink" title="10. 使用 Spring 有哪些方式？"></a>10. 使用 Spring 有哪些方式？</h2><p>使用 Spring 有以下方式： </p><ul><li>作为一个成熟的 Spring Web 应用程序。 </li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。 </li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java  Objects）。 </li><li>用于远程使用。</li></ul><h1 id="Spring控制反转-IOC-（13）"><a href="#Spring控制反转-IOC-（13）" class="headerlink" title="Spring控制反转(IOC)（13）"></a>Spring控制反转(IOC)（13）</h1><h2 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h2><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对</p><p>象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反</p><p>转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h2 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h2><ul><li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li><li>解耦，由容器去维护具体的对象 </li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h2 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h2><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><h2 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h2><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 interface Fruit &#123;</span><br><span class="line">2 public abstract void eat();</span><br><span class="line">3 &#125;</span><br><span class="line">4</span><br><span class="line">5 class Apple implements Fruit &#123;</span><br><span class="line">6 public void eat()&#123;</span><br><span class="line">7 System.out.println(&quot;Apple&quot;);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br><span class="line">11 class Orange implements Fruit &#123;</span><br><span class="line">12 public void eat()&#123;</span><br><span class="line">13 System.out.println(&quot;Orange&quot;);</span><br><span class="line">14 &#125;</span><br><span class="line">15 &#125;</span><br><span class="line">16</span><br><span class="line">17 class Factory &#123;</span><br><span class="line">18 public static Fruit getInstance(String ClassName) &#123;</span><br><span class="line">19 Fruit f=null;</span><br><span class="line">20 try &#123;</span><br><span class="line">21 f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">22 &#125; catch (Exception e) &#123;</span><br><span class="line">23 e.printStackTrace();</span><br><span class="line">24 &#125;</span><br><span class="line">25 return f;</span><br><span class="line">26 &#125;</span><br><span class="line">27 &#125;</span><br><span class="line">28</span><br><span class="line">29 class Client &#123;</span><br><span class="line">30 public static void main(String[] a) &#123;</span><br><span class="line">31 Fruit f=Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;);</span><br><span class="line">32 if(f!=null)&#123;</span><br><span class="line">33 f.eat();</span><br><span class="line">34 &#125;</span><br><span class="line">35 &#125;</span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h2><p>Spring 的 IoC 设计支持以下功能：依赖注入依赖检查自动装配支持集合指定初始化方法和销毁方法</p><p>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</p><p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring </p><p>RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><h2 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做 Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>依赖关系</p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取 bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean 之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具</p><p>有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化。统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><p>加载方式</p><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean 时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所</p><p>依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>创建方式</p><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>注册方式</p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、</p><p>BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h2 id="Spring-如何设计容器的，BeanFactory和-ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和-ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和 ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和 ApplicationContext的关系详解</h2><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，</p><p>Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><p>BeanFactory和ApplicationContext的关系</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 </p><p>ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p><p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" alt="容器的层级关系"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功</p><p>能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p>小结</p><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出</p></li></ol><p>Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 </p><p>BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><p>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans 的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找 bean配置。</p><p>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h2 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h2><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h2 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h2><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接</p><p>口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><ul><li>查找定位操作与应用代码完全无关。</li><li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li><li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li></ul><h2 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor </p><p>Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h2 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h2><table><thead><tr><th>构造函数注入</th><th>setter注 入</th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属 性</td><td>会覆盖 setter 属 性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h2 id="Spring-Beans（19）什么是Spring-beans？"><a href="#Spring-Beans（19）什么是Spring-beans？" class="headerlink" title="Spring Beans（19）什么是Spring beans？"></a>Spring Beans（19）什么是Spring beans？</h2><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p><h2 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h2><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括bean，它的生命周期详情及它的依赖。</p><h3 id="如何创建一个如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何创建一个如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何创建一个如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何创建一个如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li></ul><h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h2 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h2><ol><li><p>Set方法注入；</p></li><li><p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p></li><li><p>静态工厂注入；</p></li><li><p>实例工厂；</p></li></ol><h2 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h2><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过 bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean 每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h2 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h2><p>Spring框架支持以下五种bean的作用域：</p><ul><li>singleton : bean在每个Spring ioc 容器中只有一个实例。</li><li>prototype：一个bean的定义可以有多个实例。</li><li>request：每次http请求都会创建一个bean，该作用域仅在基于web的SpringApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个</li></ul><p>实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h3 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，</p><p>把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean() 了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h2 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前</p><p>需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。解释Spring框架中bean的生命周期</p><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean 实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p><p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="bean生命周期"></p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对 Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><p>Spring对bean进行实例化；</p><p>Spring将值和bean的引用注入到bean对应的属性中；</p><p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；</p><p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方</p><p>法，将BeanFactory容器实例传入；</p><p>如果bean实现了ApplicationContextAware接口，Spring将调用 setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-</p><p>ProcessBeforeInitialization()方法；</p><p>如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，</p><p>该方法也会被调用；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-</p><p>ProcessAfterInitialization()方法；此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p><p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方</p><p>法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p><p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的</p><p>DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p><h2 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h2><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的</p><p>时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><h2 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h2><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p><h2 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h2><p>Spring提供以下几种集合的配置元素：类型用于注入一列值，允许有相同的值。</p><p>类型用于注入一组值，不允许有相同的值。</p><p>类型用于注入一组键值对，键和值都只能为String类型。</p><h2 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h2><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><h2 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h2><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，</p><p>Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通</p><p>过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean </p><p>Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p><h3 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><ul><li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li><li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType进行装配。</li><li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li></ul><h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，。</p><p>在启动spring IoC时，容器自动装载了一个</p><p>AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：  </p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</li></ul><h2 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h2><p>自动装配的局限性是：重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p><p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><h3 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h3><p>可以</p><h1 id="Spring注解（8）"><a href="#Spring注解（8）" class="headerlink" title="Spring注解（8）"></a>Spring注解（8）</h1><h2 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h2><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring 配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被</p><p>Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1@Configuration</span><br><span class="line">2public class StudentConfig &#123;</span><br><span class="line">3@Bean</span><br><span class="line">4public StudentBean myStudent() &#123;</span><br><span class="line">5return new StudentBean();</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><h2 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h2><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 元素。</p><h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h2 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h2><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出</p><p>BeanInitializationException。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1public class Employee &#123;</span><br><span class="line">2private String name;</span><br><span class="line">3@Required</span><br><span class="line">4public void setName(String name)&#123;</span><br><span class="line">5this.name=name;</span><br><span class="line">6&#125;</span><br><span class="line">7public string getName()&#123;</span><br><span class="line">8return name;</span><br><span class="line">9&#125;</span><br><span class="line">10&#125;</span><br></pre></td></tr></table></figure><h2 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h2><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰 setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1public class Employee &#123;</span><br><span class="line">2private String name;</span><br><span class="line">3@Autowired</span><br><span class="line">4public void setName(String name) &#123;</span><br><span class="line">5this.name=name;</span><br><span class="line">6&#125;</span><br><span class="line">7public string getName()&#123;</span><br><span class="line">8return name;</span><br><span class="line">9&#125;</span><br><span class="line">10&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。 </p><h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p><h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL </li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h1 id="Spring数据访问（14）"><a href="#Spring数据访问（14）" class="headerlink" title="Spring数据访问（14）"></a>Spring数据访问（14）</h1><h2 id="解释对象-x2F-关系映射集成模块"><a href="#解释对象-x2F-关系映射集成模块" class="headerlink" title="解释对象&#x2F;关系映射集成模块"></a>解释对象&#x2F;关系映射集成模块</h2><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h2 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h2><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者</p><p>只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><h3 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p><h2 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h2><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访</p><p>问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。</p><p>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h2 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h2><p>JdbcTemplate</p><p>SimpleJdbcTemplate</p><p>NamedParameterJdbcTemplate</p><p>SimpleJdbcInsert</p><p>SimpleJdbcCall</p><h2 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h2><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h2 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h2><p>在Spring中有两种方式访问Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>ernateDAOSupport 并应用 AOP 拦截器节点</li></ul><h2 id="如何通扩展-Hib过HibernateDaoSupport将Spring和Hibernate-结合起来？"><a href="#如何通扩展-Hib过HibernateDaoSupport将Spring和Hibernate-结合起来？" class="headerlink" title="如何通扩展 Hib过HibernateDaoSupport将Spring和Hibernate 结合起来？"></a>如何通扩展 Hib过HibernateDaoSupport将Spring和Hibernate 结合起来？</h2><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p><ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul><h2 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h2><p>Spring支持两种类型的事务管理：编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h2 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，</p><p>spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog或者redo log实现的。</p><h2 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h2><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>\1.    ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>\2.    ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）； 3. ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p><p>\4.    ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p><p>\5.    ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h2 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h2><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API 支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><h2 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h2><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h1 id="Spring面向切面编程-AOP-（13）什么是AOP"><a href="#Spring面向切面编程-AOP-（13）什么是AOP" class="headerlink" title="Spring面向切面编程(AOP)（13）什么是AOP"></a>Spring面向切面编程(AOP)（13）什么是AOP</h1><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h2 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h2><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）  AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）  Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP</p><p>对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><h2 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h2><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ 的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而</p><p>Spring AOP则无需特定的编译器处理。</p><h3 id="InvocationHandler-的-invoke-Object-proxy-Method-method-Object-args-："><a href="#InvocationHandler-的-invoke-Object-proxy-Method-method-Object-args-：" class="headerlink" title="InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)："></a>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：</h3><p>proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p><h2 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h2><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><p>Advice + Target Object &#x3D; Proxy</p><h2 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h2><p>（1）  切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）  连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）  通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）  切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）  引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）  目标对象（Target Object）： 被一个或者多个切面（aspect）所通知</p><p>（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知</p><p>（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）  织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul><h2 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean</p><p>中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是</p><p>ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有 bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p><p>Spring只支持方法级别的连接点</p><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段可以利用Aspect来补充。</p><h2 id="连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h2><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h2 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过</p><p>SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><p>\1. 前置通知（Before）：在目标方法被调用之前调用通知功能；</p><p>\2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p><p>\3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p><p>\4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p><p>\5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice before advice target method 执行 around after advice after advice</p><p>afterReturning</p><p>②有异常情况下的执行顺序： around before advice before advice target method 执行 around after advice after advice</p><p>afterThrowing:异常发生 java.lang.RuntimeException: 异常发生</p><h2 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h2><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p><p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ul><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ul><p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Aspect%E6%B3%A8%E8%A7%A3.png" alt="Aspect注解"></p><h2 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h2><p>在这种情况下，切面由常规类以及基于XML的配置实现。解释基于注解的切面实现</p><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p><h2 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h2><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/05-Spring%20MVC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/05-Spring%20MVC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级 Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的 web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间 的配合。 </p><h2 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h2><p>（1）可以支持各种视图技术,而不仅仅局限于JSP； </p><p>（2）与Spring框架集成（如IoC容器、AOP等）； </p><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射 （handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器 （ViewResolver）。 </p><p>（4） 支持各种请求资源的映射策略。 </p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）<br>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了 其它组件之间的耦合度。 </p><p>（2）处理器映射器HandlerMapping（不需要程序员开发）<br>作用：根据请求的URL来查找Handler </p><p>（3）处理器适配器HandlerAdapter<br>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。 </p><p>（4）处理器Handler（需要程序员开发） </p><p>（5）视图解析器 ViewResolver（不需要程序员开发）<br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view） </p><p>（6）视图View（需要程序员开发jsp）<br>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等 等） </p><h2 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h2><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的 HTTP请求和响应。</p><h2 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h2><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解 析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽 象的方式实现了一个控制层，允许用户创建多种用途的控制器。 </p><h2 id="Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性 能的,解决方案是在控制器里面不能写字段。 </p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下  DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下  DispatcherServlet 的工作流程？</h2><p>（1）用户发送请求至前端控制器DispatcherServlet； </p><p>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器， 请求获取Handle； </p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦 截器(如果有则生成)一并返回给DispatcherServlet； </p><p>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；</p><p>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制 器)； </p><p>（6）Handler执行完成返回ModelAndView； </p><p>（7）HandlerAdapter将Handler执行结果ModelAndView返回给 DispatcherServlet； </p><p>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行 解析；</p><p>（9）ViewResolver解析后返回具体View； </p><p>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） </p><p>（11）DispatcherServlet响应用户。<br>![SpringMVC工作流程](05-Spring MVC面试题（2020最新版）.assets&#x2F;SpringMVC工作流程.png)</p><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h2 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h2><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验 的总结）。模型（model）-视图（view）-控制器（controller），三层架构的 设计模式。用于实现前端页面的展现与后端业务数据处理的分离。 </p><p>mvc设计模式的好处 </p><p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展 性，可维护性。 </p><p>2.有利于系统的并行开发，提升开发效率。 </p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="注解原理是什么"><a href="#注解原理是什么" class="headerlink" title="注解原理是什么"></a>注解原理是什么</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生 成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代 理对象。通过代理对象调用自定义注解的方法，会终调用 AnnotationInvocationHandler的invoke方法。该方法会从memberValues这 个Map中索引出对应的值。而memberValues的来源是Java常量池。 </p><h2 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h2><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用 于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 </p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对 象。 </p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给 客户。</p><h2 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h2><p>答：一般用@Controller注解,也可以使用@RestController,@RestController 注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h2 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h2><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简</p><p>便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使</p><p>用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和 @RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于</p><p>HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC </p><p>Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方</p><p>法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><ul><li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li><li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li></ul><h2 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p>value， method</p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes，produces</p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如 application&#x2F;json, text&#x2F;html;</p><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params，headers</p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的</p><p>HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h2 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h2><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 </p><p>@RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; </p><p>RequestMethod.GET)</p><p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h2><p>相同点都是基于mvc的表现层框架，都用于web项目的开发。</p><p>不同点</p><p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：</p><p>DispatcherServlet。struts2的前端控制器是filter：</p><p>StrutsPreparedAndExcutorFilter。</p><p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p><p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC 通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，   后又将ModelAndView中的模型数据通过 reques域传输到页面。Jsp视图解析器默认使用jstl。</p><p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p><h2 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h2><p>（1）  转发：在返回值前面加”forward:”，譬如”forward:user.do?name&#x3D;method4”</p><p>（2）  重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></p><h2 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。</p><p>具体步骤如下 ：</p><p>（1）  加入Jackson.jar</p><p>（2）  在配置文件中配置json的映射</p><p>（3）  在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p><h2 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><p>（1）  解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;filter&gt;</span><br><span class="line">2 &lt;filter‐name&gt;CharacterEncodingFilter&lt;/filter‐name&gt;</span><br><span class="line">3 &lt;filter‐class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/fi</span><br><span class="line">lter‐class&gt;</span><br><span class="line">4</span><br><span class="line">5 &lt;init‐param&gt;</span><br><span class="line">6 &lt;param‐name&gt;encoding&lt;/param‐name&gt;</span><br><span class="line">7 &lt;param‐value&gt;utf‐8&lt;/param‐value&gt;</span><br><span class="line">8 &lt;/init‐param&gt;</span><br><span class="line">9 &lt;/filter&gt;</span><br><span class="line">10</span><br><span class="line">11 &lt;filter‐mapping&gt;</span><br><span class="line">12 &lt;filter‐name&gt;CharacterEncodingFilter&lt;/filter‐name&gt;</span><br><span class="line">13 &lt;url‐pattern&gt;/*&lt;/url‐pattern&gt;</span><br><span class="line">14 &lt;/filter‐mapping&gt;</span><br></pre></td></tr></table></figure><p>（2）get请求中文参数出现乱码解决方法有两个： </p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;ConnectorURIEncoding=&quot;utf‐8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; proto</span><br><span class="line">col=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><p>②另外一种方法对参数进行重新编码：</p><p>String userName &#x3D; new </p><p>String(request.getParamter(“userName”).getBytes(“ISO8859-</p><p>1”),“utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h2 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h2><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上 method&#x3D;RequestMethod.GET。</p><h2 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h2><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p><h3 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p><h2 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h2><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h3 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h2 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h2><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 配置Spring MVC的拦截器 ‐‐&gt;</span><br><span class="line">2 &lt;mvc:interceptors&gt;</span><br><span class="line">3 &lt;!‐‐ 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 ‐‐&gt;</span><br><span class="line">4 &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.zwp.action.MyHandlerInterceptor&quot;&gt;&lt;/b</span><br><span class="line">ean&gt;</span><br><span class="line">5 &lt;!‐‐ 只针对部分请求拦截 ‐‐&gt;</span><br><span class="line">6 &lt;mvc:interceptor&gt;</span><br><span class="line">7 &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;</span><br><span class="line">8 &lt;bean class=&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot; /&gt;</span><br><span class="line">9 &lt;/mvc:interceptor&gt;</span><br><span class="line">10 &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h2 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h2><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="并发编程的优缺点为什么要使用并发编程（并发编程的优点）"><a href="#并发编程的优缺点为什么要使用并发编程（并发编程的优点）" class="headerlink" title="并发编程的优缺点为什么要使用并发编程（并发编程的优点）"></a>并发编程的优缺点为什么要使用并发编程（并发编程的优点）</h2><ul><li>充分利用多核CPU的计算能力：通过并发编程的形式可以将多核CPU 的计算能力发挥到极致，性能得到提升</li><li>方便进行业务拆分，提升系统并发能力和性能：在特殊的业务场景下，先天的就适合于并发编程。现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li></ul><h2 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h2><p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如</p><p><strong>：内存泄漏、上下文切换、线程安全、死锁</strong>等问题。</p><span id="more"></span><h2 id="并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？"><a href="#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h2><p>并发编程三要素（线程的安全性问题体现在）： </p><p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么 全部执行成功要么全部执行失败。 </p><p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。 （synchronized,volatile） </p><p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行 重排序） </p><p>出现线程安全问题的原因： </p><ul><li>线程切换带来的原子性问题 </li><li>缓存导致的可见性问题 </li><li>编译优化带来的有序性问题</li></ul><p>解决办法： </p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题 </li><li>synchronized、volatile、LOCK，可以解决可见性问题 </li><li>Happens-Before 规则可以解决有序性问题</li></ul><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑 上来看那些任务是同时执行。 </li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上 的“同时进行”。 </li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行 所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><p>做一个形象的比喻： </p><p>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>串行 &#x3D; 一个队列和一台咖啡机。</p><h2 id="什么是多线程，多线程的优劣？"><a href="#什么是多线程，多线程的优劣？" class="headerlink" title="什么是多线程，多线程的优劣？"></a>什么是多线程，多线程的优劣？</h2><p>多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个 不同的线程来执行不同的任务。 </p><p>多线程的好处： 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可 以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单 个程序创建多个并行执行的线程来完成各自的任务。 </p><p>多线程的劣势： </p><ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； </li><li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程； </li><li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问 题。</li></ul><h2 id="线程和进程区别-什么是线程和进程"><a href="#线程和进程区别-什么是线程和进程" class="headerlink" title="线程和进程区别 什么是线程和进程?"></a>线程和进程区别 什么是线程和进程?</h2><p>**进程 **</p><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进 程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进 程。 </p><p><strong>线程</strong></p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至 少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。 </p><p>**进程与线程的区别 **</p><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight  Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)， 它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有 若干个线程，至少包含一个线程。 </p><p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执 行的基本单位 </p><p><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切 换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空 间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开 销小。 </p><p><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线 （线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻 量级进程。 </p><p><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空 间和资源是相互独立的 </p><p><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个 线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 </p><p><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控 制，两者均可并发执行 </p><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任 意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的 策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就 会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 </p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存 自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务<br>从保存到再加载的过程就是一次上下文切换。</strong> </p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在 每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换 对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一 项就是，其上下文切换和模式切换的时间消耗非常少。 </p><h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><p>守护线程和用户线程 </p><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网 络的子线程等都是用户线程 </li><li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护 线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程 会随 JVM 一起结束工作</li></ul><p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部 同时还启动了好多守护线程，比如垃圾回收线程。 比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线 程运行。而守护线程不会影响 JVM 的退出。 </p><p>注意事项： </p><ol><li>setDaemon(true)必须在start()方法前执行，否则会抛出  IllegalThreadStateException 异常 </li><li>在守护线程中产生的新线程也是守护线程 </li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算 逻辑 </li><li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清 理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守 护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语 句块可能无法被执行。</li></ol><h2 id="如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？"><a href="#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h2><p>windows上面用任务管理器看，linux下可以用 top 这个工具看。</p><ol><li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p 查 找出cpu利用厉害的pid号 </li><li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查 找出cpu利用率厉害的线程号，比如top -H -p 1328 </li><li>将获取到的线程号转换成16进制，去百度转换一下就行 </li><li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; &#x2F;tmp&#x2F;t.dat，比 如jstack 31365 &gt; &#x2F;tmp&#x2F;t.dat </li><li>编辑&#x2F;tmp&#x2F;t.dat文件，查找线程号对应的信息</li></ol><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>百度百科：死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资 源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推 进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进 程（线程）称为死锁进程（线程）。 </p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线 程被无限期地阻塞，因此程序不可能正常终止。 </p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方 的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.png" alt="线程死锁"></p><p>线程死锁 下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 public class DeadLockDemo &#123; </span><br><span class="line">2  private static Object resource1 = new Object();//资源 1 </span><br><span class="line">3  private static Object resource2 = new Object();//资源 2</span><br><span class="line">4 </span><br><span class="line">5  public static void main(String[] args) &#123;</span><br><span class="line">6  new Thread(() ‐&gt; &#123; </span><br><span class="line">7  synchronized (resource1) &#123; </span><br><span class="line">8  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">9  try &#123; </span><br><span class="line">10  Thread.sleep(1000); </span><br><span class="line">11  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">12  e.printStackTrace(); </span><br><span class="line">13  &#125; </span><br><span class="line">14  System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); </span><br><span class="line">15  synchronized (resource2) &#123; </span><br><span class="line">16  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">17  &#125; </span><br><span class="line">18  &#125; </span><br><span class="line">19  &#125;, &quot;线程 1&quot;).start();</span><br><span class="line">20 </span><br><span class="line">21  new Thread(() ‐&gt; &#123; </span><br><span class="line">22  synchronized (resource2) &#123; </span><br><span class="line">23  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">24  try &#123; </span><br><span class="line">25  Thread.sleep(1000); </span><br><span class="line">26  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">27  e.printStackTrace(); </span><br><span class="line">28  &#125; </span><br><span class="line">29  System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;); </span><br><span class="line">30  synchronized (resource1) &#123; </span><br><span class="line">31  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">32  &#125; </span><br><span class="line">33  &#125; </span><br><span class="line">34  &#125;, &quot;线程 2&quot;).start(); </span><br><span class="line">35  &#125; </span><br><span class="line">36 &#125; </span><br></pre></td></tr></table></figure><p>输出结果 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 Thread[线程 1,5,main]get resource1 </span><br><span class="line">2 Thread[线程 2,5,main]get resource2 </span><br><span class="line">3 Thread[线程 1,5,main]waiting get resource2 </span><br><span class="line">4 Thread[线程 2,5,main]waiting get resource1 </span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通 过Thread.sleep(1000)；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然 后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死 锁。上面的例子符合产生死锁的四个必要条件。 </p><h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ol><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只 能被一个线程(进程)占用，直到被该线程(进程)释放 </li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对 已获得的资源保持不放。 </li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程 强行剥夺，只有自己使用完毕后才释放资源。 </li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环 路（类似于死循环），造成永久阻塞</li></ol><h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。 </p><p><strong>破坏互斥条件</strong> </p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源 需要互斥访问）。 </p><p><strong>破坏请求与保持条件</strong> </p><p>一次性申请所有的资源。 </p><p>**破坏不剥夺条件 **</p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占 有的资源。 </p><p>**破坏循环等待条件 **</p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环 等待条件。 </p><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 new Thread(() ‐&gt; &#123; </span><br><span class="line">2  synchronized (resource1) &#123; </span><br><span class="line">3  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">4  try &#123; </span><br><span class="line">5  Thread.sleep(1000); </span><br><span class="line">6  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">7  e.printStackTrace();</span><br><span class="line">8  &#125; </span><br><span class="line">9  System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); </span><br><span class="line">10  synchronized (resource2) &#123; </span><br><span class="line">11  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">12  &#125; </span><br><span class="line">13  &#125; </span><br><span class="line">14 &#125;, &quot;线程 2&quot;).start(); </span><br></pre></td></tr></table></figure><p>输出结果 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 Thread[线程 1,5,main]get resource1 </span><br><span class="line">2 Thread[线程 1,5,main]waiting get resource2 </span><br><span class="line">3 Thread[线程 1,5,main]get resource2 </span><br><span class="line">4 Thread[线程 2,5,main]get resource1 </span><br><span class="line">5 Thread[线程 2,5,main]waiting get resource2 </span><br><span class="line">6 Thread[线程 2,5,main]get resource2 </span><br></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生? </p><p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后 线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对  resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样 就破坏了破坏循环等待条件，因此避免了死锁。 </p><h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程有四种方式：</p><ul><li>继承 Thread 类；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>使用 Executors 工具类创建线程池继承 Thread 类</li></ul><p>步骤</p><ol><li>定义一个Thread类的子类，重写run方法，将相关逻辑实现，run()方法</li></ol><p>就是线程要执行的业务逻辑方法 </p><ol start="2"><li><p>创建自定义的线程子类对象</p></li><li><p>调用子类实例的star()方法来启动线程</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyThread extends Thread &#123;</span><br><span class="line">2 </span><br><span class="line">3@Override</span><br><span class="line">4public void run() &#123;</span><br><span class="line">5System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);</span><br><span class="line">6&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public class TheadTest &#123;</span><br><span class="line">2</span><br><span class="line">3public static void main(String[] args) &#123;</span><br><span class="line">4MyThread myThread = new MyThread();</span><br><span class="line">5myThread.start();</span><br><span class="line">6System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);</span><br><span class="line">7&#125;</span><br><span class="line">8</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>运行结果 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 main main()方法执行结束 </span><br><span class="line">2 Thread‐0 run()方法正在执行... </span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>步骤</p><ol><li><p>定义Runnable接口实现类MyRunnable，并重写run()方法</p></li><li><p>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，该Thread对象才是真正的线程对象</p></li><li><p>调用线程对象的start()方法</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyRunnable implements Runnable &#123;</span><br><span class="line">2</span><br><span class="line">3@Override</span><br><span class="line">4public void run() &#123;</span><br><span class="line">5System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">6&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br><span class="line">1 public class RunnableTest &#123;</span><br><span class="line">2</span><br><span class="line">3public static void main(String[] args) &#123;</span><br><span class="line">4MyRunnable myRunnable = new MyRunnable();</span><br><span class="line">5Thread thread = new Thread(myRunnable);</span><br><span class="line">6thread.start();</span><br><span class="line">7System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">8&#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1main main()方法执行完成</span><br><span class="line">2Thread‐0 run()方法执行中...</span><br></pre></td></tr></table></figure><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>步骤</p><ol><li><p>创建实现Callable接口的类myCallable</p></li><li><p>以myCallable为参数创建FutureTask对象</p></li><li><p>将FutureTask作为参数创建Thread对象</p></li><li><p>调用线程对象的start()方法</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">2</span><br><span class="line">3@Override</span><br><span class="line">4public Integer call() &#123;</span><br><span class="line">5System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);</span><br><span class="line">6return 1;</span><br><span class="line">7&#125;</span><br><span class="line">8</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 public class CallableTest &#123;</span><br><span class="line">2</span><br><span class="line">3public static void main(String[] args) &#123;</span><br><span class="line">4FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());</span><br><span class="line">5Thread thread = new Thread(futureTask);</span><br><span class="line">6thread.start();</span><br><span class="line">7</span><br><span class="line">8try &#123;</span><br><span class="line">9Thread.sleep(1000);</span><br><span class="line">10System.out.println(&quot;返回结果 &quot; + futureTask.get());</span><br><span class="line">11&#125; catch (InterruptedException e) &#123;</span><br><span class="line">12e.printStackTrace();</span><br><span class="line">13&#125; catch (ExecutionException e) &#123;</span><br><span class="line">14e.printStackTrace();</span><br><span class="line">15&#125;</span><br><span class="line">16System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">17&#125;</span><br><span class="line">18</span><br><span class="line">19 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1Thread‐0 call()方法执行中...</span><br><span class="line">2返回结果 1</span><br><span class="line">3main main()方法执行完成</span><br></pre></td></tr></table></figure><h3 id="使用-Executors-工具类创建线程池"><a href="#使用-Executors-工具类创建线程池" class="headerlink" title="使用 Executors 工具类创建线程池"></a>使用 Executors 工具类创建线程池</h3><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyRunnable implements Runnable &#123;</span><br><span class="line">2</span><br><span class="line">3@Override</span><br><span class="line">4public void run() &#123;</span><br><span class="line">5System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">6&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 public class SingleThreadExecutorTest &#123;</span><br><span class="line">2 </span><br><span class="line">3  public static void main(String[] args) &#123; </span><br><span class="line">4  ExecutorService executorService = Executors.newSingleThreadExecutor(); </span><br><span class="line">5  MyRunnable runnableTest = new MyRunnable(); </span><br><span class="line">6for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">7executorService.execute(runnableTest);</span><br><span class="line">8&#125;</span><br><span class="line">9</span><br><span class="line">10System.out.println(&quot;线程任务开始执行&quot;);</span><br><span class="line">11executorService.shutdown();</span><br><span class="line">12&#125;</span><br><span class="line">13</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1线程任务开始执行</span><br><span class="line">2pool‐1‐thread‐1 is running...</span><br><span class="line">3pool‐1‐thread‐1 is running...</span><br><span class="line">4pool‐1‐thread‐1 is running...</span><br><span class="line">5pool‐1‐thread‐1 is running...</span><br><span class="line">6pool‐1‐thread‐1 is running...</span><br></pre></td></tr></table></figure><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的， run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。 start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待 run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p><h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h3 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p><p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说</p><p>Callable用于产生结果，Future 用于获取结果。</p><h2 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h2><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 </p><p>Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判</p><p>断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 </p><p>Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><h2 id="线程的状态和基本操作说说线程的生命周期及五种基本状态？"><a href="#线程的状态和基本操作说说线程的生命周期及五种基本状态？" class="headerlink" title="线程的状态和基本操作说说线程的生命周期及五种基本状态？"></a>线程的状态和基本操作说说线程的生命周期及五种基本状态？</h2><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p><ol><li><p>新建(new)：新创建了一个线程对象。</p></li><li><p>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p></li><li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片</p></li></ol><p>（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； </p><ol start="4"><li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</li></ol><p>阻塞的情况分三种：</p><p>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；</p><p>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</p><p>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会</p><p>进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p><ol start="5"><li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了 run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol><h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p><p>有两种调度模型：分时调度模型和抢占式调度模型。</p><p>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p><p>ava虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用</p><p>CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用</p><p>CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p><h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p>线程调度器选择优先级 高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><p>（1）  线程体中调用了 yield 方法让出了对 cpu 的占用权利</p><p>（2）  线程体中调用了 sleep 方法使线程进入睡眠状态</p><p>（3）  线程由于 IO 操作受到阻塞</p><p>（4）  另外一个更高优先级线程出现</p><p>（5）  在支持时间片的系统中，该线程的时间片用完</p><h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</h2><p>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 </p><p>CPU 时间可以基于线程优先级或者线程等待的时间。</p><p>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择</p><p>（也就是说不要让你的程序依赖于线程的优先级）。</p><p>请说出与线程同步以及线程调度相关的方法。</p><p>（1）  wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p><p>（2）  sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p><p>（3）  notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p><p>（4）  notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给</p><p>所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><p>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1synchronized (monitor) &#123;</span><br><span class="line">2// 判断条件谓词是否得到满足</span><br><span class="line">3while(!locked) &#123;</span><br><span class="line">4// 等待唤醒</span><br><span class="line">5monitor.wait();</span><br><span class="line">6&#125;</span><br><span class="line">7// 处理其他的业务逻辑</span><br><span class="line">8&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p><h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，</p><p>接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 </p><p>notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放</p><p>这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><h2 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h2><p>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其</p><p>他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><p>（1）  sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p><p>（2）  线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p><p>（3）  sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p><p>（4）  sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p><h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><p>在java中有以下3种方法可以终止正在运行的线程：</p><p>\1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p><p>\2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及 resume一样都是过期作废的方法。</p><p>\3. 使用interrupt方法中断线程。</p><h2 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h2><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监</p><p>视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出</p><p>interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p><p>isInterrupted：查看当前中断信号是true还是false 什么是阻塞式方法？</p><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回.</p><h2 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h2><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的</p><p>notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p><p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p><p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争</p><p>成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。如何在两个线程间共享数据？在两个线程间共享变量即可实现共享。</p><p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p><h2 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h2><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作比如说 经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><p>Java中线程通信协作的 常见的两种方式：</p><p>一.syncrhoized加锁的线程的Object类的wait()&#x2F;notify()&#x2F;notifyAll()</p><p>二.ReentrantLock类加锁的线程的Condition类的await()&#x2F;signal()&#x2F;signalAll() 线程间直接的数据交换：</p><p>三.通过管道进行线程间通信：1）字节流；2）字符流同步方法和同步块，哪个是更好的选择？</p><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><p>请知道一条原则：同步的范围越小越好。</p><h2 id="什么是线程同步和线程互斥，有哪几种实现方式？"><a href="#什么是线程同步和线程互斥，有哪几种实现方式？" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式？"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h2><p>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</p><p>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻  多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><p>实现线程同步的方法</p><ul><li>同步代码方法：sychronized 关键字修饰的方法同步代码块：</li><li>sychronized 关键字修饰的代码块</li><li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li><li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了 lock接口的锁他与sychronized方法具有相同的基本行为和语义</li></ul><h2 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h2><p>在 java 虚拟机中，每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的</p><p>监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p><p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p><h2 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h2><p>这里区分一下：</p><p>（1）  如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，</p><p>没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p>（2）  如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到</p><p>ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据</p><p>maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略</p><p>RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 什么叫线程安全？servlet 是线程安全吗?</p><p>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p><p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p><p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p><p>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程</p><p>安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p><h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p><p>方法二：使用自动锁 synchronized。</p><p>方法三：使用手动锁 Lock。</p><p>手动锁 Java 示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 Lock lock = new ReentrantLock(); </span><br><span class="line">2 lock. lock(); </span><br><span class="line">3 try &#123;</span><br><span class="line">4System. out. println(&quot;获得锁&quot;);</span><br><span class="line">5&#125; catch (Exception e) &#123;</span><br><span class="line">6// TODO: handle exception</span><br><span class="line">7&#125; finally &#123;</span><br><span class="line">8System. out. println(&quot;释放锁&quot;);</span><br><span class="line">9lock. unlock();</span><br><span class="line">10&#125;</span><br></pre></td></tr></table></figure><h2 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h2><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先 权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS  dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程 会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表低 优先级，10 代表高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先 级有关，如非特别需要，一般无需设置线程优先级。</p><p>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 </p><p>new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了</p><p>Thread1，main 函数中 new 了 Thread2，那么：</p><p>（1）  Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</p><p>（2）  Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</p><h2 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</h2><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump 文件中。</p><p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。</p><p>在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p><p>一个线程运行时发生异常会怎样？如果异常没有被捕获该线程将会停止执行。</p><p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 </p><p>Thread.getUncaughtExceptionHandler()来查询线程的</p><p>UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p><h2 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h2><ul><li><p>线程的生命周期开销非常高消耗过多的 </p></li><li><p>CPU资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p></li><li><p>降低稳定性JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p></li></ul><h1 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p><h3 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h3><p>不会，在下一个垃圾回调周期中，这个对象将是被可回收的。</p><p>也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</p><h3 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h3><p>1）     垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；</p><p>finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { }</p><p>在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间</p><p>2）     GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。</p><h3 id="重排序数据依赖性为什么代码会重排序？"><a href="#重排序数据依赖性为什么代码会重排序？" class="headerlink" title="重排序数据依赖性为什么代码会重排序？"></a>重排序数据依赖性为什么代码会重排序？</h3><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image001.gif" alt="img">在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：在单线程环境下不能改变程序运行的结果；存在数据依赖关系的不允许重排序需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p><h2 id="as-if-srial规则和happens-before规则的区别"><a href="#as-if-srial规则和happens-before规则的区别" class="headerlink" title="as-if-srial规则和happens-before规则的区别"></a>as-if-srial规则和happens-before规则的区别</h2><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image002.gif" alt="img"> as-if-serial语义保证单线程内程序的执行结果不被改变，happensbefore关系保证正确同步的多线程程序的执行结果不被改变。 <img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image003.gif" alt="img"> as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before指定的顺序来执行的。</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image004.gif" alt="img"> as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p><h1 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-的作用？"><a href="#synchronized-的作用？" class="headerlink" title="synchronized 的作用？"></a>synchronized 的作用？</h3><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视</p><p>器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的</p><p>线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方</p><p>对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p>synchronized关键字最主要的三种使用方式：</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image005.gif" alt="img"> 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image006.gif" alt="img"> 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 <img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image007.gif" alt="img"> 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定</p><p>对象的锁。</p><p>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实</p><p>例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具</p><p>有缓存功能！下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 public class Singleton &#123;</span><br><span class="line">2</span><br><span class="line">3 private volatile static Singleton uniqueInstance;</span><br><span class="line">4</span><br><span class="line">5private Singleton() &#123;</span><br><span class="line">6&#125;</span><br><span class="line">7</span><br><span class="line">8public static Singleton getUniqueInstance() &#123;</span><br><span class="line">9//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br><span class="line">10if (uniqueInstance == null) &#123;</span><br><span class="line">11//类对象加锁</span><br><span class="line">12synchronized (Singleton.class) &#123;</span><br><span class="line">13if (uniqueInstance == null) &#123;</span><br><span class="line">14uniqueInstance = new Singleton();</span><br><span class="line">15&#125;</span><br><span class="line">16&#125;</span><br><span class="line">17&#125;</span><br><span class="line">18return uniqueInstance;</span><br><span class="line">19&#125;</span><br><span class="line">20&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance </p><p>&#x3D; new Singleton(); 这段代码其实是分为三步执行：</p><ol><li><p>为 uniqueInstance 分配内存空间</p></li><li><p>初始化 uniqueInstance</p></li><li><p>将 uniqueInstance 指向分配的内存地址</p></li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 </p><p>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。说一下 synchronized 底层实现原理？</p><p>synchronized是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过javap命令，查看相应的字节码文件。 synchronized 同步语句块的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1public class SynchronizedDemo &#123;</span><br><span class="line">2public void method() &#123;</span><br><span class="line">3synchronized (this) &#123;</span><br><span class="line">4System.out.println(&quot;synchronized 代码块&quot;);</span><br><span class="line">5&#125;</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><p>通过JDK 反汇编指令 javap -c -v SynchronizedDemo</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109183510197.png" alt="image-20201109183510197"></p><p>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是</p><p>monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</p><p>为什么会有两个monitorexit呢？</p><p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此 后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p><p>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</p><p>synchronized可重入的原理</p><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h3 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h3 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果</p><p>一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h3 id="线程-B-怎么知道线程-A-修改了变量"><a href="#线程-B-怎么知道线程-A-修改了变量" class="headerlink" title="线程 B 怎么知道线程 A 修改了变量"></a>线程 B 怎么知道线程 A 修改了变量</h3><p>（1）  volatile 修饰变量</p><p>（2）  synchronized 修饰修改变量的方法</p><p>（3）  wait&#x2F;notify</p><p>（4）while 轮询</p><h3 id="当一个线程进一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池</p><p>（注意不是等待池哦）中等待对象的锁。</p><h3 id="synchronized、volatile、CAS-比较"><a href="#synchronized、volatile、CAS-比较" class="headerlink" title="synchronized、volatile、CAS 比较"></a>synchronized、volatile、CAS 比较</h3><p>（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p><p>（3）CAS 是基于冲突检测的乐观锁（非阻塞）</p><h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； </li><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比</p><p>synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都</p><p>相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>相同点：两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</p><p>同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0 时才能释放锁。主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word</li><li>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：  普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象    </li><li>同步方法块，锁是括号里面的对象</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h3><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 </p><p>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 </p><p>AtomicInteger。</p><p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p><h3 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h3><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><h3 id="volatle-变量和-atomic-变量有什么不同？"><a href="#volatle-变量和-atomic-变量有什么不同？" class="headerlink" title="volatle 变量和 atomic 变量有什么不同？"></a>volatle 变量和 atomic 变量有什么不同？</h3><p>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</p><p>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如</p><p>getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><h3 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h3><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double 可以保证其操作原子性。</p><p>所以从Oracle Java Spec里面可以看到：</p><ul><li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li><li>如果使用volatile修饰long和double，那么其读写都是原子操作对于64位的引用地址的读写，都是原子操作</li><li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li><li>推荐JVM实现为原子操作</li></ul><h3 id="volatile-修饰符的有过什么实践？"><a href="#volatile-修饰符的有过什么实践？" class="headerlink" title="volatile 修饰符的有过什么实践？"></a>volatile 修饰符的有过什么实践？</h3><p>单例模式</p><p>是否 Lazy 初始化：是是否多线程安全：是</p><p>实现难度：较复杂描述：对于Double-Check这种可能出现的问题（当然这种概率已经非常小了，但毕竟还是有的嘛~），解决方案是：只需要给instance的声明加上volatile关</p><p>键字即可volatile关键字的一个作用是禁止指令重排，把instance声明为volatile 之后，对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。注意：volatile阻止的不是singleton &#x3D; newSingleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Singleton7 &#123;</span><br><span class="line">2 </span><br><span class="line">3  private static volatile Singleton7 instance = null;</span><br><span class="line">4 </span><br><span class="line">5  private Singleton7() &#123;&#125;</span><br><span class="line">6</span><br><span class="line">7  public static Singleton7 getInstance() &#123;</span><br><span class="line">8  if (instance == null) &#123;</span><br><span class="line">9  synchronized (Singleton7.class) &#123;</span><br><span class="line">10  if (instance == null) &#123;</span><br><span class="line">11  instance = new Singleton7(); </span><br><span class="line">12  &#125; </span><br><span class="line">13  &#125; </span><br><span class="line">14  &#125;</span><br><span class="line">15 </span><br><span class="line">16  return instance;</span><br><span class="line">17  &#125;</span><br><span class="line">18 </span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p><p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p><p>区别</p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比 synchronized关键字要好。但是volatile关键字只能用于变量而</li></ul><p>synchronized关键字可以修饰方法以及代码块。synchronized关键字在</p><p>JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="什么是不可变对象，它对写并发应用有什么帮助？"><a href="#什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助？"></a>什么是不可变对象，它对写并发应用有什么帮助？</h3><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p><p>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不</p><p>可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p><p>只有满足如下状态，一个对象才是不可变的；  它的状态不能在创建后再被修改；  所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</p><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h1 id="Lock体系"><a href="#Lock体系" class="headerlink" title="Lock体系"></a>Lock体系</h1><h2 id="Lock简介与初识AQS"><a href="#Lock简介与初识AQS" class="headerlink" title="Lock简介与初识AQS"></a>Lock简介与初识AQS</h2><h3 id="Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><p>（1）  可以使锁更公平</p><p>（2）  可以使线程在等待锁的时候响应中断</p><p>（3）  可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p><p>（4）  可以在不同的范围，以不同的顺序获取和释放锁</p><p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><h3 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3><p>悲观锁：总是假设 坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 </p><p>Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><p>乐观锁的实现方式：</p><p>1、     使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p><p>2、     java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值</p><p>（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。</p><h3 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h3><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p><p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。</p><p>悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p><p>CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面</p><p>的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p><p>java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的</p><p>(AtomicInteger,AtomicBoolean,AtomicLong)。</p><h3 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h3><p>1、     ABA 问题：比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p><p>2、     循环时间长开销大：</p><p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p><p>3、     只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。什么是死锁？</p><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 </p><p>b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h3 id="产生死锁的条件是什么？怎么防止死锁？"><a href="#产生死锁的条件是什么？怎么防止死锁？" class="headerlink" title="产生死锁的条件是什么？怎么防止死锁？"></a>产生死锁的条件是什么？怎么防止死锁？</h3><p>产生死锁的必要条件：</p><p>1、     互斥条件：所谓互斥就是进程在某一时间内独占资源。</p><p>2、     请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3、     不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</p><p>4、     循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以 大可能地避免、预防和 解除死锁。</p><p>防止死锁可以采用以下的方法：</p><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、</li><li>ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><h3 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p>Java 中导致饥饿的原因：</p><p>1、     高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p><p>2、     线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p><p>3、     线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p><h3 id="多线程锁的升级原理是什么？"><a href="#多线程锁的升级原理是什么？" class="headerlink" title="多线程锁的升级原理是什么？"></a>多线程锁的升级原理是什么？</h3><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降</p><h2 id="AQ-级。-S-AbstractQueuedSynchronizer-详解与源码分析"><a href="#AQ-级。-S-AbstractQueuedSynchronizer-详解与源码分析" class="headerlink" title="AQ(级。)S(AbstractQueuedSynchronizer)详解与源码分析"></a>AQ(级。)S(AbstractQueuedSynchronizer)详解与源码分析</h2><h3 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h3><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks包下面。</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109202104977.png" alt="image-20201109202104977"></p><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h3><p>下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><p>AQS 原理概览</p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制</p><p>AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p><p>看个AQS(AbstractQueuedSynchronizer)原理图：</p><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109202131975.png" alt="image-20201109202131975"></p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1//返回同步状态的当前值</span><br><span class="line">2protected final int getState() &#123;</span><br><span class="line">3return state;</span><br><span class="line">4&#125;</span><br><span class="line">5// 设置同步状态的值</span><br><span class="line">6protected final void setState(int newState) &#123;</span><br><span class="line">7state = newState;</span><br><span class="line">8&#125;</span><br><span class="line">9//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect （期望值）</span><br><span class="line">10protected final boolean compareAndSetState(int expect, int update) &#123; </span><br><span class="line">11 return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p>AQS 对资源的共享方式</p><p>AQS定义两种资源共享方式</p><ul><li><p>xclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：  </p><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p><p>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</p></li><li><p>Share（共享）：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p></li></ul><p>AQS底层使用了模板方法模式同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样</p><p>（模板方法模式很经典的一个应用）：</p><ol><li><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p></li><li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p></li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">2tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">3tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">4tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">5tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回fals e。</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，</p><p>会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就</p><p>会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累</p><p>加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为</p><p>N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS 也支持自定义同步器同时实现独占和共享两种方式，如</p><p>ReentrantReadWriteLock。</p><h2 id="ReentrantLock-重入锁-实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？"><a href="#ReentrantLock-重入锁-实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？" class="headerlink" title="ReentrantLock(重入锁)实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？"></a>ReentrantLock(重入锁)实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？</h2><p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频</p><p>率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</p><p>在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是</p><p>ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。</p><p>重入性的实现原理要想支持重入性，就要解决两个问题：1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。</p><p>ReentrantLock支持两种锁：公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。</p><h2 id="读写锁ReentrantReadWriteLock源码分析"><a href="#读写锁ReentrantReadWriteLock源码分析" class="headerlink" title="读写锁ReentrantReadWriteLock源码分析"></a>读写锁ReentrantReadWriteLock源码分析</h2><h3 id="ReadWriteLock-是什么"><a href="#ReadWriteLock-是什么" class="headerlink" title="ReadWriteLock 是什么"></a>ReadWriteLock 是什么</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p><p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离</p><p>技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>而读写锁有以下三个重要的特性：</p><p>（1）  公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p><p>（2）  重进入：读锁和写锁都支持线程重进入。</p><p>（3）  锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p><h2 id="Condition源码分析与等待通知机制-LockSupport详解并发容器并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析"><a href="#Condition源码分析与等待通知机制-LockSupport详解并发容器并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析" class="headerlink" title="Condition源码分析与等待通知机制 LockSupport详解并发容器并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析"></a>Condition源码分析与等待通知机制 LockSupport详解并发容器并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</h2><h3 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h3><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。平时涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p><p>那么它到底是如何实现线程安全的？</p><p>JDK 1.6版本关键要素：</p><ul><li>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；</li><li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。</li></ul><p>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 </p><p>CAS + synchronized 来保证并发安全性。</p><h3 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h3><p>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数</p><p>的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p><p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p><h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果</p><p>有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，</p><p>Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。</p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操</p><p>作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p><h3 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像</p><p>ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><h3 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</p><p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。</p><p>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</p><p>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</p><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出</p><p>ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h2 id="并发容器之CopyOnWriteArrayList详解"><a href="#并发容器之CopyOnWriteArrayList详解" class="headerlink" title="并发容器之CopyOnWriteArrayList详解"></a>并发容器之CopyOnWriteArrayList详解</h2><h3 id="CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？"><a href="#CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？" class="headerlink" title="CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？"></a>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</h3><p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在</p><p>CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p><p>CopyOnWriteArrayList 的使用场景通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p><p>CopyOnWriteArrayList 的缺点</p><ol><li><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</p></li><li><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然</p></li></ol><p>CopyOnWriteArrayList 能做到   终一致性,但是还是没法满足实时性要求。</p><ol start="3"><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add&#x2F;set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ol><p>CopyOnWriteArrayList 的设计思想</p><ol><li><p>读写分离，读和写分开</p></li><li><p>终一致性</p></li><li><p>使用另外开辟空间的思路，来解决并发冲突并发容器之ThreadLocal详解</p></li></ol><h3 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>hreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个</p><p>ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，</p><p>每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p><p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。</p><p>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。 ThreadLocal 使用例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadLocal &#123;</span><br><span class="line">2</span><br><span class="line">3//线程本地存储变量</span><br><span class="line">4private static final ThreadLocal&lt;Integer&gt; THREAD_LOCAL_NUM</span><br><span class="line">5= new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">6@Override</span><br><span class="line">7protected Integer initialValue() &#123;</span><br><span class="line">8return 0;</span><br><span class="line">9&#125;</span><br><span class="line">10&#125;;</span><br><span class="line">11</span><br><span class="line">12public static void main(String[] args) &#123;</span><br><span class="line">13for (int i = 0; i &lt;3; i++) &#123;//启动三个线程</span><br><span class="line">14Thread t = new Thread() &#123;</span><br><span class="line">15@Override</span><br><span class="line">16public void run() &#123;</span><br><span class="line">17add10ByThreadLocal();</span><br><span class="line">18&#125;</span><br><span class="line">19&#125;;</span><br><span class="line">20t.start();</span><br><span class="line">21&#125;</span><br><span class="line">22&#125;</span><br><span class="line">23</span><br><span class="line">24/**</span><br><span class="line">25* 线程本地存储变量加 5</span><br><span class="line">*/</span><br><span class="line">26 </span><br><span class="line">27private static void add10ByThreadLocal() &#123;</span><br><span class="line">28for (int i = 0; i &lt;5; i++) &#123;</span><br><span class="line">29Integer n = THREAD_LOCAL_NUM.get();</span><br><span class="line">30n += 1;</span><br><span class="line">31THREAD_LOCAL_NUM.set(n);</span><br><span class="line">32System.out.println(Thread.currentThread().getName() + &quot; : ThreadLocal n um=&quot; + n);</span><br><span class="line">33&#125;</span><br><span class="line">34&#125;</span><br><span class="line">35</span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure><p>打印结果：启动了 3 个线程，每个线程 后都打印到 “ThreadLocal num&#x3D;5”，而不是 num 一直在累加直到值等于 15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1Thread‐0 : ThreadLocal num=1</span><br><span class="line">2Thread‐1 : ThreadLocal num=1</span><br><span class="line">3Thread‐0 : ThreadLocal num=2</span><br><span class="line">4Thread‐0 : ThreadLocal num=3</span><br><span class="line">5Thread‐1 : ThreadLocal num=2</span><br><span class="line">6Thread‐2 : ThreadLocal num=1</span><br><span class="line">7Thread‐0 : ThreadLocal num=4</span><br><span class="line">8Thread‐2 : ThreadLocal num=2</span><br><span class="line">9Thread‐1 : ThreadLocal num=3</span><br><span class="line">10Thread‐1 : ThreadLocal num=4</span><br><span class="line">11Thread‐2 : ThreadLocal num=3</span><br><span class="line">12Thread‐0 : ThreadLocal num=5</span><br><span class="line">13Thread‐2 : ThreadLocal num=4</span><br><span class="line">14Thread‐2 : ThreadLocal num=5</span><br><span class="line">15Thread‐1 : ThreadLocal num=5</span><br></pre></td></tr></table></figure><h3 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h3><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h2 id="ThreadLocal内存泄漏分析与解决方案"><a href="#ThreadLocal内存泄漏分析与解决方案" class="headerlink" title="ThreadLocal内存泄漏分析与解决方案"></a>ThreadLocal内存泄漏分析与解决方案</h2><h3 id="ThreadLocal造成内存泄漏的原因？"><a href="#ThreadLocal造成内存泄漏的原因？" class="headerlink" title="ThreadLocal造成内存泄漏的原因？"></a>ThreadLocal造成内存泄漏的原因？</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key 为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 </p><p>ThreadLocal方法后  好手动调用remove()方法</p><h3 id="ThreadLocal内存泄漏解决方案？"><a href="#ThreadLocal内存泄漏解决方案？" class="headerlink" title="ThreadLocal内存泄漏解决方案？"></a>ThreadLocal内存泄漏解决方案？</h3><ul><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li><li>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li></ul><h2 id="并发容器之BlockingQueue详解"><a href="#并发容器之BlockingQueue详解" class="headerlink" title="并发容器之BlockingQueue详解"></a>并发容器之BlockingQueue详解</h2><h3 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7 提供了 7 个阻塞队列。分别是：</p><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>SynchronousQueue：一个不存储元素的阻塞队列。</p><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协</p><p>作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，</p><p>wait,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而</p><p>是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用 经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h2 id="并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与-LinkedBlockingQueue详解线程池-Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？"><a href="#并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与-LinkedBlockingQueue详解线程池-Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？" class="headerlink" title="并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与 LinkedBlockingQueue详解线程池 Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？"></a>并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与 LinkedBlockingQueue详解线程池 Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？</h2><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 </p><p>Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><p>（1）  newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>（2）  newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的 大大小。线程池的大小一旦达到 大值就</p><p>会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p>（3）  newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的 大线程大小。</p><p>（4）  newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><h3 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h3><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制  大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</li></ul><h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ul><li>RUNNING：这是   正常的状态，接受新的任务，处理等待队列中的任务。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>​          TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 </li><li>TIDYING 状态时，会执行钩子方法 terminated()。</li><li>​           TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h3 id="什么是-Executor-框架？为什么使用-Executor-框架？"><a href="#什么是-Executor-框架？为什么使用-Executor-框架？" class="headerlink" title="什么是 Executor 框架？为什么使用 Executor 框架？"></a>什么是 Executor 框架？为什么使用 Executor 框架？</h3><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的，而且无限制的创建线程会引起应用程序内存溢出。</p><p>所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以</p><p>回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。</p><h3 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h3><ul><li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li><li>Executor 接口对象能执行我们的线程任务。</li><li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li><li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li><li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。</li></ul><h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 </p><p>Runnable 和 Callable 类型的任务。</p><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有异常处理：submit()方便Exception处理</p><h3 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p><h2 id="线程池之ThreadPoolExecutor详解"><a href="#线程池之ThreadPoolExecutor详解" class="headerlink" title="线程池之ThreadPoolExecutor详解"></a>线程池之ThreadPoolExecutor详解</h2><h3 id="Executors和ThreaPoolExecutor创建线程池的区别"><a href="#Executors和ThreaPoolExecutor创建线程池的区别" class="headerlink" title="Executors和ThreaPoolExecutor创建线程池的区别"></a>Executors和ThreaPoolExecutor创建线程池的区别</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 各个方法的弊端：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor:<br>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数 大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p><h3 id="你知道怎么创建线程池吗？"><a href="#你知道怎么创建线程池吗？" class="headerlink" title="你知道怎么创建线程池吗？"></a>你知道怎么创建线程池吗？</h3><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p><p>ThreadPoolExecutor() 是 原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p><h3 id="ThreadPoolExecutor构造函数重要参数分析"><a href="#ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="ThreadPoolExecutor构造函数重要参数分析"></a>ThreadPoolExecutor构造函数重要参数分析</h3><p>ThreadPoolExecutor3 个最重要的参数：</p><p>corePoolSize ：核心线程数，线程数定义了    小可以同时运行的线程数量。</p><p>​             maximumPoolSize ：线程池中允许存在的工作线程的  大数量</p><p>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</p><p>ThreadPoolExecutor其他常见参数:</p><ol><li><p>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</p></li><li><p>unit ：keepAliveTime 参数的时间单位。</p></li><li><p>threadFactory：为线程池提供创建新线程的线程工厂</p></li><li><p>handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略 ThreadPoolExecutor饱和策略</p></li></ol><p>ThreadPoolExecutor饱和策略定义:</p><p>如果当前同时运行的线程数量达到  大线程数量并且队列也已经被放满了任时，</p><p>ThreadPoolTaskExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃 早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 </p><p>RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 </p><p>ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 </p><p>ThreadPoolExecutor.CallerRunsPolicy。当  大池被填满时，此策略为我们提供可</p><p>伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p><h3 id="一个简单的线程池Demo-Runnable-ThreadPoolExecutor-线程池实现原理"><a href="#一个简单的线程池Demo-Runnable-ThreadPoolExecutor-线程池实现原理" class="headerlink" title="一个简单的线程池Demo:Runnable+ThreadPoolExecutor 线程池实现原理"></a>一个简单的线程池Demo:Runnable+ThreadPoolExecutor 线程池实现原理</h3><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109203453876.png" alt="image-20201109203453876"></p><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 </p><p>Demo。</p><p>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1 import java.util.Date;</span><br><span class="line">2</span><br><span class="line">3/** </span><br><span class="line">4  * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="line">5  */</span><br><span class="line">6 public class MyRunnable implements Runnable &#123;</span><br><span class="line">7 </span><br><span class="line">8  private String command;</span><br><span class="line">9 </span><br><span class="line">10  public MyRunnable(String s) &#123; </span><br><span class="line">11  this.command = s;</span><br><span class="line">12  &#125;</span><br><span class="line">13</span><br><span class="line">14  @Override </span><br><span class="line">15  public void run() &#123; </span><br><span class="line">16  System.out.println(Thread.currentThread().getName() + &quot; Start. Time = &quot; + new Date()); </span><br><span class="line">17  processCommand();</span><br><span class="line">18  System.out.println(Thread.currentThread().getName() + &quot; End. Time = &quot; + new Date()); </span><br><span class="line">19  &#125;</span><br><span class="line">20 </span><br><span class="line">21  private void processCommand() &#123;</span><br><span class="line">22  try &#123;</span><br><span class="line">23  Thread.sleep(5000);</span><br><span class="line">24  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">25  e.printStackTrace(); </span><br><span class="line">26  &#125; </span><br><span class="line">27  &#125;</span><br><span class="line">28 </span><br><span class="line">29  @Override</span><br><span class="line">30  public String toString() &#123; </span><br><span class="line">31  return this.command;</span><br><span class="line">32  &#125;</span><br><span class="line">33 &#125; </span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1 import java.util.concurrent.ArrayBlockingQueue; </span><br><span class="line">2 import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">3 import java.util.concurrent.TimeUnit;</span><br><span class="line">4 </span><br><span class="line">5 public class ThreadPoolExecutorDemo &#123;</span><br><span class="line">6</span><br><span class="line">7  private static final int CORE_POOL_SIZE = 5;</span><br><span class="line">8  private static final int MAX_POOL_SIZE = 10; </span><br><span class="line">9  private static final int QUEUE_CAPACITY = 100;</span><br><span class="line">10  private static final Long KEEP_ALIVE_TIME = 1L; </span><br><span class="line">11  public static void main(String[] args) &#123;</span><br><span class="line">12</span><br><span class="line">13  //使用阿里巴巴推荐的创建线程池的方式</span><br><span class="line">14  //通过ThreadPoolExecutor构造函数自定义参数创建 </span><br><span class="line">15  ThreadPoolExecutor executor = new ThreadPoolExecutor( </span><br><span class="line">16  CORE_POOL_SIZE, </span><br><span class="line">17  MAX_POOL_SIZE, </span><br><span class="line">18  KEEP_ALIVE_TIME, </span><br><span class="line">19  TimeUnit.SECONDS,</span><br><span class="line">20  new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), </span><br><span class="line">21  new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">22</span><br><span class="line">23  for (int i = 0; i &lt; 10; i++) &#123; </span><br><span class="line">24  //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">25  Runnable worker = new MyRunnable(&quot;&quot; + i); </span><br><span class="line">26  //执行Runnable </span><br><span class="line">27  executor.execute(worker);</span><br><span class="line">28  &#125; </span><br><span class="line">29  //终止线程池 </span><br><span class="line">30  executor.shutdown(); </span><br><span class="line">31  while (!executor.isTerminated()) &#123; </span><br><span class="line">32  &#125; </span><br><span class="line">33  System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">34  &#125;</span><br><span class="line">35 &#125; </span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><p>corePoolSize: 核心线程数为 5。</p></li><li><p>maximumPoolSize ：   大线程数 10</p></li><li><p>keepAliveTime : 等待时间为 1L。</p></li><li><p>unit: 等待时间的单位为 TimeUnit.SECONDS。</p></li><li><p>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</p></li></ol><p>handler:饱和策略为 CallerRunsPolicy。 Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1pool‐1‐thread‐2 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">2pool‐1‐thread‐5 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">3pool‐1‐thread‐4 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">4pool‐1‐thread‐1 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">5pool‐1‐thread‐3 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">6pool‐1‐thread‐5 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">7pool‐1‐thread‐3 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">8pool‐1‐thread‐2 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">9pool‐1‐thread‐4 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">10pool‐1‐thread‐1 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">11pool‐1‐thread‐2 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">12pool‐1‐thread‐1 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">13pool‐1‐thread‐4 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">14pool‐1‐thread‐3 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">15pool‐1‐thread‐5 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">16pool‐1‐thread‐2 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">17pool‐1‐thread‐3 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">18pool‐1‐thread‐4 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">19pool‐1‐thread‐5 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">20pool‐1‐thread‐1 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br></pre></td></tr></table></figure><h2 id="线程池之ScheduledThreadPoolExecutor详解-FutureTask详解原子操作类"><a href="#线程池之ScheduledThreadPoolExecutor详解-FutureTask详解原子操作类" class="headerlink" title="线程池之ScheduledThreadPoolExecutor详解 FutureTask详解原子操作类"></a>线程池之ScheduledThreadPoolExecutor详解 FutureTask详解原子操作类</h2><h3 id="什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？"></a>什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？</h3><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。</p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——</p><p>Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持</p><p>CAS 的原子操作。</p><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用</p><p>同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，</p><p>AtomicReference</p><p>原子数组：AtomicIntegerArray，AtomicLongArray，</p><p>AtomicReferenceArray</p><p>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，</p><p>AtomicReferenceFieldUpdater</p><p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个</p><p>boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）说一下 atomic 的原理？</p><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个</p><p>（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>AtomicInteger 类的部分源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><br><span class="line">2private static final Unsafe unsafe = Unsafe.getUnsafe(); 3 private static final long valueOffset;</span><br><span class="line">4</span><br><span class="line">5static &#123;</span><br><span class="line">6try &#123;</span><br><span class="line">7valueOffset = unsafe.objectFieldOffset</span><br><span class="line">8(AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">9&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">10&#125;</span><br><span class="line">11</span><br><span class="line">12 private volatile int value;</span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。</p><p>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个</p><p>volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的 新值。</p><h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h2 id="并发工具之CountDownLatch与CyclicBarrier"><a href="#并发工具之CountDownLatch与CyclicBarrier" class="headerlink" title="并发工具之CountDownLatch与CyclicBarrier"></a>并发工具之CountDownLatch与CyclicBarrier</h2><h3 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h3><p>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p><ul><li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li><li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li><li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入 barrierAction，指定当所有线程都到达时执行的业务功能；</li><li>CountDownLatch是不能复用的，而CyclicLatch是可以复用的。</li></ul><h2 id="并发工具之Semaphore与Exchanger"><a href="#并发工具之Semaphore与Exchanger" class="headerlink" title="并发工具之Semaphore与Exchanger"></a>并发工具之Semaphore与Exchanger</h2><h3 id="Semaphore-有什么作用"><a href="#Semaphore-有什么作用" class="headerlink" title="Semaphore 有什么作用"></a>Semaphore 有什么作用</h3><p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。</p><p>Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码 多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p><p>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 </p><p>ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量) 可以指定多个线程同时访问某个资源。</p><h3 id="什么是线程间交换数据的工具Exchanger"><a href="#什么是线程间交换数据的工具Exchanger" class="headerlink" title="什么是线程间交换数据的工具Exchanger"></a>什么是线程间交换数据的工具Exchanger</h3><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供</p><p>了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过 exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p><h3 id="常用的并发工具类有哪些？"><a href="#常用的并发工具类有哪些？" class="headerlink" title="常用的并发工具类有哪些？"></a>常用的并发工具类有哪些？</h3><ul><li>Semaphore(信号量)-允许多个线程同时访问： synchronized 和ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li>CountDownLatch(倒计时器)： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li>CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到 后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 </li><li>CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul><h1 id="并发实践"><a href="#并发实践" class="headerlink" title="并发实践"></a>并发实践</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java异常架构与异常关键字"><a href="#Java异常架构与异常关键字" class="headerlink" title="Java异常架构与异常关键字"></a>Java异常架构与异常关键字</h1><h2 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。</p><p>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答 what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</p><h2 id="Java异常架构"><a href="#Java异常架构" class="headerlink" title="Java异常架构"></a>Java异常架构</h2><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Java%E5%BC%82%E5%B8%B8.png" alt="Java异常"></p><h3 id="1-Throwable"><a href="#1-Throwable" class="headerlink" title="1. Throwable"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><span id="more"></span><h3 id="2-Error（错误）"><a href="#2-Error（错误）" class="headerlink" title="2. Error（错误）"></a>2. Error（错误）</h3><p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual </p><p>MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）</p><p>等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不</p><p>应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><h3 id="3-Exception（异常）"><a href="#3-Exception（异常）" class="headerlink" title="3. Exception（异常）"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p><p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、</p><p>ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛</p><p>出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p><p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><p>定义: Exception 中除 RuntimeException 及其子类之外的异常。</p><p>特点: Java 编译器会检查它。如果程序中出现此类异常，比如 </p><p>ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p><h3 id="4-受检异常与非受检异常"><a href="#4-受检异常与非受检异常" class="headerlink" title="4. 受检异常与非受检异常"></a>4. 受检异常与非受检异常</h3><p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常</p><p>（unchecked exception）。</p><h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h4><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合</p><p>预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 </p><p>RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p><h4 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h4><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误(Error)</p><h2 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h2><p>• try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p><p>• catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p><p>• finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了 return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p><p>• throw – 用于抛出异常。</p><p>• throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p><h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109173809704.png" alt="image-20201109173809704"></p><p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对</p><p>象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、 catch、throw、throws 和 finally。</p><p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p><h2 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下</p><p>去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意</p><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/clip_image001-1604914706296.gif" alt="img"> 非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</p><p>​         <img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/clip_image002-1604914706296.gif" alt="img"> 一个方法出现编译时异常，就需要 try-catch&#x2F; throws 处理，否则会导致编译错误</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。 throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。如何选择异常类型</p><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109173855168.png" alt="image-20201109173855168"></p><h2 id="常见异常处理方式直接抛出异常"><a href="#常见异常处理方式直接抛出异常" class="headerlink" title="常见异常处理方式直接抛出异常"></a>常见异常处理方式直接抛出异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws IOException &#123; </span><br><span class="line">2 File file = new File(filePath);</span><br><span class="line">3 String result; </span><br><span class="line">4 BufferedReader reader = new BufferedReader(new FileReader(file)); </span><br><span class="line">5 while((result = reader.readLine())!=null) &#123; </span><br><span class="line">6 System.out.println(result);</span><br><span class="line">7&#125;</span><br><span class="line">8reader.close();</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure><h3 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws MyException &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// code</span><br><span class="line">4 &#125; catch (IOException e) &#123;</span><br><span class="line">5MyException ex = new MyException(&quot;read file failed.&quot;);</span><br><span class="line">6ex.initCause(e);</span><br><span class="line">7throw ex;</span><br><span class="line">8&#125;</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1private static void readFile(String filePath) &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// code</span><br><span class="line">4&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">5// handle FileNotFoundException</span><br><span class="line">6 &#125; catch (IOException e)&#123;</span><br><span class="line">7// handle IOException</span><br><span class="line">8&#125;</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1private static void readFile(String filePath) &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// code</span><br><span class="line">4&#125; catch (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">5// handle FileNotFoundException or UnknownHostException</span><br><span class="line">6 &#125; catch (IOException e)&#123;</span><br><span class="line">7// handle IOException</span><br><span class="line">8&#125;</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详</p><p>细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1public class MyException extends Exception &#123;</span><br><span class="line">2public MyException()&#123; &#125;</span><br><span class="line">3public MyException(String msg)&#123;</span><br><span class="line">4super(msg);</span><br><span class="line">5&#125;</span><br><span class="line">6// ...</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws MyException &#123; </span><br><span class="line">2  File file = new File(filePath); </span><br><span class="line">3  String result;</span><br><span class="line">4  BufferedReader reader = null; </span><br><span class="line">5  try &#123; </span><br><span class="line">6  reader = new BufferedReader(new FileReader(file)); </span><br><span class="line">7  while((result = reader.readLine())!=null) &#123;</span><br><span class="line">8  System.out.println(result); </span><br><span class="line">9  &#125; </span><br><span class="line">10  &#125; catch (IOException e) &#123;</span><br><span class="line">11  System.out.println(&quot;readFile method catch block.&quot;); </span><br><span class="line">12  MyException ex = new MyException(&quot;read file failed.&quot;); </span><br><span class="line">13  ex.initCause(e);</span><br><span class="line">14  throw ex; </span><br><span class="line">15  &#125; finally &#123; </span><br><span class="line">16  System.out.println(&quot;readFile method finally block.&quot;);</span><br><span class="line">17  if (null != reader) &#123; </span><br><span class="line">18  try &#123;</span><br><span class="line">19  reader.close(); </span><br><span class="line">20  &#125; catch (IOException e) &#123;</span><br><span class="line">21  e.printStackTrace(); </span><br><span class="line">22  &#125; </span><br><span class="line">23  &#125;</span><br><span class="line">24  &#125; </span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure><p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入  finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入  finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。 若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码 中的 catch 子句修改如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 catch (IOException e) &#123; </span><br><span class="line">2  System.out.println(&quot;readFile method catch block.&quot;);</span><br><span class="line">3  return; </span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是 否执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 readFile method catch block. </span><br><span class="line">2 readFile method finally block.</span><br></pre></td></tr></table></figure><p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1private static void tryWithResourceTest()&#123;</span><br><span class="line">2try (Scanner scanner = new Scanner(new FileInputStream(&quot;c:/abc&quot;),&quot;UTF8&quot;))&#123;</span><br><span class="line">3// code</span><br><span class="line">4 &#125; catch (IOException e)&#123;</span><br><span class="line">5// handle exception</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h1 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h1><h2 id="1-Error-和-Exception-区别是什么？"><a href="#1-Error-和-Exception-区别是什么？" class="headerlink" title="1. Error 和 Exception 区别是什么？"></a>1. Error 和 Exception 区别是什么？</h2><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出 等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕 获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复； </p><p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错 误，应对其进行处理，使应用程序可以继续正常运行。 </p><h2 id="2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="2. 运行时异常和一般异常(受检异常)区别是什么？"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h2><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出 现的异常。 Java 编译器不会检查运行时异常。 </p><p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编 译器会检查受检异常。 </p><p><strong>RuntimeException异常和受检异常之间的区别：</strong>是否强制要求调用者必须处 理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建 议使用RuntimeException异常。 </p><h2 id="3-JVM-是如何处理异常的？"><a href="#3-JVM-是如何处理异常的？" class="headerlink" title="3. JVM 是如何处理异常的？"></a>3. JVM 是如何处理异常的？</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM， 该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常 对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，终才进 入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p><p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常 处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如 果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异 常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并 终止应用程序。 </p><h2 id="4-throw-和-throws-的区别是什么？"><a href="#4-throw-和-throws-的区别是什么？" class="headerlink" title="4. throw 和 throws 的区别是什么？"></a>4. throw 和 throws 的区别是什么？</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出 异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法 内部通过 throw 拋出异常对象。 </p><p>**throws 关键字和 throw 关键字在使用上的几点区别如下： **</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中 的异常，受查异常和非受查异常都可以被抛出。 </li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出 的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中 必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异 常。</li></ul><h2 id="5-final、finally、finalize-有什么区别？"><a href="#5-final、finally、finalize-有什么区别？" class="headerlink" title="5. final、finally、finalize 有什么区别？"></a>5. final、finally、finalize 有什么区别？</h2><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方 法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 </li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执 行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用 来存放一些关闭资源的代码。 </li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类， Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的 清理工作。</li></ul><h2 id="6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="6. NoClassDefFoundError 和  ClassNotFoundException 区别？"></a>6. NoClassDefFoundError 和  ClassNotFoundException 区别？</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该 尝试捕获这个异常。 </p><p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类 的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到 了，可能是变异后被删除了等原因导致； </p><p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其 进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用  Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动 态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中， 另一个加载器又尝试去加载它。 </p><h2 id="7-try-catch-finally-中哪个部分可以省略？"><a href="#7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="7. try-catch-finally 中哪个部分可以省略？"></a>7. try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略 </p><p>**原因 **</p><p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时 异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处 理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch可以省略，你加上catch编译器也觉得无可厚非。 </p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对 所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛 出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾 处理，或者加上catch捕获以便进一步处理。 </p><p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。  </p><h2 id="8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？"><a href="#8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？" class="headerlink" title="8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？"></a>8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</h2><p>答：会执行，在 return 前执行。 </p><p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块， try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块 执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会 返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的 困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也 可以通过提升编译器的语法检查级别来产生警告或错误。 </p><p><strong>代码示例1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public static int getInt() &#123; </span><br><span class="line">2  int a = 10; </span><br><span class="line">3  try &#123;</span><br><span class="line">4  System.out.println(a / 0); </span><br><span class="line">5  a = 20; </span><br><span class="line">6  &#125; catch (ArithmeticException e) &#123; </span><br><span class="line">7  a = 30; </span><br><span class="line">8  return a; </span><br><span class="line">9  /* </span><br><span class="line">10  * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返 回路径就形成了 </span><br><span class="line">11  * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 </span><br><span class="line">12  * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量 了，而是常量30 </span><br><span class="line">13  */ </span><br><span class="line">14  &#125; finally &#123; </span><br><span class="line">15  a = 40; </span><br><span class="line">16  &#125; </span><br><span class="line">17  return a; </span><br><span class="line">18 &#125; </span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong>30 </p><p><strong>代码示例2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 public static int getInt() &#123; </span><br><span class="line">2  int a = 10; </span><br><span class="line">3  try &#123; </span><br><span class="line">4  System.out.println(a / 0); </span><br><span class="line">5  a = 20; </span><br><span class="line">6  &#125; catch (ArithmeticException e) &#123; </span><br><span class="line">7  a = 30; </span><br><span class="line">8  return a; </span><br><span class="line">9  &#125; finally &#123; </span><br><span class="line">10  a = 40; </span><br><span class="line">11  //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直 接返回40 </span><br><span class="line">12  return a; </span><br><span class="line">13  &#125;</span><br><span class="line">14 </span><br><span class="line">15 &#125; </span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong>40  </p><h2 id="9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。"><a href="#9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。" class="headerlink" title="9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。"></a>9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</h2><p>有如下代码片断： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 try &#123; </span><br><span class="line">2  throw new ExampleB(&quot;b&quot;) </span><br><span class="line">3 &#125; catch（ExampleA e）&#123; </span><br><span class="line">4  System.out.println(&quot;ExampleA&quot;); </span><br><span class="line">5 &#125; catch（Exception e）&#123; </span><br><span class="line">6  System.out.println(&quot;Exception&quot;); </span><br><span class="line">7 &#125; </span><br></pre></td></tr></table></figure><p>请问执行此段代码的输出是什么？ </p><p><strong>答：</strong> </p><p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类 型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB  类型的异常） </p><p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 class Annoyance extends Exception &#123; </span><br><span class="line">2 &#125; </span><br><span class="line">3 class Sneeze extends Annoyance &#123; </span><br><span class="line">4 &#125; </span><br><span class="line">5 class Human &#123; </span><br><span class="line">6  public static void main(String[] args) </span><br><span class="line">7  throws Exception &#123; </span><br><span class="line">8  try &#123; </span><br><span class="line">9  try &#123; </span><br><span class="line">10  throw new Sneeze(); </span><br><span class="line">11  &#125; catch ( Annoyance a ) &#123; </span><br><span class="line">12  System.out.println(&quot;Caught Annoyance&quot;); </span><br><span class="line">13  throw a; </span><br><span class="line">14  &#125; </span><br><span class="line">15  &#125; catch ( Sneeze s ) &#123; </span><br><span class="line">16  System.out.println(&quot;Caught Sneeze&quot;); </span><br><span class="line">17  return ; </span><br><span class="line">18  &#125; finally &#123; </span><br><span class="line">19  System.out.println(&quot;Hello World!&quot;); </span><br><span class="line">20  &#125; </span><br><span class="line">21  &#125; </span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure><p> <strong>结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Caught Annoyance </span><br><span class="line">2 Caught Sneeze </span><br><span class="line">3 Hello World! </span><br></pre></td></tr></table></figure><h2 id="10-常见的-RuntimeException-有哪些？"><a href="#10-常见的-RuntimeException-有哪些？" class="headerlink" title="10. 常见的 RuntimeException 有哪些？"></a>10. 常见的 RuntimeException 有哪些？</h2><ul><li>ClassCastException(类转换异常) </li><li>IndexOutOfBoundsException(数组越界) </li><li>NullPointerException(空指针) </li><li>ArrayStoreException(数据存储异常，操作数组时类型不一致) </li><li>还有IO操作的BufferOverflowException异常</li></ul><h2 id="11-Java常见异常有哪些"><a href="#11-Java常见异常有哪些" class="headerlink" title="11. Java常见异常有哪些"></a>11. Java常见异常有哪些</h2><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p><p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时,抛出该异常</p><h1 id="Java异常处理最佳实践"><a href="#Java异常处理最佳实践" class="headerlink" title="Java异常处理最佳实践"></a>Java异常处理最佳实践</h1><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。本文给出几个被很多团队使用的异常处理 佳实践。</p><h2 id="1-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#1-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="1. 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>1. 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在 try块的 后关闭资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1public void doNotCloseResourceInTry() &#123;</span><br><span class="line">2FileInputStream inputStream = null;</span><br><span class="line">3try &#123;</span><br><span class="line">4File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">5inputStream = new FileInputStream(file);</span><br><span class="line">6// use the inputStream to read a file</span><br><span class="line">7// do NOT do this</span><br><span class="line">8inputStream.close();</span><br><span class="line">9&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">10log.error(e);</span><br><span class="line">11&#125; catch (IOException e) &#123;</span><br><span class="line">12log.error(e);</span><br><span class="line">13&#125;</span><br><span class="line">14&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的  后部分。结果就是，你并没有关闭资源。</p><p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><h3 id="1-1-使用-finally-代码块"><a href="#1-1-使用-finally-代码块" class="headerlink" title="1.1 使用 finally 代码块"></a>1.1 使用 finally 代码块</h3><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功</p><p>执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public void closeResourceInFinally() &#123; </span><br><span class="line">2  FileInputStream inputStream = null; </span><br><span class="line">3  try &#123; </span><br><span class="line">4  File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">5  inputStream = new FileInputStream(file); </span><br><span class="line">6  // use the inputStream to read a file</span><br><span class="line">7  &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">8  log.error(e);</span><br><span class="line">9  &#125; finally &#123;</span><br><span class="line">10  if (inputStream != null) &#123; </span><br><span class="line">11  try &#123; </span><br><span class="line">12  inputStream.close(); </span><br><span class="line">13  &#125; catch (IOException e) &#123; </span><br><span class="line">14  log.error(e); </span><br><span class="line">15  &#125; </span><br><span class="line">16  &#125; </span><br><span class="line">17  &#125;</span><br><span class="line">18 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Java-7-的-try-with-resource-语法"><a href="#1-2-Java-7-的-try-with-resource-语法" class="headerlink" title="1.2 Java 7 的 try-with-resource 语法"></a>1.2 Java 7 的 try-with-resource 语法</h3><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1public void automaticallyCloseResource() &#123;</span><br><span class="line">2File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">3try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">4// use the inputStream to read a file</span><br><span class="line">5&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">6log.error(e);</span><br><span class="line">7 &#125; catch (IOException e) &#123;</span><br><span class="line">8log.error(e);</span><br><span class="line">9&#125;</span><br><span class="line">10&#125;</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="2-优先明确的异常"><a href="#2-优先明确的异常" class="headerlink" title="2. 优先明确的异常"></a>2. 优先明确的异常</h2><p>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</p><p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。因此，总是尝试寻找 适合你的异常事件的类，例如，抛出一个 </p><p>NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public void doNotDoThis() throws Exception &#123;</span><br><span class="line">2 ...</span><br><span class="line">3&#125;</span><br><span class="line">4public void doThis() throws NumberFormatException &#123; </span><br><span class="line">5 ...</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="3-对异常进行文档说明"><a href="#3-对异常进行文档说明" class="headerlink" title="3. 对异常进行文档说明"></a>3. 对异常进行文档说明</h2><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p><p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 public void doSomething(String input) throws MyBusinessException &#123; </span><br><span class="line">2 ...</span><br><span class="line">3 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-使用描述性消息抛出异常"><a href="#4-使用描述性消息抛出异常" class="headerlink" title="4. 使用描述性消息抛出异常"></a>4. 使用描述性消息抛出异常</h2><p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p><p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1try &#123;</span><br><span class="line">2new Long(&quot;xyz&quot;);</span><br><span class="line">3 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">4log.error(e);</span><br><span class="line">5&#125;</span><br></pre></td></tr></table></figure><h2 id="5-优先捕获最具体的异常"><a href="#5-优先捕获最具体的异常" class="headerlink" title="5. 优先捕获最具体的异常"></a>5. 优先捕获最具体的异常</h2><p>大多数 IDE 都可以帮助你实现这个  佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获</p><p>IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。总是优先捕获  具体的异常类，并将不太具体的 catch 块添加到列表的末尾。你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非</p><p>NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public void catchMostSpecificExceptionFirst() &#123; </span><br><span class="line">2  try &#123;</span><br><span class="line">3  doSomething(&quot;A message&quot;);</span><br><span class="line">4&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5log.error(e);</span><br><span class="line">6&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">7log.error(e)</span><br><span class="line">8&#125;</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure><h2 id="6-不要捕获-Throwable-类"><a href="#6-不要捕获-Throwable-类" class="headerlink" title="6. 不要捕获 Throwable 类"></a>6. 不要捕获 Throwable 类</h2><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你</p><p>永远不应该这样做！</p><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><p>所以， 好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1public void doNotCatchThrowable() &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// do something</span><br><span class="line">4&#125; catch (Throwable t) &#123;</span><br><span class="line">5 // don&#x27;t do this!</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><h2 id="7-不要忽略异常"><a href="#7-不要忽略异常" class="headerlink" title="7. 不要忽略异常"></a>7. 不要忽略异常</h2><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1public void doNotIgnoreExceptions() &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5// this will never happen</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。合理的做法是至少要记录异常的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1public void logAnException() &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5log.error(&quot;This should never happen: &quot; + e);</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><h2 id="8-不要记录并抛出异常"><a href="#8-不要记录并抛出异常" class="headerlink" title="8. 不要记录并抛出异常"></a>8. 不要记录并抛出异常</h2><p>这可能是本文中 常被忽略的  佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1try &#123;</span><br><span class="line">2new Long(&quot;xyz&quot;);</span><br><span class="line">3 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">4log.error(e);</span><br><span class="line">5throw e;</span><br><span class="line">6&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 17:44:28,945 ERROR TestExceptionHandling:65 ‐ java.lang.NumberFormatExcep tion: For input string: &quot;xyz&quot; </span><br><span class="line">2 Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input str ing: &quot;xyz&quot; </span><br><span class="line">3 at java.lang.NumberFormatException.forInputString(NumberFormatException.j ava:65)</span><br><span class="line">4 at java.lang.Long.parseLong(Long.java:589) </span><br><span class="line">5 at java.lang.Long.(Long.java:965) </span><br><span class="line">6 at com.stackify.example.TestExceptionHandling.logAndThrowException(TestEx ceptionHandling.java:63) </span><br><span class="line">7 at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:5</span><br><span class="line">8)</span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">3// do something</span><br><span class="line">4&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h2 id="9-包装异常时不要抛弃原始的异常"><a href="#9-包装异常时不要抛弃原始的异常" class="headerlink" title="9. 包装异常时不要抛弃原始的异常"></a>9. 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。</p><p>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 </p><p>NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的</p><p>构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">2try &#123;</span><br><span class="line">3// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br><span class="line">6&#125;</span><br><span class="line">7&#125;</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="10-不要使用异常控制程序的流程"><a href="#10-不要使用异常控制程序的流程" class="headerlink" title="10. 不要使用异常控制程序的流程"></a>10. 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h2 id="11-使用标准异常"><a href="#11-使用标准异常" class="headerlink" title="11. 使用标准异常"></a>11. 使用标准异常</h2><p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</p><h2 id="12-异常会影响性能"><a href="#12-异常会影响性能" class="headerlink" title="12. 异常会影响性能"></a>12. 异常会影响性能</h2><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p><ul><li>仅在异常情况下使用异常；</li><li>在可恢复的异常情况下使用异常；尽管使用异常有利于 Java 开发，但是在应用中  好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</li></ul><h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p><p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个 佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p><h2 id="异常处理-阿里巴巴Java开发手册"><a href="#异常处理-阿里巴巴Java开发手册" class="headerlink" title="异常处理-阿里巴巴Java开发手册"></a>异常处理-阿里巴巴Java开发手册</h2><ol><li>【强制】Java 类库中定义的可以通过预检查方式规避的</li></ol><p>RuntimeException异常不应该通过catch 的方式来处理，比如：</p><p>NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj !&#x3D; null) {…} 反例：try { obj.method(); } catch </p><p>(NullPointerException e) {…}</p><ol start="2"><li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p></li><li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，</p></li></ol><p>再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p><ol start="4"><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。 外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p></li><li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p></li><li><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1private int x = 0;</span><br><span class="line">2public int checkReturn() &#123;</span><br><span class="line">3try &#123;</span><br><span class="line">4// x等于1，此处不返回</span><br><span class="line">5return ++x;</span><br><span class="line">6&#125; finally &#123;</span><br><span class="line">7// 返回的结果是2</span><br><span class="line">8return ++x;</span><br><span class="line">9&#125;</span><br><span class="line">10&#125;</span><br></pre></td></tr></table></figure><ol><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出</p></li></ol><p>NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：</p><p>ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p><ol start="3"><li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用</p></li></ol><p>obj.getA().getB().getC()；一连串调用，易产生NPE。</p><p>正例：使用JDK8的Optional类来防止NPE问题。</p><ol start="5"><li>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new</li></ol><p>RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：</p><p>DAOException &#x2F; ServiceException等。</p><ol start="6"><li><p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {…}</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/12/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p><strong>集合框架：</strong>用于存储数据的容器。 </p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。 任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算 法。 </p><p><strong>接口：</strong>表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现， 从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。 </p><p><strong>实现：</strong>集合接口的具体实现，是重用性很高的数据结构。<br><strong>算法：</strong>在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方 法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个 接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。 它减少了程序设计的辛劳。 </p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部 分上，而不是为了让程序能正常运转而将注意力于底层设计上。 </p><p>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以 便联合这些API而去写大量的代码。 它提高了程序速度和质量。 </p><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p>集合的特点主要有如下两点： </p><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。 </li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因 为集合是可变长度的。</li></ul><span id="more"></span><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是固定长度的；集合可变长度的。 </li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存 储引用数据类型。 </li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同 数据类型。</li></ul><p><strong>数据结构：</strong>就是容器中存储数据的方式。 </p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个 容器的内部数据结构不同。 </p><p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参 阅顶层内容。建立底层对象。</strong> </p><h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ol><li>容量自增长； </li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质 量； 3</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。 </li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h2 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h2><p>Map接口和Collection接口是所有集合框架的父接口： </p><ol><li>Collection接口的子接口包括：Set接口和List接口 </li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、 ConcurrentHashMap以及Properties等 </li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h2 id="List，Set，Map三者的区别？List、Set、Map-是否继-承自-Collection-接口？List、Map、Set-三个接口存取-元素时，各有什么特点？"><a href="#List，Set，Map三者的区别？List、Set、Map-是否继-承自-Collection-接口？List、Map、Set-三个接口存取-元素时，各有什么特点？" class="headerlink" title="List，Set，Map三者的区别？List、Set、Map 是否继 承自 Collection 接口？List、Map、Set 三个接口存取 元素时，各有什么特点？"></a>List，Set，Map三者的区别？List、Set、Map 是否继 承自 Collection 接口？List、Map、Set 三个接口存取 元素时，各有什么特点？</h2><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Collection.png" alt="Collection"></p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Map.png" alt="Map"></p><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、 List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是 collection的子接口。 </p><p>Collection集合主要有List和Set两大接口 </p><ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重 复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList  和 Vector。 </li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素， 只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、 LinkedHashSet 以及 TreeSet。</li></ul><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不 要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元 素时，只要给出键对象，就会返回对应的值对象。 </p><p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、 ConcurrentHashMap</p><h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><p>Collection </p><p>**List **</p><ul><li>Arraylist： Object数组 </li><li>Vector： Object数组 </li><li>LinkedList： 双向循环链表</li></ul><p>**Set **</p><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过  LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基 于 Hashmap 实现一样，不过还是有一点点区别的。 </li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。) Map </li><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主 体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后<br>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转 化为红黑树，以减少搜索时间 </li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是 基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面 结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。 同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 </li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为 了解决哈希冲突而存在的 </li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已 经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优 先考虑的。 </li><li>statck：堆栈类，先进后出。 </li><li>hashtable：就比hashmap多了个线程安全。 </li><li>enumeration：枚举，相当于迭代器。</li></ul><h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作 时，有可能会产生 fail-fast 机制。 </p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中 的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简 单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制。 </p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个  modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出 异常，终止遍历。 </p><p>解决办法： </p><ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上 synchronized。 </li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个 只读集合，这样改变集合的任何操作都会抛出 Java. lang.  UnsupportedOperationException 异常。 示例代码如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">list. add(&quot;x&quot;); </span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list); </span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错 </span><br><span class="line">System. out. println(list. size()); </span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><p>Iterator 使用代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1List&lt;String&gt; list = new ArrayList</span><br><span class="line">2Iterator&lt;String&gt; it = list. iterator</span><br><span class="line">3while(it. hasNext())&#123;</span><br><span class="line">4String obj = it. next();</span><br><span class="line">5System. out. println(obj);</span><br><span class="line">6&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历</p><p>的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">2while(it.hasNext())&#123;</span><br><span class="line">3*// do something*</span><br><span class="line">4it.remove();5&#125;</span><br></pre></td></tr></table></figure><p>一种  常见的错误代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1for(Integer i : list)&#123;</span><br><span class="line">2list.remove(i)</span><br><span class="line">3&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元 素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h3 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什-么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什-么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什 么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什 么？Java 中 List 遍历的最佳实践是什么？</h3><h3 id="遍历方式有以下几种："><a href="#遍历方式有以下几种：" class="headerlink" title="遍历方式有以下几种："></a>遍历方式有以下几种：</h3><ol><li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读 取每一个位置的元素，当读取到后一个元素后停止。 </p></li><li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏 蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支 持了 Iterator 模式。 </p></li><li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使 用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺 点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替 换。</p></li></ol><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标 记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读 取元素的平均时间复杂度为 O(1)，如ArrayList。 </li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。 推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议 用 Iterator 或 foreach 遍历。</li></ul><h3 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h3><p>ArrayList的优点如下：</p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul><p>ArrayList 的缺点如下：</p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。         </li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul><p>ArrayList 比较适合顺序添加、随机访问的场景。</p><h3 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换。</p><p>List 转数组：使用 List 自带的 toArray() 方法。代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1// list to array</span><br><span class="line">2List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">3list.add(&quot;123&quot;);</span><br><span class="line">4list.add(&quot;456&quot;);</span><br><span class="line">5list.toArray();</span><br><span class="line">6</span><br><span class="line">7// array to list</span><br><span class="line">8String[] array = new String[]&#123;&quot;123&quot;,&quot;456&quot;&#125;;</span><br><span class="line">9Arrays.asList(array);</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。 </li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p>补充：数据结构基础之双向链表</p><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><p>​          线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 </p><p>ArrayList 是非线程安全的。</p><p>性能：ArrayList 在性能方面要优于 Vector。</p><p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 </p><p>Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对</p><p>象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h3><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组</p><p>元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector是线程安全容器，但性能上较ArrayList差。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList插入速度较快。</p><h3 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h3><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 </p><p>synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">2synchronizedList.add(&quot;aaa&quot;);</span><br><span class="line">3synchronizedList.add(&quot;bbb&quot;);</span><br><span class="line">4</span><br><span class="line">5for (int i = 0; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">6System.out.println(synchronizedList.get(i));</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？-ArrayList-中的数组定义如下："><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？-ArrayList-中的数组定义如下：" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？ ArrayList 中的数组定义如下："></a>为什么 ArrayList 的 elementData 加上 transient 修饰？ ArrayList 中的数组定义如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 private transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>再看一下 ArrayList 的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">2implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列</p><p>化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOE xception&#123; </span><br><span class="line">2  *// Write out element count, and any hidden stuff* </span><br><span class="line">3  int expectedModCount = modCount; </span><br><span class="line">4  s.defaultWriteObject(); </span><br><span class="line">5  *// Write out array length* </span><br><span class="line">6  s.writeInt(elementData.length); </span><br><span class="line">7  *// Write out all elements in the proper order.* </span><br><span class="line">8  for (int i=0; i&lt;size; i++) </span><br><span class="line">9  s.writeObject(elementData[i]); </span><br><span class="line">10  if (modCount != expectedModCount) &#123; </span><br><span class="line">11  throw new ConcurrentModificationException();</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><p>List , Set 都是继承自Collection 接口</p><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、</p><p>LinkedList 和 Vector。</p><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 </p><p>HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p>Set和List对比</p><p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</p><p>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，</p><p>HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，</p><p>HashSet 不允许重复的值。</p><h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为 HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的</p><p>V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较 hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1private static final Object PRESENT = new Object();</span><br><span class="line">2private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">3</span><br><span class="line">4public HashSet() &#123;</span><br><span class="line">&lt;&gt;</span><br><span class="line">5map = new HashMap ();</span><br><span class="line">6&#125;</span><br><span class="line">7</span><br><span class="line">8public boolean add(E e) &#123;</span><br><span class="line">9// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="line">10return map.put(e, PRESENT)==null;</span><br><span class="line">11&#125;</span><br></pre></td></tr></table></figure><p>hashCode（）与equals（）的相关规定：</p><ol><li><p>如果两个对象相等，则hashcode一定也是相同的</p></li><li><p>两个对象相等,对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p></li><li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p></li></ol><p>&#x3D;&#x3D;与equals的区别</p><ol><li><p>&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</p></li><li><p>&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较3.&#x3D;&#x3D; 指引用是否相同 equals()指的是值是否相同</p></li></ol><h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现了Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用  put（）向  map中添加元素</td><td>调用  add（）  方法向Set  中添加元素</td></tr><tr><td>HashMap  使用键  （Key）计算  Hashcode</td><td>HashSet 使用成员对象来计  算  hashcode 值，对于两个对象  来说  hashcode 可能相  同，所以  equals()方法用来判断对象的相等性，如果两个对象不同的话，那  么返回  false</td></tr><tr><td>HashMap 相对于  HashSet 较快，因为它是使用唯一的键获取对象</td><td>HashSet 较  HashMap  来说比较慢</td></tr></tbody></table><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h4 id="BlockingQueue是什么？"><a href="#BlockingQueue是什么？" class="headerlink" title="BlockingQueue是什么？"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中 BlockingQueue的实现，比如ArrayBlockingQueue、</p><p>LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。在 Queue 中 poll()和 remove()有什么区别？</p><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">2queue. offer(&quot;string&quot;); // add</span><br><span class="line">3System. out. println(queue. poll());</span><br><span class="line">4System. out. println(queue. remove());</span><br><span class="line">5System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h3 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构： 在Java编程语言中， 基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>HashMap 基于 Hash 算法实现的</p><ol><li><p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相</p></li></ol><p>同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value 放入链表中</p><ol start="3"><li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p></li><li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p></li></ol><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个</p><p>之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p><h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</p><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109162525820.png" alt="jdk1.7中HashMap数据结构"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image001.jpg" alt="jdk1.8中HashMap数据结构"></p><h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p><ol><li><p>resize 扩容优化</p></li><li><p>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</p></li><li><p>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</p></li></ol><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：  inflateTab  le()</td><td>直接集成到了扩容  函数  resize()中</td></tr><tr><td>hash值计算方式</td><td>扰动处理   &#x3D; 9次扰动   &#x3D; 4次位运算 + 5次异或运算</td><td>扰动处理   &#x3D; 2次扰动   &#x3D; 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据 的规则</td><td>无冲突 时，存放 数组；冲 突时，存 放链表</td><td>无冲突时，存放 数组；冲 突 &amp; 链表 长度 &lt; 8：存放单 链表；冲 突 &amp; 链表 长度 &gt; 8：树化并 存放红黑 树</td></tr><tr><td>插入数据 方式</td><td>头插法 （先讲原 位置的数 据移到后1 位，再插 入数据到 该位置）</td><td>尾插法 （直接插 入到链表 尾部&#x2F;红黑 树）</td></tr><tr><td>扩容后存 储位置的 计算方式</td><td>全部按照 原来方法 进行计算 （即 hashCode -&gt;&gt; 扰动 函数 -&gt;&gt; (h&amp;lengt h-1)）</td><td>按照扩容 后的规律 计算（即 扩容后的 位置&#x3D;原位 置 or 原位 置 + 旧容 量）</td></tr></tbody></table><h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高</p><p>16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是</p><p>2的幂，计算下标index &#x3D; (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且</p><p>JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109162901394.png" alt="image-20201109162901394"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">1 public V put(K key, V value) &#123;</span><br><span class="line">2 return putVal(hash(key), key, value, false, true);</span><br><span class="line">3 &#125;</span><br><span class="line">4</span><br><span class="line">5 static final int hash(Object key) &#123;</span><br><span class="line">6 int h;</span><br><span class="line">7 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 //实现Map.put和相关方法</span><br><span class="line">11 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">12 boolean evict) &#123;</span><br><span class="line">13 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">14 // 步骤①：tab为空则创建</span><br><span class="line">15 // table未初始化或者长度为0，进行扩容</span><br><span class="line">16 if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">17 n = (tab = resize()).length;</span><br><span class="line">18 // 步骤②：计算index，并对null做处理</span><br><span class="line">19 // (n ‐ 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这</span><br><span class="line">个结点是放在数组中)</span><br><span class="line">20 if ((p = tab[i = (n ‐ 1) &amp; hash]) == null)</span><br><span class="line">21 tab[i] = newNode(hash, key, value, null);</span><br><span class="line">22 // 桶中已经存在元素</span><br><span class="line">23 else &#123;</span><br><span class="line">24 Node&lt;K,V&gt; e; K k;</span><br><span class="line">25 // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">26 // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">27 if (p.hash == hash &amp;&amp;</span><br><span class="line">28 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">29 // 将第一个元素赋值给e，用e来记录</span><br><span class="line">30 e = p;</span><br><span class="line">31 // 步骤④：判断该链为红黑树</span><br><span class="line">32 // hash值不相等，即key不相等；为红黑树结点</span><br><span class="line">33 // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可</span><br><span class="line">能为null</span><br><span class="line">34 else if (p instanceof TreeNode)</span><br><span class="line">35 // 放入树中</span><br><span class="line">36 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">37 // 步骤⑤：该链为链表</span><br><span class="line">38 // 为链表结点</span><br><span class="line">39 else &#123;</span><br><span class="line">40 // 在链表最末插入结点</span><br><span class="line">41 for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">42 // 到达链表的尾部</span><br><span class="line">43</span><br><span class="line">44 //判断该链表尾部指针是不是空的</span><br><span class="line">45 if ((e = p.next) == null) &#123;</span><br><span class="line">46 // 在尾部插入新结点</span><br><span class="line">47 p.next = newNode(hash, key, value, null);</span><br><span class="line">48 //判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br><span class="line">49 if (binCount &gt;= TREEIFY_THRESHOLD ‐ 1) // ‐1 for 1st</span><br><span class="line">50 //链表结构转树形结构</span><br><span class="line">51 treeifyBin(tab, hash);</span><br><span class="line">52 // 跳出循环</span><br><span class="line">53 break;</span><br><span class="line">54 &#125;</span><br><span class="line">55 // 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">56 if (e.hash == hash &amp;&amp;</span><br><span class="line">57 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">58 // 相等，跳出循环</span><br><span class="line">59 break;</span><br><span class="line">60 // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br><span class="line">61 p = e;</span><br><span class="line">62 &#125;</span><br><span class="line">63 &#125;</span><br><span class="line">64 //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的val</span><br><span class="line">ue这个值</span><br><span class="line">65 if (e != null) &#123;</span><br><span class="line">66 // 记录e的value</span><br><span class="line">67 V oldValue = e.value;</span><br><span class="line">68 // onlyIfAbsent为false或者旧值为null</span><br><span class="line">69 if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">70 //用新值替换旧值</span><br><span class="line">71 e.value = value;</span><br><span class="line">72 // 访问后回调</span><br><span class="line">73 afterNodeAccess(e);</span><br><span class="line">74 // 返回旧值</span><br><span class="line">75 return oldValue;</span><br><span class="line">76 &#125;</span><br><span class="line">77 &#125;</span><br><span class="line">78 // 结构性修改</span><br><span class="line">79 ++modCount;</span><br><span class="line">80 // 步骤⑥：超过最大容量就扩容</span><br><span class="line">81 // 实际大小大于阈值则扩容</span><br><span class="line">82 if (++size &gt; threshold)</span><br><span class="line">83 resize();</span><br><span class="line">84 // 插入后回调</span><br><span class="line">85 afterNodeInsertion(evict);</span><br><span class="line">86 return null;</span><br><span class="line">87 &#125;</span><br></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； </p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向</p><p>④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； </p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了 大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1 final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">2 Node&lt;K,V&gt;[] oldTab = table;//oldTab指向hash桶数组</span><br><span class="line">3 int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">4 int oldThr = threshold;</span><br><span class="line">5 int newCap, newThr = 0;</span><br><span class="line">6 if (oldCap &gt; 0) &#123;//如果oldCap不为空的话，就是hash桶数组不为空</span><br><span class="line">7 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//如果大于最大容量了，就赋值为整数最大的阀</span><br><span class="line">值</span><br><span class="line">8 threshold = Integer.MAX_VALUE;</span><br><span class="line">9 return oldTab;//返回</span><br><span class="line">10 &#125;//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br><span class="line">11 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">12 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">13 newThr = oldThr &lt;&lt; 1; // double threshold 双倍扩容阀值threshold</span><br><span class="line">14 &#125;</span><br><span class="line">15 // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初</span><br><span class="line">始化成最小2的n次幂</span><br><span class="line">16 // 直接将该值赋给新的容量</span><br><span class="line">17 else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">18 newCap = oldThr;</span><br><span class="line">19 // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br><span class="line">20 else &#123; // zero initial threshold signifies using defaults</span><br><span class="line">21 newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">22 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">23 &#125;</span><br><span class="line">24 // 新的threshold = 新的cap * 0.75</span><br><span class="line">25 if (newThr == 0) &#123;</span><br><span class="line">26 float ft = (float)newCap * loadFactor;</span><br><span class="line">27 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">28 (int)ft : Integer.MAX_VALUE);</span><br><span class="line">29 &#125;</span><br><span class="line">30 threshold = newThr;</span><br><span class="line">31 // 计算出新的数组长度后赋给当前成员变量table</span><br><span class="line">32 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">33 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建hash桶数组</span><br><span class="line">34 table = newTab;//将新数组的值复制给旧的hash桶数组</span><br><span class="line">35 // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素</span><br><span class="line">重排逻辑，使其均匀的分散</span><br><span class="line">36 if (oldTab != null) &#123;</span><br><span class="line">37 // 遍历新数组的所有桶下标</span><br><span class="line">38 for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">39 Node&lt;K,V&gt; e;</span><br><span class="line">40 if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">41 // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br><span class="line">42 oldTab[j] = null;</span><br><span class="line">43 // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br><span class="line">44 if (e.next == null)</span><br><span class="line">45 // 用同样的hash映射算法把该元素加入新的数组</span><br><span class="line">46 newTab[e.hash &amp; (newCap ‐ 1)] = e;</span><br><span class="line">47 // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br><span class="line">48 else if (e instanceof TreeNode)</span><br><span class="line">49 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">50 // e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br><span class="line">51 else &#123; // preserve order</span><br><span class="line">52 // loHead,loTail 代表扩容后不用变换下标，见注1</span><br><span class="line">53 Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">54 // hiHead,hiTail 代表扩容后变换下标，见注1</span><br><span class="line">55 Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">56 Node&lt;K,V&gt; next;</span><br><span class="line">57 // 遍历链表</span><br><span class="line">58 do &#123;</span><br><span class="line">59 next = e.next;</span><br><span class="line">60 if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">61 if (loTail == null)</span><br><span class="line">62 // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br><span class="line">63 // 代表下标保持不变的链表的头元素</span><br><span class="line">64 loHead = e;</span><br><span class="line">65 else</span><br><span class="line">66 // loTail.next指向当前e</span><br><span class="line">67 loTail.next = e;</span><br><span class="line">68 // loTail指向当前的元素e</span><br><span class="line">69 // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素</span><br><span class="line">时，</span><br><span class="line">70 // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br><span class="line">71 // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br><span class="line">72 loTail = e;</span><br><span class="line">73 &#125;</span><br><span class="line">74 else &#123;</span><br><span class="line">75 if (hiTail == null)</span><br><span class="line">76 // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br><span class="line">77 hiHead = e;</span><br><span class="line">78 else</span><br><span class="line">79 hiTail.next = e;</span><br><span class="line">80 hiTail = e;</span><br><span class="line">81 &#125;</span><br><span class="line">82 &#125; while ((e = next) != null);</span><br><span class="line">83 // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br><span class="line">84 if (loTail != null) &#123;</span><br><span class="line">85 loTail.next = null;</span><br><span class="line">86 newTab[j] = loHead;</span><br><span class="line">87 &#125;</span><br><span class="line">88 if (hiTail != null) &#123;</span><br><span class="line">89 hiTail.next = null;</span><br><span class="line">90 newTab[j + oldCap] = hiHead;</span><br><span class="line">91 &#125;</span><br><span class="line">92 &#125;</span><br><span class="line">93 &#125;</span><br><span class="line">94 &#125;</span><br><span class="line">95 &#125;</span><br><span class="line">96 return newTab;</span><br><span class="line">97 &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；什么是哈希？</p><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109163448750.png" alt="image-20201109163448750"></p><p>这样我们就可以将拥有相同哈希值的对象(img)组织成一个链表放在hash值所对应的 bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数</p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1static final int hash(Object key) &#123;</span><br><span class="line">2int h;</span><br><span class="line">3return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">4&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><h4 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h4><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109163526813.png" alt="image-20201109163526813"></p><p>通过上面的链地址法（使用散列表）和扰(img)动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；总结</p><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ol><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ol><h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：  如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p><p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p><p>用户自定义 Key 类 佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p><h3 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><p>\1.   都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同的情况</p><p>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</p><h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写hashCode()和equals()方法</p><p>\1.  重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p><p>\2.  重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对</p><p>于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？</h3><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到 大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p>那怎么解决呢？</p><p>\1. HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p><p>\2. 在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算</p><p>（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取</p><p>余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;</p><p>(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题</p><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p><p>这个算法应该如何设计呢？我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操</p><p>作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 </p><p>hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p>那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，  终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p><h3 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h3><ol><li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；</li></ol><p>HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p><ol start="2"><li><p>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在</p></li></ol><p>HashTable 中 put 进的键值只要有一个 null，直接抛</p><p>NullPointerException。</p><ol start="4"><li><p>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2 的幂次方。</p></li><li><p>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li><li><p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p></li></ol><h3 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是 好的选择。然</p><p>而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p><h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol><li><p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized 锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启了一种全新的方式实现,利用CAS算法。）</p></li><li><p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p></li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><p> 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组</p><p>+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑</p><p>二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><p>​           实现线程安全的方式（重要）： ① 在JDK1.7的时候，</p><p>ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16</p><p>倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 </p><p>Node 数组+链表+红黑树的数据结构来实现，并发控制使用 </p><p>synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还</p><p>能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② </p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p>两者的对比图：</p><p>HashTable:</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165808848.png" alt="image-20201109165808848"></p><p>JDK1.7的ConcurrentHashMap：</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165820466.png" alt="image-20201109165820466"></p><p>JDK1.8的ConcurrentHashMap（TreeBi(img)n: 红黑二叉树节点 Node: 链表节点）：</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165840129.png" alt="image-20201109165840129"></p><p>答：ConcurrentHashMap 结合了 Hash(img)Map 和 HashTable 二者的优势。 HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h3 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p>JDK1.7</p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实</p><p>现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165916185.png" alt="image-20201109165916185"></p><ol><li><p>该类包含两个静态内部类 HashE(img)ntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p></li><li><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p></li></ol><p>JDK1.8</p><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N 倍。</p><p>结构如下：</p><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165939912.png" alt="image-20201109165939912"></p><p>看插入元素过程（建议去看看源码）：</p><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1else if ((f = tabAt(tab, i = (n ‐ 1) &amp; hash)) == null) &#123;</span><br><span class="line">2if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">3break; // no lock when adding to empty bin</span><br><span class="line">4&#125;</span><br></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加</p><p>synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 if (fh &gt;= 0) &#123; </span><br><span class="line">2 binCount = 1;</span><br><span class="line">3for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">4K ek;</span><br><span class="line">5if (e.hash == hash &amp;&amp;</span><br><span class="line">6((ek = e.key) == key ||</span><br><span class="line">7(ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">8oldVal = e.val;</span><br><span class="line">9if (!onlyIfAbsent)</span><br><span class="line">10e.val = value;</span><br><span class="line">11break;</span><br><span class="line">12&#125;</span><br><span class="line">13Node&lt;K,V&gt; pred = e;</span><br><span class="line">14if ((e = e.next) == null) &#123;</span><br><span class="line">15pred.next = new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">16break;</span><br><span class="line">17&#125;</span><br><span class="line">18&#125;</span><br><span class="line">19&#125;</span><br></pre></td></tr></table></figure><p>\1.    如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过 putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><p>\2.    如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数 baseCount；</p><h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或 compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了 大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p><p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/12/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/12/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h2><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并 终得到结果的过程。 </p><p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、 和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一 步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编 程。 </p><h2 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h2><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易 用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对 象理论，允许程序员以优雅的思维方式进行复杂的编程 。 </p><h2 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h2><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使 用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java  ME提供基础。 </li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器 端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、 管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented  architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名 为 JakartaEE </li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视 机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用 户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序 的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可 以利用每个设备的本机功能。</li></ul><h2 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h2><p>JVM </p><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此Java语言可以实现跨平台。 </p><p>JRE </p><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p> 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p><p>JDK</p><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等 </p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106172325865.png" alt="image-20201106172325865"></p><span id="more"></span><h2 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。 </p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，该系统就可以运行java程序。</p><h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><p>简单易学（Java语言的语法与C语言和C++语言很接近） </p><p>面向对象（封装，继承，多态） </p><p>平台无关性（Java虚拟机实现平台无关性） </p><p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） </p><p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任） </p><p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） </p><p>安全性</p><h2 id="什么是字节码？采用字节码的大好处是什么"><a href="#什么是字节码？采用字节码的大好处是什么" class="headerlink" title="什么是字节码？采用字节码的大好处是什么"></a>什么是字节码？采用字节码的大好处是什么</h2><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文 件），它不面向任何特定的处理器，只面向虚拟机。 </p><p><strong>采用字节码的好处：</strong> </p><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可 在多种不同的计算机上运行。</p><p><strong>先看下java中的编译器和解释器：</strong> </p><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码‐‐‐‐&gt;编译器‐‐‐‐&gt;jvm可执行的Java字节码(即虚拟指令)‐‐‐‐&gt;jvm‐‐‐‐&gt;jvm中 解释器‐‐‐‐‐&gt;机器可执行的二进制机器码‐‐‐‐&gt;程序运行。</span><br></pre></td></tr></table></figure><h2 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主 类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统 类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序 的主类要求必须是public类。主类是Java程序执行的入口点。</p><h2 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h2><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main 方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏 览器这点跟flash的小游戏类似。</p><h2 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h2><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！ 没办法！！！就算没学过C++，也要记下来！ </p><ul><li>都是面向对象的语言，都支持封装、继承和多态 </li><li>Java不提供指针来直接访问内存，程序内存更加安全 </li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是 接口可以多继承。 </li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h2><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一 次； </li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是 OpenJDK的一个实现，并不是完全开源的； </li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎 相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企 业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳 定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程 序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； </li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的 性能； </li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过 更新到最新版本获得支持来获取最新版本； </li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类 型，在内存中分配了不同大小的内存空间。 </p><p><strong>分类</strong>：</p><p>基本数据类型 </p><ul><li>​数值型<br>​整数类型(byte,short,int,long)<br>​浮点类型(float,double) </li><li>​字符型(char) </li><li>​布尔型(boolean)</li></ul><p>引用数据类型 </p><ul><li>​类(class) </li><li>​接口(interface) </li><li>​数组([])</li></ul><p><strong>Java基本数据类型图</strong></p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201020121024259.png" alt="image-20201020121024259"></p><h3 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否-能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否-能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否 能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否 能作用在 String 上</h3><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从  Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7  开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版 本中都是不可以的</p><h3 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h3><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次 方）。</p><h3 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少</h3><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍 五入的原理是在参数上加 0.5 然后进行下取整。 </p><h3 id="loat-f-x3D-3-4-是否正确"><a href="#loat-f-x3D-3-4-是否正确" class="headerlink" title="loat f&#x3D;3.4;是否正确"></a>loat f&#x3D;3.4;是否正确</h3><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转 换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p><h3 id="short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗"><a href="#short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</h3><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是  int型，需要强制转换类型才能赋值给 short 型。 而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1  + 1);其中有隐含的强制类型转换。 </p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h3><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一 个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h3><h4 id="定义：用于解释说明程序的文字"><a href="#定义：用于解释说明程序的文字" class="headerlink" title="定义：用于解释说明程序的文字"></a>定义：用于解释说明程序的文字</h4><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>单行注释 格式： &#x2F;&#x2F; 注释文字 </li><li>多行注释 格式： &#x2F;* 注释文字 *&#x2F; </li><li>文档注释 格式：&#x2F;** 注释文字 *&#x2F;</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利 于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生 目标代码，注释的部分不会对程序的执行结果产生任何影响。 注意事项：多行和文档注释都不能嵌套使用。 访问修饰符</p><h3 id="访问修饰符-public-private-protected-以及不写（默认）时的-区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的-区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的 区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的 区别</h3><p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访 问。Java 支持 4 种不同的访问权限。 </p><p><strong>分类</strong>：</p><ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部 类） </li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用 任何修饰符。使用对象：类、接口、变量、方法。 </li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意： 不能修饰类（外部类）。 </li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li></ul><p><strong>访问修饰符图</strong></p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201020130327174.png" alt="image-20201020130327174"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。 </p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要 求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称<br>为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直 接短路掉，不会进行运算。 </p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h3><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h3 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h3><p>用于修饰类、属性和方法；</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h3 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h3><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><h3 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h3><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指<br>针。</p><p>this的用法在java中大体可以分为3种：</p><p>1.普通的直接引用，this相当于是指向当前对象本身。</p><p>2.形参与成员名字重名，用this来区分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 public Person(String name, int age) &#123;</span><br><span class="line">2 this.name = name;</span><br><span class="line">3 this.age = age;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p>3.引用本类的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 class Person&#123;</span><br><span class="line">2 private String name;</span><br><span class="line">3 private int age;</span><br><span class="line">4</span><br><span class="line">5 public Person() &#123;</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 public Person(String name) &#123;</span><br><span class="line">9 this.name = name;</span><br><span class="line">10 &#125;</span><br><span class="line">11 public Person(String name, int age) &#123;</span><br><span class="line">12 this(name);</span><br><span class="line">13 this.age = age;</span><br><span class="line">14 &#125;</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure><h3 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h3><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离<br>自己最近的一个父类。</p><p>super也有三种用法：</p><p>1.普通的直接引用<br>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用<br>super.xxx来引用父类的成员。<br>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区<br>分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 class Person&#123;</span><br><span class="line">2 protected String name;</span><br><span class="line">3</span><br><span class="line">4 public Person(String name) &#123;</span><br><span class="line">5 this.name = name;</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 class Student extends Person&#123;</span><br><span class="line">11 private String name;</span><br><span class="line">12</span><br><span class="line">13 public Student(String name, String name1) &#123;</span><br><span class="line">14 super(name);</span><br><span class="line">15 this.name = name1;</span><br><span class="line">16 &#125;</span><br><span class="line">17</span><br><span class="line">18 public void getInfo()&#123;</span><br><span class="line">19 System.out.println(this.name); //Child</span><br><span class="line">20 System.out.println(super.name); //Father</span><br><span class="line">21 &#125;</span><br><span class="line">22</span><br><span class="line">23 &#125;</span><br><span class="line">24</span><br><span class="line">25 public class Test &#123;</span><br><span class="line">26 public static void main(String[] args) &#123;</span><br><span class="line">27 Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);</span><br><span class="line">28 s1.getInfo();</span><br><span class="line">29</span><br><span class="line">30 &#125;</span><br><span class="line">31 &#125;</span><br></pre></td></tr></table></figure><p>3.引用父类构造函数</p><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p><p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><ul><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：<br>static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</p><p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候<br>执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><h3 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h3><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</p><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h3 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h3><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p><p>因此比较常见的static应用场景有：</p><blockquote><p>1、修饰成员变量<br>2、修饰成员方法<br>3、静态代码块<br>4、修饰类【只能修饰内部类也就是静态内部类】<br>5、静态导包</p></blockquote><h3 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h3><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h3 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 ok:</span><br><span class="line">3 for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">4 for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">5 System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">6 if (j == 5) &#123;</span><br><span class="line">7 break ok;</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p><h4 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h4><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低<br>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步<br>一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p>**面向对象的特征主要有以下几个方面： **</p><p><strong>抽象：</strong>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行 为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是 什么。 </p><ul><li><p>封装 : 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如 果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没 有提供给外界访问的方法，那么这个类也没有什么意义了。 </p></li><li><p>继承 : 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新 的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用 继承我们能够非常方便地复用以前的代码。</p><p>​关于继承如下 3 点请记住：</p><p>​1.子类拥有父类非 private 的属性和方法。</p><p>​2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 </p><p>​3.子类可以用自己的方式实现父类的方法。 </p></li><li><p>多态 : 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出 的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到 底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的 方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。</p></li></ul><p>其中Java 面向对象编程三大特性：封装 继承 多态</p><p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便 于使用，提高复用性和安全性。 </p><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以 增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通 过使用继承可以提高代码复用性。继承是多态的前提。 </p><p>**关于继承如下 3 点请记住： **</p><ol><li>子类拥有父类非 private 的属性和方法。 </li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 </li><li>子类可以用自己的方式实现父类的方法。</li></ol><p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提 高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重 写（override）实现的是运行时的多态性（也称为后绑定）。 </p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是 哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对 象精髓的东西，要实现多态需要做两件事： </p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据 子类对象的不同而表现出不同的行为）。</li></ul><h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出 的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒 底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的 方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这 样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而 导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时 所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的 重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不 同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来 实现的，也就是我们所说的多态性</p><p><strong>多态的实现</strong> </p><p>Java实现多态有三个必要条件：继承、重写、向上转型。 </p><p>继承：在多态中必须存在有继承关系的子类和父类。 </p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的 方法。 </p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具 备技能调用父类的方法和子类的方法。 </p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现 代码处理不同的对象，从而达到执行不同的行为。 </p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类 对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但 是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 </p><h2 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h2><ul><li>单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。<br>开放封闭原则OCP(Open－Close Principle)</li><li>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，<br>一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有<br>打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的<br>多。</li></ul><h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><h2 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h2><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><p><strong>相同点</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点</strong></p><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间 的差异。 </p><p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。 接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则： </p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量 少用抽象类。 </li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用 的功能。</li></ul><h3 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h3><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。 </li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承， 这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h3 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h3><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实 例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根 绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以 用n条绳子系住一个气球）</p><h1 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h1><h2 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h2><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上 讲，变量其实是内存中的一小块区域 成员变量：方法外部，类内部定义的变量 局部变量：类的方法中的变量。 成员变量和局部变量的区别</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>成员变量：针对整个类有效。 </p><p>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。 </p><p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>成员变量：随着对象的创建而存在，随着对象的消失而消失 </p><p>局部变量：当方法调用完，或者语句结束后，就自动释放。</p><h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>成员变量：有默认初始值。 </p><p>局部变量：没有默认初始值，使用前必须赋值。 </p><p>使用原则 </p><p>在使用变量时需要遵循的原则为：就近原则 首先在局部范围找，有就使用；接着在成员位置找。</p><h2 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构 造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了 有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定 的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构 造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其-目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其-目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其 目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其 目的是？</h2><p>帮助子类做初始化工作。</p><h2 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，-改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，-改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法， 改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法， 改程序能正确执行吗？为什么？</h2><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构 造方法也会有默认的不带参数的构造方法。</p><h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><p>名字与类名相同； </p><p>没有返回值，但不能用void声明构造函数； </p><p>生成类的对象时自动执行，无需调用。</p><h2 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h2><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会 有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。 </p><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量 是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p><h2 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h2><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有 的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始 化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副 本，各个对象拥有的副本互不影响。</p><p> 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><p>静态方法和实例方法的区别主要体现在两个方面： </p><ol><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使 用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调 用静态方法可以无需创建对象。 </p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量 和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此 限制</p></li></ol><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静 态变量，也不可以访问非静态变量成员。</p><h2 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提 是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的 操作！</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h2><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内 部类本身就是类的一个属性，与其他属性定义方式一致。 </p><h2 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h2><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类。</strong> </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private static int radius = 1;</span><br><span class="line">4</span><br><span class="line">5 static class StaticInner &#123;</span><br><span class="line">6 public void visit() &#123;</span><br><span class="line">7 System.out.println(&quot;visit outer static variable:&quot; + radius);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量； 静态内部类的创建方式，new 外部类.静态内部类()，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">2 inner.visit</span><br></pre></td></tr></table></figure><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private static int radius = 1;</span><br><span class="line">4 private int count =2;</span><br><span class="line">5</span><br><span class="line">6 class Inner &#123;</span><br><span class="line">7 public void visit() &#123;</span><br><span class="line">8 System.out.println(&quot;visit outer static variable:&quot; + radius);</span><br><span class="line">9 System.out.println(&quot;visit outer variable:&quot; + count);</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公 有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如 下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Outer outer = new Outer();</span><br><span class="line">2 Outer.Inner inner = outer.new Inner();</span><br><span class="line">3 inner.visit();</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private int out_a = 1;</span><br><span class="line">4 private static int STATIC_b = 2;</span><br><span class="line">5</span><br><span class="line">6 public void testFunctionClass()&#123;</span><br><span class="line">7 int inner_c =3;</span><br><span class="line">8 class Inner &#123;</span><br><span class="line">9 private void fun()&#123;</span><br><span class="line">10 System.out.println(out_a);</span><br><span class="line">11 System.out.println(STATIC_b);</span><br><span class="line">12 System.out.println(inner_c);</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15 Inner inner = new Inner();</span><br><span class="line">16 inner.fun();</span><br><span class="line">17 &#125;</span><br><span class="line">18 public static void testStaticFunctionClass()&#123;</span><br><span class="line">19 int d =3;</span><br><span class="line">20 class Inner &#123;</span><br><span class="line">21 private void fun()&#123;</span><br><span class="line">22 // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外</span><br><span class="line">部类的实例变量</span><br><span class="line">23 System.out.println(STATIC_b);</span><br><span class="line">24 System.out.println(d);</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br><span class="line">27 Inner inner = new Inner();</span><br><span class="line">28 inner.fun();</span><br><span class="line">29 &#125;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法 中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应 方法内，new 内部类()，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 public static void testStaticFunctionClass()&#123;</span><br><span class="line">2 class Inner &#123;</span><br><span class="line">3 &#125;</span><br><span class="line">4 Inner inner = new Inner();</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private void test(final int i) &#123;</span><br><span class="line">4 new Service() &#123;</span><br><span class="line">5 public void method() &#123;</span><br><span class="line">6 for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">7 System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10 &#125;.method();</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br><span class="line">13 //匿名内部类必须继承或实现一个已有的接口</span><br><span class="line">14 interface Service&#123;</span><br><span class="line">15 void method();</span><br><span class="line">16 &#125;</span><br></pre></td></tr></table></figure><p>除了没有名字，匿名内部类还有以下特点： </p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。 </li><li>匿名内部类不能定义任何静态成员和静态方法。 </li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 </li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方 法。</li></ul><h4 id="匿名内部类创建方式："><a href="#匿名内部类创建方式：" class="headerlink" title="匿名内部类创建方式："></a>匿名内部类创建方式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 new 类/接口&#123;</span><br><span class="line">2 //匿名内部类实现部分</span><br><span class="line">3 &#125;</span><br></pre></td></tr></table></figure><h2 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h2><p>我们为什么要使用内部类呢？因为它有以下优点： </p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ </li><li>内部类不为同一包的其他类所见，具有很好的封装性； </li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。 </li><li>匿名内部类可以很方便的定义回调。</li></ul><h2 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h2><ol><li><p>一些多算法场合 </p></li><li><p>解决一些非面向对象的语句块。 </p></li><li><p>适当使用内部类，使得代码更加灵活和富有扩展性。 </p></li><li><p>当某个类除了它的外部类，不再被其他的类使用时。</p></li></ol><h2 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须-要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须-要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须 要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须 要加上final？</h2><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？ 它内部原理是什么呢？ </p><p>先看这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 void outMethod()&#123;</span><br><span class="line">4 final int a =10;</span><br><span class="line">5 class Inner &#123;</span><br><span class="line">6 void innerMethod()&#123;</span><br><span class="line">7 System.out.println(a);</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在 栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变 量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final， 可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。 </p><h2 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2 private int age = 12;</span><br><span class="line">3</span><br><span class="line">4 class Inner &#123;</span><br><span class="line">5 private int age = 13;</span><br><span class="line">6 public void print() &#123;</span><br><span class="line">7 int age = 14;</span><br><span class="line">8 System.out.println(&quot;局部变量：&quot; + age);</span><br><span class="line">9 System.out.println(&quot;内部类变量：&quot; + this.age);</span><br><span class="line">10 System.out.println(&quot;外部类变量：&quot; + Outer.this.age);</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br><span class="line">13</span><br><span class="line">14 public static void main(String[] args) &#123;</span><br><span class="line">15 Outer.Inner in = new Outer().new Inner();</span><br><span class="line">16 in.print();</span><br><span class="line">17 &#125;</span><br><span class="line">18</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 局部变量：14</span><br><span class="line">2 内部类变量：13</span><br><span class="line">3 外部类变量：12</span><br></pre></td></tr></table></figure><h1 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h1><h2 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h2><p>构造器不能被继承，因此不能被重写，但可以被重载。 </p><h2 id="重载（Overload）和重写（Override）的区别。重载的方法能-否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能-否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能 否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能 否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态 性，而后者实现的是运行时的多态性。 </p><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不 同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回 类型进行区分 </p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛 出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类 方法访问修饰符为private则子类中就不是重写。</p><h1 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h1><h2 id="x3D-x3D-和-equals-的区别是什么"><a href="#x3D-x3D-和-equals-的区别是什么" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h2><p>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同 一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址) </p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时， 等价于通过“&#x3D;&#x3D;”比较这两个对象。 </p><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象 的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 </p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 public class test1 &#123;</span><br><span class="line">2 public static void main(String[] args) &#123;</span><br><span class="line">3 String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">4 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">5 String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">6 String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">7 if (aa == bb) // true</span><br><span class="line">8 System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">9 if (a == b) // false，非同一对象</span><br><span class="line">10 System.out.println(&quot;a==b&quot;);</span><br><span class="line">11 if (a.equals(b)) // true</span><br><span class="line">12 System.out.println(&quot;aEQb&quot;);</span><br><span class="line">13 if (42 == 42.0) &#123; // true</span><br><span class="line">14 System.out.println(&quot;true&quot;);</span><br><span class="line">15 &#125;</span><br><span class="line">16 &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure><p>说明： </p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的 内存地址，而String的equals方法比较的是对象的值。 </li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要 创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建 一个String对象。</li></ul><h2 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h2><p>HashSet如何检查重复 </p><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？ </p><p>hashCode和equals方法的关系 </p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时 必须重写hashCode方法？”</p><h3 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整 数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。 </p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出 对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><h3 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对 象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果 没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相 同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对 象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不 同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》 第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速 度。</p><h3 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h3><p>如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的</p><h3 id="因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h3><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 </p><p>hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指 向相同的数据）</p><h2 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h2><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的 内存地址是否相等。</p><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><h2 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对-象的属性，并可返回变化后的结果，那么这里到底是值传递还是-引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对-象的属性，并可返回变化后的结果，那么这里到底是值传递还是-引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对 象的属性，并可返回变化后的结果，那么这里到底是值传递还是 引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对 象的属性，并可返回变化后的结果，那么这里到底是值传递还是 引用传递</h2><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一 个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被 调用过程中被改变，但对对象引用的改变是不会影响到调用者的 </p><h2 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术 语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用 （call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以 修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用 来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p> <strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的 一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong> </p><p>下面通过 3 个例子来给大家说明</p><p>example 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 int num1 = 10;</span><br><span class="line">3 int num2 = 20;</span><br><span class="line">4</span><br><span class="line">5 swap(num1, num2);</span><br><span class="line">6</span><br><span class="line">7 System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">8 System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br><span class="line">11 public static void swap(int a, int b) &#123;</span><br><span class="line">12 int temp = a;</span><br><span class="line">13 a = b;</span><br><span class="line">14 b = temp;</span><br><span class="line">15</span><br><span class="line">16 System.out.println(&quot;a = &quot; + a);</span><br><span class="line">17 System.out.println(&quot;b = &quot; + b);</span><br><span class="line">18 &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 a = 20</span><br><span class="line">2 b = 10</span><br><span class="line">3 num1 = 10</span><br><span class="line">4 num2 = 20</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190311218.png" alt="image-20201106190311218"></p><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、 b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 </p><p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而 对象引用作为参数就不一样，请看 example2.</p><p>example 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">3 System.out.println(arr[0]);</span><br><span class="line">4 change(arr);</span><br><span class="line">5 System.out.println(arr[0]);</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 public static void change(int[] array) &#123;</span><br><span class="line">9 // 将数组的第一个元素变为0</span><br><span class="line">10 array[0] = 0;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 0</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190416793.png" alt="image-20201106190416793"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向 的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象 上。 </p><p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件 难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时 引用同一个对象。</p><p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调 用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象 采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍 性，所以下面给出一个反例来详细地阐述一下这个问题。</p><p>example 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Test &#123;</span><br><span class="line">2</span><br><span class="line">3 public static void main(String[] args) &#123;</span><br><span class="line">4 // TODO Auto‐generated method stub</span><br><span class="line">5 Student s1 = new Student(&quot;小张&quot;);</span><br><span class="line">6 Student s2 = new Student(&quot;小李&quot;);</span><br><span class="line">7 Test.swap(s1, s2);</span><br><span class="line">8 System.out.println(&quot;s1:&quot; + s1.getName());</span><br><span class="line">9 System.out.println(&quot;s2:&quot; + s2.getName());</span><br><span class="line">10 &#125;</span><br><span class="line">11</span><br><span class="line">12 public static void swap(Student x, Student y) &#123;</span><br><span class="line">13 Student temp = x;</span><br><span class="line">14 x = y;</span><br><span class="line">15 y = temp;</span><br><span class="line">16 System.out.println(&quot;x:&quot; + x.getName());</span><br><span class="line">17 System.out.println(&quot;y:&quot; + y.getName());</span><br><span class="line">18 &#125;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 x:小李</span><br><span class="line">2 y:小张</span><br><span class="line">3 s1:小张</span><br><span class="line">4 s2:小李</span><br></pre></td></tr></table></figure><p>解析： </p><p>交换之前：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190608690.png" alt="image-20201106190608690"></p><p>交换之后：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190619059.png" alt="image-20201106190619059"></p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的 对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交 换的是这两个拷贝</p><p>总结</p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 </p><p>下面再总结一下Java中方法参数的使用情况： </p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》 </li><li>一个方法可以改变一个对象参数的状态。 </li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h2 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h2><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷 贝，也就是说传递后就互不相关了。 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引 用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说 传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h1 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h1><h2 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h2><ul><li>java.lang：这个是系统的基础类； </li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等； </li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包； </li><li>java.net：这里面是与网络有关的类； </li><li>java.util：这个是系统辅助类，特别是集合类； </li><li>java.sql：这个是数据库操作的类。</li></ul><h2 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部 分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现 有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h2><p>按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼 此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类 中派生出来的。</p><ul><li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符 输入流。 </li><li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输 出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109141513794.png" alt="image-20201109141513794"></p><p>IO­操作方式分类按操作对象分类结构图：</p><p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109142101756.png" alt="image-20201109142101756"></p><h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h2><p>简答</p><ul><li><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p></li><li><p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过<br>  Channel（通道）通讯，实现了多路复用。</p></li><li><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO<br>  ，异步 IO 的操作基于事件和回调机制。</p></li></ul><p>详细回答</p><ul><li><p>BIO (Blocking I&#x2F;O): 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p></li><li><p>NIO (New I&#x2F;O): NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的 N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p></li><li><p>AIO (Asynchronous I&#x2F;O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p></li></ul><h2 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h2><ul><li>Files. exists()：检测文件路径是否存在。 </li><li>Files. createFile()：创建文件。 </li><li>Files. createDirectory()：创建文件夹。 </li><li>Files. delete()：删除一个文件或目录。 </li><li>Files. copy()：复制文件。 </li><li>Files. move()：移动文件。 </li><li>Files. size()：查看文件个数。 </li><li>Files. read()：读取文件。 </li><li>Files. write()：写入文件。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>静态编译和动态编译</p><p><strong>静态编译：</strong>在编译时确定类型，绑定对象</p><p><strong>动态编译：</strong>运行时确定类型，绑定对象</p><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p><p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能</p><p>比直接的java代码要慢很多。</p><h2 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h2><p>反射是框架设计的灵魂。</p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制， 经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><h2 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h2><p>1.通过new对象实现反射机制 </p><p>2.通过路径实现反射机制 </p><p>3.通过类名实现反射机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1  public class Student &#123;</span><br><span class="line">2  private int id;</span><br><span class="line">3  String name;</span><br><span class="line">4  protected boolean sex;</span><br><span class="line">5  public float score;</span><br><span class="line">6  &#125;</span><br><span class="line">1   public class Get &#123;</span><br><span class="line">2   //获取反射机制三种方式</span><br><span class="line">3   public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">4   //方式一(通过建立对象)</span><br><span class="line">5   Student stu = new Student();</span><br><span class="line">6   Class classobj1 = stu.getClass();</span><br><span class="line">7   System.out.println(classobj1.getName());</span><br><span class="line">8   //方式二（所在通过路径‐相对路径）</span><br><span class="line">9   Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">10  System.out.println(classobj2.getName());</span><br><span class="line">11  //方式三（通过类名）</span><br><span class="line">12  Class classobj3 = Student.class;</span><br><span class="line">13  System.out.println(classobj3.getName());</span><br><span class="line">14  &#125;</span><br><span class="line">15  &#125;</span><br></pre></td></tr></table></figure><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程的面试题可以查看我的这篇文章重学TCP&#x2F;IP协议和三次握手四次挥手，内容不仅包括TCP&#x2F;IP协议和三次握手四次挥手的知识，还包括计算机网络</p><p>体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等，欢迎大家阅读。</p><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><ol><li><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</p></li><li><p>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p></li></ol><h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><h3 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h3><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、 double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 </p><p>char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h3><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h3 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h3><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  /** The value is used for character storage. */</span><br><span class="line"></span><br><span class="line">2  private final char value[];</span><br></pre></td></tr></table></figure><h3 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h3><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p><ol><li>String不可变但不代表引用不可以变</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  String str = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">2  str = str + &quot; World&quot;;</span><br><span class="line"></span><br><span class="line">3  System.out.println(&quot;str=&quot; + str);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 str=Hello World</span><br></pre></td></tr></table></figure><p>解析：</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><ol start="2"><li>通过反射是可以修改所谓的“不可变”对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1  // 创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br><span class="line"></span><br><span class="line">2  String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4 System.out.println(&quot;s = &quot; + s); // Hello World</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">6  // 获取String类中的value字段</span><br><span class="line"></span><br><span class="line">7  Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">9  // 改变value属性的访问权限</span><br><span class="line"></span><br><span class="line">10  valueFieldOfString.setAccessible(true);</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">12  // 获取s对象上的value属性的值</span><br><span class="line"></span><br><span class="line">13  char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">15  // 改变value所引用的数组中的第5个字符</span><br><span class="line"></span><br><span class="line">16  value[5] = &#x27;_&#x27;;</span><br><span class="line"></span><br><span class="line">17</span><br><span class="line"></span><br><span class="line">18 System.out.println(&quot;s = &quot; + s); // Hello_World</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  s = Hello World</span><br><span class="line"></span><br><span class="line">2  s = Hello_World</span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h3 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h3><p>String 类是 final 类，不可以被继承。</p><p>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。 String s &#x3D; new String(“xyz”);创建了几个字符串对象两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1String str1 = &quot;hello&quot;; //str1指向静态区</span><br><span class="line">2String str2 = new String(&quot;hello&quot;); //str2指向堆上的对象</span><br><span class="line">3String str3 = &quot;hello&quot;;</span><br><span class="line">4String str4 = new String(&quot;hello&quot;);</span><br><span class="line">5System.out.println(str1.equals(str2)); //true</span><br><span class="line">6System.out.println(str2.equals(str4)); //true</span><br><span class="line">7System.out.println(str1 == str3); //true</span><br><span class="line">8System.out.println(str1 == str2); //false</span><br><span class="line">9System.out.println(str2 == str4); //false</span><br><span class="line">10System.out.println(str2 == &quot;hello&quot;); //false</span><br><span class="line">11str2 = str1;</span><br><span class="line">12System.out.println(str2 == &quot;hello&quot;); //true</span><br></pre></td></tr></table></figure><p>如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1// StringBuffer reverse</span><br><span class="line">2StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">3stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">4System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">5// StringBuilder reverse</span><br><span class="line">6StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">7stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">8System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h3 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h3><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。 JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h3><ul><li>indexOf()：返回指定字符的索引。 </li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。 </li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。 </li><li>toLowerCase()：将字符串转成小写字母。 </li><li>toUpperCase()：将字符串转成大写字符。 </li><li>substring()：截取字符串。 </li><li>equals()：字符串比较。</li></ul><h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h3 id="String和StringBuffer、StringBuilder的区别是什么？String-为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String-为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String 为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String 为什么是不可变的</h3><p>可变性</p><p>String类中使用字符数组保存字符串，private　final　char　value[]，所以 string对象是不可变的。StringBuilder与StringBuffer都继承自</p><p>AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。线程安全性</p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。</p><p>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p>性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操</p><p>作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p>对于三者使用的总结</p><p>如果要操作少量的数据用 &#x3D; String 单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder 多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p><h2 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h2><h2 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h2><p>自动装箱与拆箱</p><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><h3 id="拆箱：将包装类型转换为基本数据类型；-int-和-Integer-有什么区别"><a href="#拆箱：将包装类型转换为基本数据类型；-int-和-Integer-有什么区别" class="headerlink" title="拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别"></a>拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别</h3><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，</p><p>Double</p><h3 id="Integer-a-x3D-127-与-Integer-b-x3D-127相等吗"><a href="#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗" class="headerlink" title="Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗"></a>Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗</h3><p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。</p><p>对于基本数据类型：&#x3D;&#x3D;比较的是值。如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer 对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1public static void main(String[] args) &#123;</span><br><span class="line">2Integer a = new Integer(3);</span><br><span class="line">3Integer b = 3; // 将3自动装箱成Integer类型</span><br><span class="line">4int c = 3;</span><br><span class="line">5System.out.println(a == b); // false 两个引用没有引用同一对象</span><br><span class="line">6System.out.println(a == c); // true a自动拆箱成int类型再和c比较</span><br><span class="line">7System.out.println(b == c); // true</span><br><span class="line">8</span><br><span class="line">9Integer a1 = 128;</span><br><span class="line">10Integer b1 = 128;</span><br><span class="line">11System.out.println(a1 == b1); // false</span><br><span class="line">12</span><br><span class="line">13Integer a2 = 127;</span><br><span class="line">14Integer b2 = 127;</span><br><span class="line">15System.out.println(a2 == b2); // true</span><br><span class="line">16&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/10/09/redis/"/>
      <url>/2022/10/09/redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis常用配置</p><img src="/2022/10/09/redis/mywechat.jpg" class="" title="myWechat"><p>daemonize no</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置 redis server 是否以守护进程的方式启动。</span><br><span class="line">no：不以守护进程启动。</span><br><span class="line">yes：以守护进程启动。</span><br></pre></td></tr></table></figure><p>pidfile “&#x2F;var&#x2F;run&#x2F;redis&#x2F;redis-server.pid”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 Redis 以守护进程方式启动时，会在该文件里面写入 redis 的进程 id。</span><br></pre></td></tr></table></figure><p>port 6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置 redis server 启动的端口，默认为 6379。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tcp-backlog 511</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP 监听的最大容纳数量。</span><br><span class="line">在高并发的环境下，需要把这个值调高以避免客户端连接缓慢的问题。</span><br><span class="line">如果该值大于 Linux 内核的值，则 Linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值， 此时要同时修改这两个值才能生效。</span><br></pre></td></tr></table></figure><span id="more"></span><p>bind 192.168.98.70</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，Redis 会监听所有 IP 的客户端连接。 如果只想让它在一个网络接口上监听，那你就绑定一个 IP 或者多个 IP。</span><br></pre></td></tr></table></figure><p>unixsocket &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis.sock</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定 unix socket 的路径。</span><br></pre></td></tr></table></figure><p>unixsocketperm 700</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定 unix socket 文件的权限。</span><br></pre></td></tr></table></figure><p>timeout 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定一个再client链接空闲多少秒之后关闭连接，0就是不关闭</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tcp-keepalive 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP 心跳包。 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。</span><br></pre></td></tr></table></figure><p>loglevel   notice</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义日志级别。</span><br></pre></td></tr></table></figure><p>logfile “&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义日志文件的位置。</span><br></pre></td></tr></table></figure><p>syslog-enabled  no</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否将志记录到系统日志，no：不记录， yes：记录。</span><br></pre></td></tr></table></figure><p>syslog-ident redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置系统日志的 identity，即系统日志的唯一标志。</span><br></pre></td></tr></table></figure><p>syslog-facility local0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。</span><br></pre></td></tr></table></figure><p>databases 16</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置数据库的数目。</span><br><span class="line">默认数据库是 DB 0，你可以在每个连接上使用 select dbid 命令选择一个不同的数据库， 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值。</span><br></pre></td></tr></table></figure><p>save 900 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据给定的时间间隔和写入次数将数据保存到磁盘。</span><br><span class="line">900 秒内如果至少有 1 个 key 的值变化，则保存。</span><br></pre></td></tr></table></figure><p>save 300 10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 秒内如果至少有 10 个 key 的值变化，则保存。</span><br></pre></td></tr></table></figure><p>save 60 10000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure><p>save “”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以注释掉所有的 save 行来停用保存功能。 也可以直接一个空字符串来实现停用。</span><br></pre></td></tr></table></figure><p>stop-writes-on-bgsave-error  yes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，如果 Redis 最后一次的后台保存失败，Redis 将停止接受写操作， 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生。</span><br><span class="line">如果后台保存进程重新启动工作了，Redis 也将自动的允许写操作。</span><br><span class="line">然而你要是安装了靠谱的监控，你可能不希望 Redis 这样做，那你就改成 no 好了。</span><br></pre></td></tr></table></figure><p>rdbcompression yes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串。默认都设为 yes 。</span><br><span class="line">如果你希望保存子进程节省点 cpu ，你就设置它为 no ， 不过这个数据集可能就会比较大。</span><br></pre></td></tr></table></figure><p>rdbchecksum yes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否校验 rdb 文件。</span><br></pre></td></tr></table></figure><p>dbfilename dump.rdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 dump 的文件位置。</span><br></pre></td></tr></table></figure><p>dir .&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工作目录。上面的 dbfilename 只指定了文件名，但是它会写入到这个目录下。</span><br><span class="line">这个配置项一定是个目录，而不能是文件名。</span><br></pre></td></tr></table></figure><iframe src="//player.bilibili.com/player.html?aid=430366092&bvid=BV1GG411V7ye&cid=827668646&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><video src="./redis/test.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p>bad asset path...]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/10/09/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/"/>
      <url>/2022/10/09/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="（1）-红黑树的了解（平衡树，二叉搜索树），使用场景"><a href="#（1）-红黑树的了解（平衡树，二叉搜索树），使用场景" class="headerlink" title="（1） 红黑树的了解（平衡树，二叉搜索树），使用场景"></a>（1） 红黑树的了解（平衡树，二叉搜索树），使用场景</h1><p>把数据结构上几种树集中的讨论一下：</p><h2 id="1-AVLtree"><a href="#1-AVLtree" class="headerlink" title="1. AVLtree"></a>1. AVLtree</h2><p>定义：先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度 大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和坏情况 下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这 个树。 </p><p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有 平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为 是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或 从可能存储在节点中的子树高度计算出来。</p><p>一般我们所看见的都是排序平衡二叉树。 </p><p>AVLtree使用场景：AVL树适合用于插入删除次数比较少，但查找多的情况。插 入删除导致很多的旋转，旋转是非常耗时的。AVL 在linux内核的vm area中使用。 </p><span id="more"></span><h2 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2. 二叉搜索树"></a>2. 二叉搜索树</h2><p>二叉搜索树也是一种树，适用与一般二叉树的全部操作，但二叉搜索树能够实现 数据的快速查找。</p><p>二叉搜索树满足的条件： </p><ol><li>非空左子树的所有键值小于其根节点的键值 </li><li>非空右子树的所有键值大于其根节点的键值 </li><li>左右子树都是二叉搜索树</li></ol><p>二叉搜索树的应用场景：如果是没有退化称为链表的二叉树，查找效率就是 lgn，效率不错，但是一旦退换称为链表了，要么使用平衡二叉树，或者之后的 RB树，因为链表就是线性的查找效率。 </p><h2 id="3-红黑树的定义"><a href="#3-红黑树的定义" class="headerlink" title="3. 红黑树的定义"></a>3. 红黑树的定义</h2><p>红黑树是一种二叉查找树，但在每个结点上增加了一个存储位表示结点的颜色， 可以是RED或者BLACK。通过对任何一条从根到叶子的路径上各个着色方式的 限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。 当二叉查找树的高度较低时，这些操作执行的比较快，但是当树的高度较高时， 这些操作的性能可能不比用链表好。红黑树（red-black tree）是一种平衡的二 叉查找树，它能保证在坏情况下，基本的动态操作集合运行时间为O(lgn)。 红黑树必须要满足的五条性质： </p><ul><li>性质一：节点是红色或者是黑色； 在树里面的节点不是红色的就是黑色的，没有其他 颜色，要不怎么叫红黑树呢，是吧。 </li><li>性质二：根节点是黑色； 根节点总是黑色的。它不能为红。 </li><li>性质三：每个叶节点（NIL或空节点）是黑色；</li><li>性质四：每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节 点）； 就是连续的两个节点不能是连续的红色，连续的两个节点的意思就是父节点与 子节点不能是连续的红色。 </li><li>性质五：从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。从根节点 到每一个NIL节点的路径中，都包含了相同数量的黑色节点。</li></ul><p>红黑树的应用场景：红黑树是一种不是非常严格的平衡二叉树，没有AVLtree那 么严格的平衡要求，所以它的平均查找，增添删除效率都还不错。广泛用在 C++的STL中。如map和set都是用红黑树实现的。 </p><h2 id="4-B树定义"><a href="#4-B树定义" class="headerlink" title="4. B树定义"></a>4. B树定义</h2><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径 不只两个），不属于二叉搜索树的范畴，因为它不止两路，存在多路。 </p><p>B树满足的条件： </p><ul><li>（1）树种的每个节点多拥有m个子节点且m&gt;&#x3D;2,空树除外（注：m阶代表一个树节 点多有多少个查找路径，m阶&#x3D;m路,当m&#x3D;2则是2叉树,m&#x3D;3则是3叉）； </li><li>（2）除根节点外每个节点的关键字数量大于等于ceil(m&#x2F;2)-1个小于等于m-1个，非根 节点关键字数必须&gt;&#x3D;2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2) </li><li>（3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也 有指向其子节点的指针只不过其指针地址都为null对应下图后一层节点的空格子 </li><li>（4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1; </li><li>（5）所有节点关键字是按递增次序排列，并遵循左小右大原则；</li></ul><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B%E6%A0%91.png" alt="B树"></p><p> B树的应用场景：构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息， 保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I&#x2F;O操作也少一些，而 且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定 的。 </p><h2 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5. B+树"></a>5. B+树</h2><p>B+树是B树的一个升级版，B+树是B树的变种树，有n棵子树的节点中含有n个 关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子节点。是为文 件系统而生的。 </p><p>相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度 完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们 先看看两者的区别 </p><ul><li>（1）B+跟B树不同，B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每 个节点所能保存的关键字大大增加； </li><li>（2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的 关键字从小到大链接； </li><li>（3）B+树的根节点关键字数量和其子节点个数相等; </li><li>（4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地 址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ul><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B+%E6%A0%91.png" alt="B+树"></p><p>特点： </p><p>在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更 快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速 度更稳定; </p><p>应用场景： 用在磁盘文件组织 数据索引和数据库索引。 </p><h2 id="6-Trie树（字典树）"><a href="#6-Trie树（字典树）" class="headerlink" title="6. Trie树（字典树）"></a>6. Trie树（字典树）</h2><p>trie，又称前缀树，是一种有序树，用于保存关联数组，其中的键通常是字符 串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决 定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根 节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点 和部分内部节点所对应的键才有相关的值。 </p><p>在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一 个特定的整数。Trie 可以看作是一个确定有限状态自动机，尽管边上的符号一 般是隐含在分支的顺序中的。 </p><p>键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示 trie  的原理。</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Trie%E6%A0%91(%E5%AD%97%E5%85%B8%E6%A0%91).png" alt="Trie树(字典树)"></p><p>trie树的优点：利用字符串的公共前缀来节约存储空间，大限度地减少无谓的 字符串比较，查询效率比哈希表高。</p><p>缺点：Trie树是一种比较简单的数据结构.理 解起来比较简单,正所谓简单的东西也得付出代价.故Trie树也有它的缺点,Trie树 的内存消耗非常大. </p><p>其基本性质可以归纳为： </p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。 </li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 </li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><p>典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经 常被搜索引擎系统用于文本词频统计。字典树与字典很相似,当你要查一个单词 是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说 明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二 个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来 储存字母,也可以储存数字等其它数据。 </p><h1 id="（2）-红黑树在STL上的应用"><a href="#（2）-红黑树在STL上的应用" class="headerlink" title="（2） 红黑树在STL上的应用"></a>（2） 红黑树在STL上的应用</h1><p>STL中set、multiset、map、multimap底层是红黑树实现的，而 unordered_map、unordered_set 底层是哈希表实现的。 </p><p>multiset、multimap： 插入相同的key的时候，我们将后插入的key放在相等的 key的右边，之后不管怎么进行插入或删除操作，后加入的key始终被认为比之 前的大。 </p><h2 id="8-（3）了解并查集吗？（低频）"><a href="#8-（3）了解并查集吗？（低频）" class="headerlink" title="8. （3）了解并查集吗？（低频）"></a>8. （3）了解并查集吗？（低频）</h2><p>什么是合并查找问题呢？</p><p>顾名思义，就是既有合并又有查找操作的问题。举个例子，有一群人，他们之间 有若干好友关系。如果两个人有直接或者间接好友关系，那么我们就说他们在同 一个朋友圈中，这里解释下，如果Alice是Bob好友的好友，或者好友的好友的 好友等等，即通过若干好友可以认识，那么我们说Alice和Bob是间接好友。随 着时间的变化，这群人中有可能会有新的朋友关系，这时候我们会对当中某些人 是否在同一朋友圈进行询问。这就是一个典型的合并－查找操作问题，既包含了 合并操作，又包含了查找操作。 </p><p>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素 构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并， 其间要反复查找一个元素在哪个集合中。 </p><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合 并及查询问题。 </p><p>并查集也是使用树形结构实现。不过，不是二叉树。每个元素对应一个节点，每 个组对应一棵树。在并查集中，哪个节点是哪个节点的父亲以及树的形状等信息 无需多加关注，整体组成一个树形结构才是重要的。类似森林 </p><h1 id="（4）-贪心算法和动态规划的区别"><a href="#（4）-贪心算法和动态规划的区别" class="headerlink" title="（4） 贪心算法和动态规划的区别"></a>（4） 贪心算法和动态规划的区别</h1><p>贪心算法：局部优，划分的每个子问题都优，得到全局优，但是不能保证 是全局优解，所以对于贪心算法来说，解是从上到下的，一步一步优，直到 后。 动态规划：将问题分解成重复的子问题，每次都寻找左右子问题解中优的解， 一步步得到全局的优解.重复的子问题可以通过记录的方式，避免多次计算。 所以对于动态规划来说，解是从小到上，从底层所有可能性中找到优解，再一 步步向上。 分治法：和动态规划类似，将大问题分解成小问题，但是这些小问题是独立的， 没有重复的问题。独立问题取得解，再合并成大问题的解。 例子：比如钱币分为1元3元4元，要拿6元钱，贪心的话，先拿4，再拿两个1， 一共3张钱；实际优却是两张3元就够了。 </p><h2 id="（5）-判断一个链表是否有环，如何找到这个环的起点"><a href="#（5）-判断一个链表是否有环，如何找到这个环的起点" class="headerlink" title="（5） 判断一个链表是否有环，如何找到这个环的起点"></a>（5） 判断一个链表是否有环，如何找到这个环的起点</h2><p>给定一个单链表，只给出头指针h： </p><ol><li>如何判断是否存在环？ </li><li>如何知道环的长度？ </li><li>如何找出环的连接点在哪里？ </li><li>带环链表的长度是多少？</li></ol><p>解法： </p><ol><li>对于问题1，使用追赶的方法，设定两个指针slow、fast，从头指针开始， 每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL 退出。 </li><li>对于问题2，记录下问题1的碰撞点p，slow、fast从该点开始，再次碰撞所 走过的操作数就是环的长度s。 </li><li>问题3：有定理：碰撞点p到连接点的距离&#x3D;头指针到连接点的距离，因此， 分别从碰撞点、头指针开始走，相遇的那个点就是连接点。(证明在后面附注) </li><li>问题3中已经求出连接点距离头指针的长度，加上问题2中求出的环的长度， 二者之和就是带环单链表的长度</li></ol><h1 id="6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h1><p>——大家一般认为名不见经传strcpy函数实现不是很难，流行的strcpy函数写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. char *my_strcpy(char *dst,const char *src)</span><br><span class="line">2. &#123;</span><br><span class="line">3. assert(dst != NULL);</span><br><span class="line">4. assert(src != NULL);</span><br><span class="line">5. char *ret = dst;</span><br><span class="line">6. while((* dst++ = * src++) != &#x27;\0&#x27;)</span><br><span class="line">7. ;</span><br><span class="line">8. return ret;</span><br><span class="line">9. &#125;</span><br></pre></td></tr></table></figure><p>如果注意到：</p><p>1，检查指针有效性；</p><p>2，返回目的指针des；</p><p>3，源字符串的末尾 ‘\0’ 需要拷贝。</p><h2 id="内存重叠"><a href="#内存重叠" class="headerlink" title="内存重叠"></a>内存重叠</h2><p>内存重叠：拷贝的目的地址在源地址范围内。所谓内存重叠就是拷贝的目的地址和源地址有重叠。</p><p>在函数strcpy和函数memcpy都没有对内存重叠做处理的，使用这两个函数的时候只有程序员自己保证源地址和目标地址不重叠，或者使用memmove函数进行内存拷贝。</p><p>memmove函数对内存重叠做了处理。</p><p>strcpy的正确实现应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. char *my_strcpy(char *dst,const char *src)</span><br><span class="line">2. &#123;</span><br><span class="line">3. assert(dst != NULL);</span><br><span class="line">4. assert(src != NULL);</span><br><span class="line">5. char *ret = dst;</span><br><span class="line">6. memmove(dst,src,strlen(src)+1);</span><br><span class="line">7. return ret;</span><br><span class="line">8. &#125;</span><br></pre></td></tr></table></figure><p>memmove函数实现时考虑到了内存重叠的情况，可以完成指定大小的内存拷贝</p><h1 id="（7）-快排存在的问题，如何优化"><a href="#（7）-快排存在的问题，如何优化" class="headerlink" title="（7） 快排存在的问题，如何优化"></a>（7） 快排存在的问题，如何优化</h1><h2 id="快排的时间复杂度"><a href="#快排的时间复杂度" class="headerlink" title="快排的时间复杂度"></a>快排的时间复杂度</h2><p>时间复杂度  快平均是O（nlogn）,  慢的时候是O(n2);辅助空间也是</p><p>O(logn)；   开始学快排时   疑惑的就是这个东西不知道怎么得来的，一种是通过数学运算可以的出来，还有一种是通过递归树来理解就容易多了</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p><p>所谓时间复杂度 理想的就是取到中位数情况，那么递归树就是一个完全二叉树，那么树的深度也就是 低为Logn，这个时候每一次又需要n次比较，所以时间复杂度nlogn，当快排为顺序或者逆序</p><p>时，这个数为一个斜二叉树，深度为n，同样每次需要n次比较，那那么  坏需要n2的时间优化：</p><p>1.当整个序列有序时退出算法；</p><p>2.当序列长度很小时（根据经验是大概小于 8），应该使用常数更小的算法，比如插入排序等；</p><p>3.随机选取分割位置；</p><p>4.当分割位置不理想时，考虑是否重新选取分割位置；</p><p>5.分割成两个序列时，只对其中一个递归进去，另一个序列仍可以在这一函数内继续划分，可以显著减小栈的大小（尾递归）：</p><p>6.将单向扫描改成双向扫描，可以减少划分过程中的交换次数优化1：当待排序序列的长度分割到一定大小后，使用插入排序原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割优化3：优化递归操作快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归</p><p>耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为</p><p>O(logn)，将会提高性能。</p><h1 id="（8）-Top-K问题（可以采取的方法有哪些，各自优点？）"><a href="#（8）-Top-K问题（可以采取的方法有哪些，各自优点？）" class="headerlink" title="（8） Top K问题（可以采取的方法有哪些，各自优点？）"></a>（8） Top K问题（可以采取的方法有哪些，各自优点？）</h1><p>1.将输入内容（假设用数组存放）进行完全排序，从中选出排在前K的元素即为所求。有了这个思路，我们可以选择相应的排序算法进行处理，目前来看快速排序，堆排序和归并排序都能达到O(nlogn)的时间复杂度。</p><p>2.对输入内容进行部分排序，即只对前K大的元素进行排序（这K个元素即为所求）。此时我们可以选择冒泡排序或选择排序进行处理，即每次冒泡（选择）都能找到所求的一个元素。这类策略的时间复杂度是O(Kn)。</p><p>3.对输入内容不进行排序，显而易见，这种策略将会有更好的性能开销。我们此时可以选择两种策略进行处理：用一个桶来装前k个数，桶里面可以按照 小堆来维护 a)利用 小堆维护一个大小为K的数组，目前该小根堆中的元素是排名前K的数，其中根是 小的数。此后，每次从原数组中取一个元素与根进行比较，如大于根的元素，则将根元素替换并进行堆调整（下沉），即保证小根堆中的元素仍然是排名前K的数，且根元素仍然 小；否则不予处理，取下一个数组元素继续该过程。该算法的时间复杂度是O(nlogK)，一般来说企业中都采用该策略处理 top-K问题，因为该算法不需要一次将原数组中的内容全部加载到内存中，而这正是海量数据处理必然会面临的一个关卡。</p><p>b)利用快速排序的分划函数找到分划位置K，则其前面的内容即为所求。该算法是一种非常有效的处理方式，时间复杂度是O(n)（证明可以参考算法导论书籍）。对于能一次加载到内存中的数组，该策略非常优秀。</p><h1 id="（9）-Bitmap的使用，存储和插入方法"><a href="#（9）-Bitmap的使用，存储和插入方法" class="headerlink" title="（9） Bitmap的使用，存储和插入方法"></a>（9） Bitmap的使用，存储和插入方法</h1><h2 id="BitMap从字面的意思"><a href="#BitMap从字面的意思" class="headerlink" title="BitMap从字面的意思"></a>BitMap从字面的意思</h2><p>很多人认为是位图，其实准确的来说，翻译成基于位的映射。</p><p>在所有具有性能优化的数据结构中，大家使用  多的就是hash表，是的，在具有定位查找上具有O(1)的常量时间，多么的简洁优美。但是数据量大了，内存就不够了。</p><p>当然也可以使用类似外排序来解决问题的，由于要走IO所以时间上又不行。</p><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>其实如果你知道计数排序的话（算法导论中有一节讲过），你就会发现这个和计数排序很像。</p><h2 id="bitmap应用"><a href="#bitmap应用" class="headerlink" title="bitmap应用"></a>bitmap应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下。</span><br><span class="line">2）去重数据而达到压缩数据</span><br></pre></td></tr></table></figure><p>还可以用于爬虫系统中url去重、解决全组合问题。</p><p>BitMap应用：排序示例</p><p>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201113162002074.png" alt="image-20201113162002074"></p><p>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i&#x2F;8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Littleending的情况，这里默认为Big-ending。不过计算机一般是小端存储的，如</p><p>intel。小端的话就是将倒数第5位置1）,因为是从零开始的，所以要把第五位置为一（如下图）：</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201113162009552.png" alt="image-20201113162009552"></p><p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201113162016525.png" alt="image-20201113162016525"></p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。</p><h2 id="bitmap排序复杂度分析"><a href="#bitmap排序复杂度分析" class="headerlink" title="bitmap排序复杂度分析"></a>bitmap排序复杂度分析</h2><p>Bitmap排序需要的时间复杂度和空间复杂度依赖于数据中  大的数字。</p><p>bitmap排序的时间复杂度不是O(N)的，而是取决于待排序数组中的大值</p><p>MAX，在实际应用上关系也不大，比如我开10个线程去读byte数组，那么复杂度为:O(Max&#x2F;10)。也就是要是读取的，可以用多线程的方式去读取。时间复杂度方面也是O(Max&#x2F;n)，其中Max为byte[]数组的大小，n为线程大小。空间复杂度应该就是O(Max&#x2F;8)bytes吧</p><h2 id="BitMap算法流程"><a href="#BitMap算法流程" class="headerlink" title="BitMap算法流程"></a>BitMap算法流程</h2><p>假设需要排序或者查找的 大数MAX&#x3D;10000000（lz:这里MAX应该是 大的数而不是int数据的总数！），那么我们需要申请内存空间的大小为int a[1 + </p><p>MAX&#x2F;32]。</p><p>其中：a[0]在内存中占32为可以对应十进制数0-31，依次类推： bitmap表为：</p><p>a[0]———&gt;0-31 a[1]———&gt;32-63 a[2]———&gt;64-95</p><p>a[3]———&gt;96-127</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201113162104008.png" alt="image-20201113162104008"></p><p>我们要把一个整数N映射到Bit-Map中去，首先要确定把这个N Mapping到哪一个数组元素中去，即确定映射元素的index。我们用int类型的数组作为map的元素，这样我们就知道了一个元素能够表示的数字个数(这里是32)。于是N&#x2F;32 就可以知道我们需要映射的key了。所以余下来的那个N%32就是要映射到的位数。</p><p>1.求十进制数对应在数组a中的下标：</p><p>先由十进制数n转换为与32的余可转化为对应在数组a中的下标。</p><p>如十进制数0-31，都应该对应在a[0]中，比如n&#x3D;24,那么 n&#x2F;32&#x3D;0，则24对应在数组a中的下标为0。又比如n&#x3D;60,那么n&#x2F;32&#x3D;1，则60对应在数组a中的下标为 1，同理可以计算0-N在数组a中的下标。</p><p>i &#x3D; N&gt;&gt;K % 结果就是N&#x2F;(2^K)</p><p>Note: map的范围是[0, 原数组 大的数对应的2的整次方数-1]。</p><p>2.求十进制数对应数组元素a[i]在0-31中的位m：</p><p>十进制数0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。</p><p>m &#x3D; n &amp; ((1 &lt;&lt; K) - 1) %结果就是n%(2^K)</p><p>3.利用移位0-31使得对应第m个bit位为1</p><p>如a[i]的第m位置1：a[i] &#x3D; a[i] | (1&lt;</p><p>如：将当前4对应的bit位置1的话，只需要1左移4位与B[0] | 即可。</p><p>Note:</p><p>1 p+(i&#x2F;8)|(0×01&lt;&lt;(i%8))这样也可以？</p><p>2 同理将int型变量a的第k位清0，即a&#x3D;a&amp;~(1&lt;</p><h2 id="BitMap算法评价"><a href="#BitMap算法评价" class="headerlink" title="BitMap算法评价"></a>BitMap算法评价</h2><p>优点：</p><ol><li><p>运算效率高，不进行比较和移位；</p></li><li><p>占用内存少，比如   大的数MAX&#x3D;10000000；只需占用内存为</p></li></ol><p>MAX&#x2F;8&#x3D;1250000Byte&#x3D;1.25M。</p><ol start="3"><li></li></ol><p>缺点：</p><ol><li><p>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</p></li><li><p>当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</p></li></ol><h1 id="（10）-字典树的理解以及在统计上的应用"><a href="#（10）-字典树的理解以及在统计上的应用" class="headerlink" title="（10） 字典树的理解以及在统计上的应用"></a>（10） 字典树的理解以及在统计上的应用</h1><p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。Trie树也有它的缺点,Trie树的内存消耗非常大.当然,或许用左儿子右兄弟的方法建树的话,可能会好点. 就是在海量数据中找出某一个数，比如2亿QQ号中查找出某一个特定的QQ号</p><h1 id="（11）-N个骰子出现和为m的概率"><a href="#（11）-N个骰子出现和为m的概率" class="headerlink" title="（11） N个骰子出现和为m的概率"></a>（11） N个骰子出现和为m的概率</h1><p>典型的可以用动态规划的思想来完成</p><p>1.现在变量有：骰子个数，点数和。当有k个骰子，点数和为n时，出现次数记为 f(k,n)。那与k-1个骰子阶段之间的关系是怎样的？</p><p>2.当我有k-1个骰子时，再增加一个骰子，这个骰子的点数只可能为1、2、3、</p><p>4、5或6。那k个骰子得到点数和为n的情况有：</p><p>(k-1,n-1)：第k个骰子投了点数1</p><p>(k-1,n-2)：第k个骰子投了点数2</p><p>(k-1,n-3)：第k个骰子投了点数3</p><p>…</p><p>(k-1,n-6)：第k个骰子投了点数6</p><p>在k-1个骰子的基础上，再增加一个骰子出现点数和为n的结果只有这6种情况！所以：f(k,n)&#x3D;f(k-1,n-1)+f(k-1,n-2)+f(k-1,n-3)+f(k-1,n-4)+f(k-1,n-5)+f(k-</p><p>1,n-6)</p><p>3.有1个骰子，f(1,1)&#x3D;f(1,2)&#x3D;f(1,3)&#x3D;f(1,4)&#x3D;f(1,5)&#x3D;f(1,6)&#x3D;1。</p><p>用递归就可以解决这个问题：</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%80%92%E5%BD%92.jpg" alt="递归"></p><p>用迭代来完成</p><p><img src="/21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E8%BF%AD%E4%BB%A3.jpg" alt="迭代"></p><h1 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h1><p>目前关于海量数据想到的解决办法：</p><p>1.bitmap</p><p>2.桶排序，外部排序，将需要排序的放到外存上，不用全部放到内存上</p><h1 id="（20）-一致性哈希说明"><a href="#（20）-一致性哈希说明" class="headerlink" title="（20） 一致性哈希说明"></a>（20） 一致性哈希说明</h1><p>优点</p><p>1.当后端是缓存服务器时，经常使用一致性哈希算法来进行负载均衡。使用一致性哈希的好处在于，增减集群的缓存服务器时，只有少量的缓存会失效，回源量较小。</p><p>2.尽量减少数据丢失问题，减少移动数据的风险</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式总结</title>
      <link href="/2022/10/09/22-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
      <url>/2022/10/09/22-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这-个实例。"><a href="#1-单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这-个实例。" class="headerlink" title="1. 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这 个实例。"></a>1. 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这 个实例。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">（1）懒汉式 public class Singleton &#123;  </span><br><span class="line">    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载  */       private static Singleton instance = null;  </span><br><span class="line">    /* 私有构造方法，防止被实例化 */      </span><br><span class="line">    private Singleton() &#123;    </span><br><span class="line">    &#125;  </span><br><span class="line">    /* 1:懒汉式，静态工程方法，创建实例 */       public static Singleton getInstance() &#123;           if (instance == null) &#123;               instance = new Singleton();          </span><br><span class="line">    &#125;       </span><br><span class="line">   return instance;     </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">    （2）饿汉式 </span><br><span class="line">    public class Singleton &#123;  </span><br><span class="line">    /* 持有私有静态实例，防止被引用 */       </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    /* 私有构造方法，防止被实例化 */      </span><br><span class="line">    private Singleton() &#123;   </span><br><span class="line">    &#125;  </span><br><span class="line">    /* 1:懒汉式，静态工程方法，创建实例 */       public static Singleton getInstance() &#123;         </span><br><span class="line">    return instance;     </span><br><span class="line">    &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用场景： </p><ul><li>要求生成唯一序列号的环境； </li><li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数 器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并 确保是线程安全的； </li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源； </li><li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式 （当然，也可以直接声明为static的方式）。</li></ul><span id="more"></span><h2 id="2-工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂-方法使一个类的实例化延迟到其子类。"><a href="#2-工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂-方法使一个类的实例化延迟到其子类。" class="headerlink" title="2. 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。"></a>2. 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂 方法使一个类的实例化延迟到其子类。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">接口</span><br><span class="line"></span><br><span class="line">public interface Fruit &#123;       </span><br><span class="line">public void print();   &#125;   </span><br><span class="line">2个实现类</span><br><span class="line">public class Apple implements Fruit&#123;  </span><br><span class="line">    @Override       </span><br><span class="line">    public void print() &#123;           </span><br><span class="line">    System.out.println(&quot;我是一个苹果&quot;);       </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">public class Orange implements Fruit&#123;  </span><br><span class="line">    @Override       </span><br><span class="line">    public void print() &#123;           </span><br><span class="line">    System.out.println(&quot;我是一个橘子&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">工厂类</span><br><span class="line"></span><br><span class="line">public class FruitFactory &#123;       </span><br><span class="line">public Fruit produce(String type)&#123;           </span><br><span class="line">if(type.equals(&quot;apple&quot;))&#123;               </span><br><span class="line">return new Apple();           </span><br><span class="line">&#125;else if(type.equals(&quot;orange&quot;))&#123;               </span><br><span class="line">return new Orange();           </span><br><span class="line">&#125;else&#123;               </span><br><span class="line">System.out.println(&quot;请输入正确的类型!&quot;);                 </span><br><span class="line">return null;            </span><br><span class="line">&#125;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用场景：jdbc连接数据库，硬件访问，降低对象的产生和销毁</p><h2 id="3-抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指-定它们的具体类。"><a href="#3-抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指-定它们的具体类。" class="headerlink" title="3. 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指 定它们的具体类。"></a>3. 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无须指 定它们的具体类。</h2><p>相对于工厂模式，我们可以新增产品类（只需要实现产品接口），只需要同时新 增一个工厂类，客户端就可以轻松调用新产品的代码。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface food&#123;&#125; </span><br><span class="line">class A implements food&#123;&#125; </span><br><span class="line">class B implements food&#123;&#125; </span><br><span class="line">interface produce&#123; food get();&#125; </span><br><span class="line">class FactoryForA implements produce&#123;     </span><br><span class="line">@Override     </span><br><span class="line">public food get() &#123;         </span><br><span class="line">return new A();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">class FactoryForB implements produce&#123;     </span><br><span class="line">@Override     </span><br><span class="line">public food get() &#123;         </span><br><span class="line">return new B();     </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">public class AbstractFactory &#123;     </span><br><span class="line">public void ClientCode(String name)&#123;         </span><br><span class="line">food x= new FactoryForA().get();         </span><br><span class="line">x = new FactoryForB().get();     </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束。 涉及不同操作系统的时候，都可以考虑使用抽象工厂模式 </p><h2 id="4-建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可-以创建不同的表示。"><a href="#4-建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可-以创建不同的表示。" class="headerlink" title="4.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可 以创建不同的表示。"></a>4.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可 以创建不同的表示。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Build &#123;     </span><br><span class="line">static class Student&#123;     </span><br><span class="line">String name = null ;         </span><br><span class="line">int number = -1 ;         </span><br><span class="line">String sex = null ;     </span><br><span class="line">public Student(Builder builder)         &#123;     </span><br><span class="line">this.name=builder.name;     </span><br><span class="line">this.number=builder.number;     </span><br><span class="line">this.sex=builder.sex;     </span><br><span class="line">&#125;         </span><br><span class="line">static class Builder&#123;</span><br><span class="line">            </span><br><span class="line">String name = null ;             </span><br><span class="line">int number = -1 ;             </span><br><span class="line">String sex = null ;             </span><br><span class="line">public Builder setName(String name)&#123;                 </span><br><span class="line">this.name=name;                 </span><br><span class="line">return this;             </span><br><span class="line">&#125;             </span><br><span class="line">public Builder setNumber(int number)&#123;                 </span><br><span class="line">this.number=number;                 </span><br><span class="line">return this;             </span><br><span class="line">&#125;             </span><br><span class="line">public Builder setSex(String sex)&#123;                 </span><br><span class="line">this.sex=sex;                 </span><br><span class="line">return this;             </span><br><span class="line">&#125;             </span><br><span class="line">public Student build()&#123;                 </span><br><span class="line">return new Student(this);            </span><br><span class="line">&#125;</span><br><span class="line"> &#125;                 </span><br><span class="line">&#125;     </span><br><span class="line">public static void main(String[] args) &#123;     </span><br><span class="line">Student A=new Student.Builder().setName(&quot;张 三&quot;).setNumber(1).build();     Student B=new Student.Builder().setSex(&quot;男&quot;).setName(&quot;李四&quot;).build();      </span><br><span class="line">System.out.println(A.name+&quot; &quot;+A.number+&quot; &quot;+A.sex);         System.out.println(B.name+&quot; &quot;+B.number+&quot; &quot;+B.sex);     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用场景：</p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模 式。 </li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同 时，则可以使用该模式。 </li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候 使用建造者模式非常合适。</li></ol><h2 id="5-原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的-对象。"><a href="#5-原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的-对象。" class="headerlink" title="5. 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的 对象。"></a>5. 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的 对象。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable&#123;     </span><br><span class="line">private String name;     </span><br><span class="line">public String getName() &#123;         </span><br><span class="line">return name;     </span><br><span class="line">&#125;     </span><br><span class="line">public void setName(String name) &#123;         </span><br><span class="line">this.name = name;     </span><br><span class="line">&#125;     </span><br><span class="line">@Override     </span><br><span class="line">protected Object clone()   &#123;         </span><br><span class="line">try &#123;             </span><br><span class="line">return super.clone();         </span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;             </span><br><span class="line">e.printStackTrace();         </span><br><span class="line">&#125;finally &#123;             </span><br><span class="line">return null;         </span><br><span class="line">&#125;     </span><br><span class="line">&#125;     </span><br><span class="line">public static void main ( String[] args)&#123;         </span><br><span class="line">Prototype pro = new Prototype();         </span><br><span class="line">Prototype pro1 = (Prototype)pro.clone();     </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>原型模式实际上就是实现Cloneable接口，重写clone（）方法。 </p><p>使用原型模式的优点： </p><p>1.性能优良 </p><p>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是 要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 </p><p>2.逃避构造函数的约束 </p><p>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见 13.4节）。</p><p>使用场景： </p><p>资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </p><p>性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模 式。 </p><p>一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可 以考虑使用原型模式拷贝多个对象供调用者使用。</p><p>浅拷贝和深拷贝：</p><p>浅拷贝：Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用 对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝， 其他的原始类型比如int、long、char、string（当做是原始类型）等都会被拷 贝。 </p><p>注意：　使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一 是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是 一个原始类型或不可变对象。 </p><p>深拷贝：对私有的类变量进行独立的拷贝       </p><p>如：this.arrayList &#x3D; (ArrayList)this.arrayList.clone();</p><h2 id="6-适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本-因接口不匹配而无法在一起工作的两个类能够在一起工作。"><a href="#6-适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本-因接口不匹配而无法在一起工作的两个类能够在一起工作。" class="headerlink" title="6. 适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本 因接口不匹配而无法在一起工作的两个类能够在一起工作。"></a>6. 适配器模式：将一个类的接口变换成客户端所期待的另一种接口，从而使原本 因接口不匹配而无法在一起工作的两个类能够在一起工作。</h2><p>主要可分为3种： </p><ol><li>类适配：创建新类，继承源类，并实现新接口，例如  class  adapter extends oldClass  implements newFunc{} </li><li>对象适配：创建新类持源类的实例，并实现新接口，例如  class adapter implements newFunc { private oldClass oldInstance ;} </li><li>接口适配：创建新的抽象类实现旧接口方法。例如  abstract class adapter implements oldClassFunc { void newFunc();}</li></ol><p>使用场景： </p><p>你有动机修改一个已经投产中的接口时，适配器模式可能是适合你的模式。比 如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接 口，怎么办？使用适配器模式，这也是我们例子中提到的。</p><h2 id="7-装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰-器模式相比生成子类更为灵活-。"><a href="#7-装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰-器模式相比生成子类更为灵活-。" class="headerlink" title="7. 装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰 器模式相比生成子类更为灵活 。"></a>7. 装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰 器模式相比生成子类更为灵活 。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125; </span><br><span class="line">public class Decorator implements Source&#123;     </span><br><span class="line">private Source source ;     </span><br><span class="line">public void decotate1()&#123;         </span><br><span class="line">System.out.println(&quot;decorate&quot;);     </span><br><span class="line">&#125;     </span><br><span class="line">@Override     </span><br><span class="line">public void method() &#123;         </span><br><span class="line">decotate1();         </span><br><span class="line">source.method();     </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用场景： </p><ol><li>需要扩展一个类的功能，或给一个类增加附加功能。</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 </li><li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</li></ol><h2 id="8-代理模式：为其他对象提供一种代理以控制对这个对象的访问。"><a href="#8-代理模式：为其他对象提供一种代理以控制对这个对象的访问。" class="headerlink" title="8. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。"></a>8. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Source&#123; void method();&#125; </span><br><span class="line">class OldClass implements Source&#123;     </span><br><span class="line">@Override     </span><br><span class="line">public void method() &#123;     </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">class Proxy implements Source&#123;     </span><br><span class="line">private Source source = new OldClass();     </span><br><span class="line">void doSomething()&#123;&#125;     </span><br><span class="line">@Override    </span><br><span class="line">public void method() &#123;         </span><br><span class="line">new Class1().Func1();         </span><br><span class="line">source.method();         </span><br><span class="line">new Class2().Func2();         </span><br><span class="line">doSomething();     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要-显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。"><a href="#9-中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要-显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。" class="headerlink" title="9. 中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要 显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。"></a>9. 中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要 显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Mediator &#123;      </span><br><span class="line">//定义同事类      </span><br><span class="line">protected ConcreteColleague1 c1;      </span><br><span class="line">protected ConcreteColleague2 c2;      </span><br><span class="line">//通过getter/setter方法把同事类注入进来      </span><br><span class="line">public ConcreteColleague1 getC1() &#123;              </span><br><span class="line">return c1;      </span><br><span class="line">&#125;</span><br><span class="line">  public void setC1(ConcreteColleague1 c1) &#123;              </span><br><span class="line">  this.c1 = c1;      </span><br><span class="line">  &#125;      </span><br><span class="line">  public ConcreteColleague2 getC2() &#123;             </span><br><span class="line">  return c2; &#125;     </span><br><span class="line">  public void setC2(ConcreteColleague2 c2) &#123;       </span><br><span class="line">  this.c2 = c2;     </span><br><span class="line">  &#125;    </span><br><span class="line">  //中介者模式的业务逻辑     </span><br><span class="line">  public abstract void doSomething1();     </span><br><span class="line">  public abstract void doSomething2(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用场景： 中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中 出现了蜘蛛网状结构，即每个类都与其他的类有直接的联系。 </p><h2 id="10-命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端-参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。"><a href="#10-命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端-参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。" class="headerlink" title="10. 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端 参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。"></a>10. 命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端 参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</h2><p>Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的 </p><p>Command命令角色：需要执行的所有命令都在这里声明 </p><p>Invoker调用者角色：接收到命令，并执行命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//通用Receiver类 </span><br><span class="line">public abstract class Receiver &#123;     </span><br><span class="line">public abstract void doSomething(); </span><br><span class="line">&#125; </span><br><span class="line">//具体Receiver类 </span><br><span class="line">public class ConcreteReciver1 extends Receiver&#123;      </span><br><span class="line">//每个接收者都必须处理一定的业务逻辑      </span><br><span class="line">public void doSomething()&#123; &#125;  </span><br><span class="line">&#125; </span><br><span class="line">public class ConcreteReciver2 extends Receiver&#123;      </span><br><span class="line">//每个接收者都必须处理一定的业务逻辑      </span><br><span class="line">public void doSomething()&#123; &#125;  </span><br><span class="line">&#125; </span><br><span class="line">//抽象Command类 public abstract class Command &#123;     </span><br><span class="line">public abstract void execute(); </span><br><span class="line">&#125; </span><br><span class="line">//具体的Command类 </span><br><span class="line">public class ConcreteCommand1 extends Command &#123;      </span><br><span class="line">//对哪个Receiver类进行命令处理      </span><br><span class="line">private Receiver receiver;   </span><br><span class="line">//构造函数传递接收者   </span><br><span class="line">public ConcreteCommand1(Receiver _receiver)&#123;   </span><br><span class="line">this.receiver = _receiver;     </span><br><span class="line">&#125;  </span><br><span class="line">//必须实现一个命令 </span><br><span class="line">public void execute() &#123;   </span><br><span class="line">//业务处理        </span><br><span class="line">this.receiver.doSomething();    </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">public class ConcreteCommand2 extends Command &#123;  </span><br><span class="line">//哪个Receiver类进行命令处理   </span><br><span class="line">private Receiver receiver; </span><br><span class="line">//构造函数传递接收者</span><br><span class="line">public ConcreteCommand2(Receiver _receiver)&#123;    </span><br><span class="line">this.receiver = _receiver;   </span><br><span class="line">&#125;     </span><br><span class="line">//必须实现一个命令 </span><br><span class="line"> public void execute() &#123;      </span><br><span class="line"> //业务处理      </span><br><span class="line"> this.receiver.doSomething(); </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125; </span><br><span class="line"> //调用者Invoker类 public class Invoker &#123;   </span><br><span class="line"> private Command command;</span><br><span class="line"> public void setCommand(Command _command)&#123;    </span><br><span class="line"> this.command = _command;  </span><br><span class="line"> &#125;</span><br><span class="line">public void action() &#123;      </span><br><span class="line">this.command.execute();  </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">//场景类 </span><br><span class="line">public class Client &#123; </span><br><span class="line">public static void main(String[] args)&#123;      </span><br><span class="line">Invoker invoker = new Invoker();       </span><br><span class="line">Receiver receiver = new ConcreteReceiver1();</span><br><span class="line">    Command command = new ConcreteCommand1(receiver);         invoker.setCommand(command);    </span><br><span class="line">     invoker.action(); </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用场景： 认为是命令的地方就可以采用命令模式，例如，在GUI开发中，一个按钮的点击 是一个命令，可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模<br>式；触发－反馈机制的处理等。</p><h2 id="11-责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。"><a href="#11-责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。" class="headerlink" title="11.责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。"></a>11.责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">     private Handler nextHandler;</span><br><span class="line">     //每个处理者都必须对请求做出处理</span><br><span class="line">     public final Response handleMessage(Request request)&#123;</span><br><span class="line">             Response response = null;  </span><br><span class="line">             //判断是否是自己的处理级别</span><br><span class="line">             if(this.getHandlerLevel().equals(request.getRequestLevel()))&#123;</span><br><span class="line">                    response = this.echo(request);</span><br><span class="line">             &#125;else&#123;  //不属于自己的处理级别</span><br><span class="line">                    //判断是否有下一个处理者</span><br><span class="line">                    if(this.nextHandler != null)&#123;</span><br><span class="line">                            response = this.nextHandler.handleMessage(request);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                            //没有适当的处理者，业务自行处理</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             return response;</span><br><span class="line">     &#125;</span><br><span class="line">     //设置下一个处理者是谁</span><br><span class="line">     public void setNext(Handler _handler)&#123;</span><br><span class="line">             this.nextHandler = _handler;</span><br><span class="line">     &#125;</span><br><span class="line">     //每个处理者都有一个处理级别</span><br><span class="line">     protected abstract Level getHandlerLevel();</span><br><span class="line">     //每个处理者都必须实现处理任务</span><br><span class="line">     protected abstract Response echo(Request request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。"><a href="#12-策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。" class="headerlink" title="12.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。"></a>12.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</h2><p>使用场景：</p><ol><li><p>多个类只有在算法或行为上稍有不同的场景。</p></li><li><p>算法需要自由切换的场景。</p></li><li><p>需要屏蔽算法规则的场景。</p></li></ol><h2 id="13-迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。"><a href="#13-迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。" class="headerlink" title="13.迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。"></a>13.迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</h2><p>迭代器模式已经被淘汰，java中已经把迭代器运用到各个聚集类（collection）中了，使用java自带的迭代器就已经满足我们的需求了。</p><h2 id="14-组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。"><a href="#14-组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。" class="headerlink" title="14.组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。"></a>14.组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Composite extends Component &#123;</span><br><span class="line">     //构件容器</span><br><span class="line">     private ArrayList componentArrayList = new ArrayList();</span><br><span class="line">     //增加一个叶子构件或树枝构件</span><br><span class="line">     public void add(Component component)&#123;</span><br><span class="line">             this.componentArrayList.add(component);</span><br><span class="line">     &#125;</span><br><span class="line">     //删除一个叶子构件或树枝构件</span><br><span class="line">     public void remove(Component component)&#123;</span><br><span class="line">this.componentArrayList.remove(component);</span><br><span class="line">     &#125;</span><br><span class="line">     //获得分支下的所有叶子构件和树枝构件</span><br><span class="line">     public ArrayList getChildren()&#123;</span><br><span class="line">             return this.componentArrayList;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</p></li><li><p>从一个整体中能够独立出部分模块或功能的场景。</p></li></ol><h2 id="15-观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。"><a href="#15-观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。" class="headerlink" title="15.观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。"></a>15.观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line">     //定义一个观察者数组</span><br><span class="line">     private Vector obsVector = new Vector();</span><br><span class="line">     //增加一个观察者</span><br><span class="line">     public void addObserver(Observer o)&#123;</span><br><span class="line">             this.obsVector.add(o);</span><br><span class="line">     &#125;</span><br><span class="line">     //删除一个观察者</span><br><span class="line">     public void delObserver(Observer o)&#123;</span><br><span class="line">             this.obsVector.remove(o);</span><br><span class="line">     &#125;</span><br><span class="line">     //通知所有观察者</span><br><span class="line">     public void notifyObservers()&#123;</span><br><span class="line">             for(Observer o:this.obsVector)&#123;</span><br><span class="line">                     o.update();</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</p></li><li><p>事件多级触发场景。</p></li><li><p>跨系统的消息交换场景，如消息队列的处理机制</p></li></ol><h2 id="16-门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。"><a href="#16-门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。" class="headerlink" title="16.门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。"></a>16.门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    private subSystem1 subSystem1 = new subSystem1();</span><br><span class="line">    private subSystem2 subSystem2 = new subSystem2();</span><br><span class="line">    private subSystem3 subSystem3 = new subSystem3();</span><br><span class="line">    public void startSystem()&#123;</span><br><span class="line">        subSystem1.start();</span><br><span class="line">        subSystem2.start();         </span><br><span class="line">        subSystem3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public void stopSystem()&#123;</span><br><span class="line">        subSystem1.stop();</span><br><span class="line">        subSystem2.stop();         </span><br><span class="line">        subSystem3.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>为一个复杂的模块或子系统提供一个供外界访问的接口</p></li><li><p>子系统相对独立——外界对子系统的访问只要黑箱操作即可</p></li><li><p>预防低水平人员带来的风险扩散</p></li></ol><h2 id="17-备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。"><a href="#17-备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。" class="headerlink" title="17.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。"></a>17.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">    private String state;</span><br><span class="line">    /**</span><br><span class="line">*工厂方法，返回一个新的备忘录对象</span><br><span class="line">     */</span><br><span class="line">    public Memento createMemento()&#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">*将发起人恢复到备忘录对象所记载的状态</span><br><span class="line">     */</span><br><span class="line">    public void restoreMemento(Memento memento)&#123;</span><br><span class="line">        this.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">        System.out.println(&quot;当前状态：&quot; + this.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>需要保存和恢复数据的相关状态场景。</p></li><li><p>提供一个可回滚（rollback）的操作。</p></li><li><p>需要监控的副本场景中。</p></li><li><p>数据库连接的事务管理就是用的备忘录模式。</p></li></ol><h2 id="18-访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。"><a href="#18-访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。" class="headerlink" title="18.访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。"></a>18.访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</h2><p>使用场景：</p><ol><li><p>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。</p></li><li><p>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</p></li></ol><h2 id="19-状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。"><a href="#19-状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。" class="headerlink" title="19.状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。"></a>19.状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</h2><p>使用场景：</p><ol><li><p>行为随状态改变而改变的场景这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。</p></li><li><p>条件、分支判断语句的替代者</p></li></ol><h2 id="20-解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。"><a href="#20-解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。" class="headerlink" title="20.解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。"></a>20.解释器模式：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</h2><p>使用场景：</p><ol><li><p>重复发生的问题可以使用解释器模式</p></li><li><p>一个简单语法需要解释的场景</p></li></ol><h2 id="21-享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。"><a href="#21-享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。" class="headerlink" title="21.享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。"></a>21.享元模式：使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract class flywei&#123; &#125;</span><br><span class="line">public class Flyweight extends flywei&#123;</span><br><span class="line">    Object obj ;</span><br><span class="line">    public Flyweight(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class  FlyweightFactory&#123;     private HashMap data;</span><br><span class="line">    public FlyweightFactory()&#123; data = new HashMap&lt;&gt;();&#125;</span><br><span class="line">    public Flyweight getFlyweight(Object object)&#123;</span><br><span class="line">        if ( data.containsKey(object))&#123;</span><br><span class="line">            return data.get(object);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Flyweight flyweight = new Flyweight(object);</span><br><span class="line">            data.put(object,flyweight);</span><br><span class="line">            return flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>系统中存在大量的相似对象。</p></li><li><p>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p></li><li><p>需要缓冲池的场景。</p></li></ol><h2 id="22-桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。"><a href="#22-桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。" class="headerlink" title="22.桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。"></a>22.桥梁模式：将抽象和实现解耦，使得两者可以独立地变化。</h2><p>Circle类将DrwaApi与Shape类进行了桥接，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">interface DrawAPI &#123;</span><br><span class="line">    public void drawCircle(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">class RedCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GreenCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</span><br><span class="line">                + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    protected DrawAPI drawAPI;</span><br><span class="line">    protected Shape(DrawAPI drawAPI)&#123;</span><br><span class="line">        this.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">    private int x, y, radius;</span><br><span class="line">    public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.drawCircle(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端使用代码</span><br><span class="line">Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); </span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li><p>不希望或不适用使用继承的场景</p></li><li><p>接口或抽象类不稳定的场景</p></li><li><p>重用性要求较高的场景</p></li></ol><h2 id="23-模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。"><a href="#23-模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。" class="headerlink" title="23.模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。"></a>23.模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</h2><p>使用场景：</p><ol><li><p>多个子类有公有的方法，并且逻辑基本相同时。</p></li><li><p>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</p></li><li><p>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
