<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="运气和努力一样重要">
<meta property="og:type" content="website">
<meta property="og:title" content="和善寺">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="和善寺">
<meta property="og:description" content="运气和努力一样重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="善善332">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>和善寺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="和善寺" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和善寺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:21" itemprop="dateModified" datetime="2021-03-03T13:51:21+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p><strong>集合框架：</strong>用于存储数据的容器。 </p>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。 任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算 法。 </p>
<p><strong>接口：</strong>表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现， 从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。 </p>
<p><strong>实现：</strong>集合接口的具体实现，是重用性很高的数据结构。<br><strong>算法：</strong>在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方 法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个 接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。 它减少了程序设计的辛劳。 </p>
<p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部 分上，而不是为了让程序能正常运转而将注意力于底层设计上。 </p>
<p>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以 便联合这些API而去写大量的代码。 它提高了程序速度和质量。 </p>
<h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p>集合的特点主要有如下两点： </p>
<ul>
<li>对象封装数据，对象多了也需要存储。集合用于存储对象。 </li>
<li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因 为集合是可变长度的。</li>
</ul>
<h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul>
<li>数组是固定长度的；集合可变长度的。 </li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存 储引用数据类型。 </li>
<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同 数据类型。</li>
</ul>
<p><strong>数据结构：</strong>就是容器中存储数据的方式。 </p>
<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个 容器的内部数据结构不同。 </p>
<p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参 阅顶层内容。建立底层对象。</strong> </p>
<h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ol>
<li>容量自增长； </li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质 量； 3</li>
<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。 </li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ol>
<h2 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h2><p>Map接口和Collection接口是所有集合框架的父接口： </p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口 </li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、 ConcurrentHashMap以及Properties等 </li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h2 id="List，Set，Map三者的区别？List、Set、Map-是否继-承自-Collection-接口？List、Map、Set-三个接口存取-元素时，各有什么特点？"><a href="#List，Set，Map三者的区别？List、Set、Map-是否继-承自-Collection-接口？List、Map、Set-三个接口存取-元素时，各有什么特点？" class="headerlink" title="List，Set，Map三者的区别？List、Set、Map 是否继 承自 Collection 接口？List、Map、Set 三个接口存取 元素时，各有什么特点？"></a>List，Set，Map三者的区别？List、Set、Map 是否继 承自 Collection 接口？List、Map、Set 三个接口存取 元素时，各有什么特点？</h2><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Collection.png" alt="Collection"></p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Map.png" alt="Map"></p>
<p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、 List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是 collection的子接口。 </p>
<p>Collection集合主要有List和Set两大接口 </p>
<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重 复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList  和 Vector。 </li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素， 只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、 LinkedHashSet 以及 TreeSet。</li>
</ul>
<p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不 要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元 素时，只要给出键对象，就会返回对应的值对象。 </p>
<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、 ConcurrentHashMap</p>
<h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><p>Collection </p>
<p>**List **</p>
<ul>
<li>Arraylist： Object数组 </li>
<li>Vector： Object数组 </li>
<li>LinkedList： 双向循环链表</li>
</ul>
<p>**Set **</p>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过  LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基 于 Hashmap 实现一样，不过还是有一点点区别的。 </li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。) Map </li>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主 体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后<br>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转 化为红黑树，以减少搜索时间 </li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是 基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面 结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。 同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 </li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为 了解决哈希冲突而存在的 </li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已 经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优 先考虑的。 </li>
<li>statck：堆栈类，先进后出。 </li>
<li>hashtable：就比hashmap多了个线程安全。 </li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
<h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作 时，有可能会产生 fail-fast 机制。 </p>
<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中 的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简 单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制。 </p>
<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个  modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出 异常，终止遍历。 </p>
<p>解决办法： </p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上 synchronized。 </li>
<li>使用CopyOnWriteArrayList来替换ArrayList</li>
</ol>
<h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个 只读集合，这样改变集合的任何操作都会抛出 Java. lang.  UnsupportedOperationException 异常。 示例代码如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">list. add(&quot;x&quot;); </span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list); </span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错 </span><br><span class="line">System. out. println(list. size()); </span><br></pre></td></tr></table></figure>

<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><p>Iterator 使用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	List&lt;String&gt; list = new ArrayList</span><br><span class="line">2	Iterator&lt;String&gt; it = list. iterator</span><br><span class="line">3	while(it. hasNext())&#123;</span><br><span class="line">4	String obj = it. next();</span><br><span class="line">5	System. out. println(obj);</span><br><span class="line">6	&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历</p>
<p>的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">2	while(it.hasNext())&#123;</span><br><span class="line">3	*// do something*</span><br><span class="line">4	it.remove();5	&#125;</span><br></pre></td></tr></table></figure>

<p>一种  常见的错误代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	for(Integer i : list)&#123;</span><br><span class="line">2	list.remove(i)</span><br><span class="line">3	&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>
<h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元 素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h3 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什-么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什-么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什 么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什 么？Java 中 List 遍历的最佳实践是什么？</h3><h3 id="遍历方式有以下几种："><a href="#遍历方式有以下几种：" class="headerlink" title="遍历方式有以下几种："></a>遍历方式有以下几种：</h3><ol>
<li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读 取每一个位置的元素，当读取到后一个元素后停止。 </p>
</li>
<li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏 蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支 持了 Iterator 模式。 </p>
</li>
<li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使 用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺 点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替 换。</p>
</li>
</ol>
<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标 记 List 实现是否支持 Random Access。</p>
<ul>
<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读 取元素的平均时间复杂度为 O(1)，如ArrayList。 </li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。 推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议 用 Iterator 或 foreach 遍历。</li>
</ul>
<h3 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h3><p>ArrayList的优点如下：</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>
</ul>
<p>ArrayList 的缺点如下：</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。         </li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>
</ul>
<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<h3 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换。</p>
<p>List 转数组：使用 List 自带的 toArray() 方法。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	// list to array</span><br><span class="line">2	List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">3	list.add(&quot;123&quot;);</span><br><span class="line">4	list.add(&quot;456&quot;);</span><br><span class="line">5	list.toArray();</span><br><span class="line">6</span><br><span class="line">7	// array to list</span><br><span class="line">8	String[] array = new String[]&#123;&quot;123&quot;,&quot;456&quot;&#125;;</span><br><span class="line">9	Arrays.asList(array);</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。 </li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p>补充：数据结构基础之双向链表</p>
<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>
<p>​          线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 </p>
<p>ArrayList 是非线程安全的。</p>
<p>性能：ArrayList 在性能方面要优于 Vector。</p>
<p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 </p>
<p>Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对</p>
<p>象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h3><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组</p>
<p>元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>
<p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector是线程安全容器，但性能上较ArrayList差。</p>
<p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList插入速度较快。</p>
<h3 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h3><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 </p>
<p>synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">2	synchronizedList.add(&quot;aaa&quot;);</span><br><span class="line">3	synchronizedList.add(&quot;bbb&quot;);</span><br><span class="line">4</span><br><span class="line">5	for (int i = 0; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">6	System.out.println(synchronizedList.get(i));</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？-ArrayList-中的数组定义如下："><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？-ArrayList-中的数组定义如下：" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？ ArrayList 中的数组定义如下："></a>为什么 ArrayList 的 elementData 加上 transient 修饰？ ArrayList 中的数组定义如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 private transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>再看一下 ArrayList 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">2	implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列</p>
<p>化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOE xception&#123; </span><br><span class="line">2  *// Write out element count, and any hidden stuff* </span><br><span class="line">3  int expectedModCount = modCount; </span><br><span class="line">4  s.defaultWriteObject(); </span><br><span class="line">5  *// Write out array length* </span><br><span class="line">6  s.writeInt(elementData.length); </span><br><span class="line">7  *// Write out all elements in the proper order.* </span><br><span class="line">8  for (int i=0; i&lt;size; i++) </span><br><span class="line">9  s.writeObject(elementData[i]); </span><br><span class="line">10  if (modCount != expectedModCount) &#123; </span><br><span class="line">11  throw new ConcurrentModificationException();</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><p>List , Set 都是继承自Collection 接口</p>
<p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、</p>
<p>LinkedList 和 Vector。</p>
<p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 </p>
<p>HashSet、LinkedHashSet 以及 TreeSet。</p>
<p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
<p>Set和List对比</p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</p>
<p>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，</p>
<p>HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，</p>
<p>HashSet 不允许重复的值。</p>
<h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p>
<p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p>
<p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为 HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的</p>
<p>V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较 hashcode 再比较equals ）。</p>
<p>以下是HashSet 部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1	private static final Object PRESENT = new Object();</span><br><span class="line">2	private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">3</span><br><span class="line">4	public HashSet() &#123;</span><br><span class="line">&lt;&gt;</span><br><span class="line">5	map = new HashMap ();</span><br><span class="line">6	&#125;</span><br><span class="line">7</span><br><span class="line">8	public boolean add(E e) &#123;</span><br><span class="line">9	// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="line">10	return map.put(e, PRESENT)==null;</span><br><span class="line">11	&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode（）与equals（）的相关规定：</p>
<ol>
<li><p>如果两个对象相等，则hashcode一定也是相同的</p>
</li>
<li><p>两个对象相等,对两个equals方法返回true</p>
</li>
<li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
</li>
<li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p>
</li>
<li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
</li>
</ol>
<p>&#x3D;&#x3D;与equals的区别</p>
<ol>
<li><p>&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</p>
</li>
<li><p>&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较3.&#x3D;&#x3D; 指引用是否相同 equals()指的是值是否相同</p>
</li>
</ol>
<h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了Map接口</td>
<td>实现了Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用  put（）向  map中添加元素</td>
<td>调用  add（）  方法向Set  中添加元素</td>
</tr>
<tr>
<td>HashMap  使用键  （Key）计算  Hashcode</td>
<td>HashSet 使用成员对象来计  算  hashcode 值，对于两个对象  来说  hashcode 可能相  同，所以  equals()方法用来判断对象的相等性，如果两个对象不同的话，那  么返回  false</td>
</tr>
<tr>
<td>HashMap 相对于  HashSet 较快，因为它是使用唯一的键获取对象</td>
<td>HashSet 较  HashMap  来说比较慢</td>
</tr>
</tbody></table>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h4 id="BlockingQueue是什么？"><a href="#BlockingQueue是什么？" class="headerlink" title="BlockingQueue是什么？"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中 BlockingQueue的实现，比如ArrayBlockingQueue、</p>
<p>LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。在 Queue 中 poll()和 remove()有什么区别？</p>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">2	queue. offer(&quot;string&quot;); // add</span><br><span class="line">3	System. out. println(queue. poll());</span><br><span class="line">4	System. out. println(queue. remove());</span><br><span class="line">5	System. out. println(queue. size());</span><br></pre></td></tr></table></figure>

<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h3 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap的数据结构： 在Java编程语言中， 基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li><p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相</p>
</li>
</ol>
<p>同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value 放入链表中</p>
<ol start="3">
<li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个</p>
<p>之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p>
<h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</p>
<h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109162525820.png" alt="jdk1.7中HashMap数据结构"></p>
<h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image001.jpg" alt="jdk1.8中HashMap数据结构"></p>
<h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p>
<ol>
<li><p>resize 扩容优化</p>
</li>
<li><p>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</p>
</li>
<li><p>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：  inflateTab  le()</td>
<td>直接集成到了扩容  函数  resize()中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理   &#x3D; 9次扰动   &#x3D; 4次位运算 + 5次异或运算</td>
<td>扰动处理   &#x3D; 2次扰动   &#x3D; 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据 的规则</td>
<td>无冲突 时，存放 数组；冲 突时，存 放链表</td>
<td>无冲突时，存放 数组；冲 突 &amp; 链表 长度 &lt; 8：存放单 链表；冲 突 &amp; 链表 长度 &gt; 8：树化并 存放红黑 树</td>
</tr>
<tr>
<td>插入数据 方式</td>
<td>头插法 （先讲原 位置的数 据移到后1 位，再插 入数据到 该位置）</td>
<td>尾插法 （直接插 入到链表 尾部&#x2F;红黑 树）</td>
</tr>
<tr>
<td>扩容后存 储位置的 计算方式</td>
<td>全部按照 原来方法 进行计算 （即 hashCode -&gt;&gt; 扰动 函数 -&gt;&gt; (h&amp;lengt h-1)）</td>
<td>按照扩容 后的规律 计算（即 扩容后的 位置&#x3D;原位 置 or 原位 置 + 旧容 量）</td>
</tr>
</tbody></table>
<h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高</p>
<p>16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是</p>
<p>2的幂，计算下标index &#x3D; (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且</p>
<p>JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>
<p>putVal方法执行流程图</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109162901394.png" alt="image-20201109162901394"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">1 public V put(K key, V value) &#123;</span><br><span class="line">2 return putVal(hash(key), key, value, false, true);</span><br><span class="line">3 &#125;</span><br><span class="line">4</span><br><span class="line">5 static final int hash(Object key) &#123;</span><br><span class="line">6 int h;</span><br><span class="line">7 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 //实现Map.put和相关方法</span><br><span class="line">11 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">12 boolean evict) &#123;</span><br><span class="line">13 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">14 // 步骤①：tab为空则创建</span><br><span class="line">15 // table未初始化或者长度为0，进行扩容</span><br><span class="line">16 if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">17 n = (tab = resize()).length;</span><br><span class="line">18 // 步骤②：计算index，并对null做处理</span><br><span class="line">19 // (n ‐ 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这</span><br><span class="line">个结点是放在数组中)</span><br><span class="line">20 if ((p = tab[i = (n ‐ 1) &amp; hash]) == null)</span><br><span class="line">21 tab[i] = newNode(hash, key, value, null);</span><br><span class="line">22 // 桶中已经存在元素</span><br><span class="line">23 else &#123;</span><br><span class="line">24 Node&lt;K,V&gt; e; K k;</span><br><span class="line">25 // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">26 // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">27 if (p.hash == hash &amp;&amp;</span><br><span class="line">28 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">29 // 将第一个元素赋值给e，用e来记录</span><br><span class="line">30 e = p;</span><br><span class="line">31 // 步骤④：判断该链为红黑树</span><br><span class="line">32 // hash值不相等，即key不相等；为红黑树结点</span><br><span class="line">33 // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可</span><br><span class="line">能为null</span><br><span class="line">34 else if (p instanceof TreeNode)</span><br><span class="line">35 // 放入树中</span><br><span class="line">36 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">37 // 步骤⑤：该链为链表</span><br><span class="line">38 // 为链表结点</span><br><span class="line">39 else &#123;</span><br><span class="line">40 // 在链表最末插入结点</span><br><span class="line">41 for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">42 // 到达链表的尾部</span><br><span class="line">43</span><br><span class="line">44 //判断该链表尾部指针是不是空的</span><br><span class="line">45 if ((e = p.next) == null) &#123;</span><br><span class="line">46 // 在尾部插入新结点</span><br><span class="line">47 p.next = newNode(hash, key, value, null);</span><br><span class="line">48 //判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br><span class="line">49 if (binCount &gt;= TREEIFY_THRESHOLD ‐ 1) // ‐1 for 1st</span><br><span class="line">50 //链表结构转树形结构</span><br><span class="line">51 treeifyBin(tab, hash);</span><br><span class="line">52 // 跳出循环</span><br><span class="line">53 break;</span><br><span class="line">54 &#125;</span><br><span class="line">55 // 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">56 if (e.hash == hash &amp;&amp;</span><br><span class="line">57 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">58 // 相等，跳出循环</span><br><span class="line">59 break;</span><br><span class="line">60 // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br><span class="line">61 p = e;</span><br><span class="line">62 &#125;</span><br><span class="line">63 &#125;</span><br><span class="line">64 //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的val</span><br><span class="line">ue这个值</span><br><span class="line">65 if (e != null) &#123;</span><br><span class="line">66 // 记录e的value</span><br><span class="line">67 V oldValue = e.value;</span><br><span class="line">68 // onlyIfAbsent为false或者旧值为null</span><br><span class="line">69 if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">70 //用新值替换旧值</span><br><span class="line">71 e.value = value;</span><br><span class="line">72 // 访问后回调</span><br><span class="line">73 afterNodeAccess(e);</span><br><span class="line">74 // 返回旧值</span><br><span class="line">75 return oldValue;</span><br><span class="line">76 &#125;</span><br><span class="line">77 &#125;</span><br><span class="line">78 // 结构性修改</span><br><span class="line">79 ++modCount;</span><br><span class="line">80 // 步骤⑥：超过最大容量就扩容</span><br><span class="line">81 // 实际大小大于阈值则扩容</span><br><span class="line">82 if (++size &gt; threshold)</span><br><span class="line">83 resize();</span><br><span class="line">84 // 插入后回调</span><br><span class="line">85 afterNodeInsertion(evict);</span><br><span class="line">86 return null;</span><br><span class="line">87 &#125;</span><br></pre></td></tr></table></figure>

<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； </p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向</p>
<p>④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； </p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了 大容量threshold，如果超过，进行扩容。</p>
<h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>
<p>②.每次扩展的时候，都是扩展2倍；</p>
<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1 final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">2 Node&lt;K,V&gt;[] oldTab = table;//oldTab指向hash桶数组</span><br><span class="line">3 int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">4 int oldThr = threshold;</span><br><span class="line">5 int newCap, newThr = 0;</span><br><span class="line">6 if (oldCap &gt; 0) &#123;//如果oldCap不为空的话，就是hash桶数组不为空</span><br><span class="line">7 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//如果大于最大容量了，就赋值为整数最大的阀</span><br><span class="line">值</span><br><span class="line">8 threshold = Integer.MAX_VALUE;</span><br><span class="line">9 return oldTab;//返回</span><br><span class="line">10 &#125;//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br><span class="line">11 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">12 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">13 newThr = oldThr &lt;&lt; 1; // double threshold 双倍扩容阀值threshold</span><br><span class="line">14 &#125;</span><br><span class="line">15 // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初</span><br><span class="line">始化成最小2的n次幂</span><br><span class="line">16 // 直接将该值赋给新的容量</span><br><span class="line">17 else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">18 newCap = oldThr;</span><br><span class="line">19 // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br><span class="line">20 else &#123; // zero initial threshold signifies using defaults</span><br><span class="line">21 newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">22 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">23 &#125;</span><br><span class="line">24 // 新的threshold = 新的cap * 0.75</span><br><span class="line">25 if (newThr == 0) &#123;</span><br><span class="line">26 float ft = (float)newCap * loadFactor;</span><br><span class="line">27 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">28 (int)ft : Integer.MAX_VALUE);</span><br><span class="line">29 &#125;</span><br><span class="line">30 threshold = newThr;</span><br><span class="line">31 // 计算出新的数组长度后赋给当前成员变量table</span><br><span class="line">32 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">33 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建hash桶数组</span><br><span class="line">34 table = newTab;//将新数组的值复制给旧的hash桶数组</span><br><span class="line">35 // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素</span><br><span class="line">重排逻辑，使其均匀的分散</span><br><span class="line">36 if (oldTab != null) &#123;</span><br><span class="line">37 // 遍历新数组的所有桶下标</span><br><span class="line">38 for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">39 Node&lt;K,V&gt; e;</span><br><span class="line">40 if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">41 // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br><span class="line">42 oldTab[j] = null;</span><br><span class="line">43 // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br><span class="line">44 if (e.next == null)</span><br><span class="line">45 // 用同样的hash映射算法把该元素加入新的数组</span><br><span class="line">46 newTab[e.hash &amp; (newCap ‐ 1)] = e;</span><br><span class="line">47 // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br><span class="line">48 else if (e instanceof TreeNode)</span><br><span class="line">49 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">50 // e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br><span class="line">51 else &#123; // preserve order</span><br><span class="line">52 // loHead,loTail 代表扩容后不用变换下标，见注1</span><br><span class="line">53 Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">54 // hiHead,hiTail 代表扩容后变换下标，见注1</span><br><span class="line">55 Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">56 Node&lt;K,V&gt; next;</span><br><span class="line">57 // 遍历链表</span><br><span class="line">58 do &#123;</span><br><span class="line">59 next = e.next;</span><br><span class="line">60 if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">61 if (loTail == null)</span><br><span class="line">62 // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br><span class="line">63 // 代表下标保持不变的链表的头元素</span><br><span class="line">64 loHead = e;</span><br><span class="line">65 else</span><br><span class="line">66 // loTail.next指向当前e</span><br><span class="line">67 loTail.next = e;</span><br><span class="line">68 // loTail指向当前的元素e</span><br><span class="line">69 // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素</span><br><span class="line">时，</span><br><span class="line">70 // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br><span class="line">71 // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br><span class="line">72 loTail = e;</span><br><span class="line">73 &#125;</span><br><span class="line">74 else &#123;</span><br><span class="line">75 if (hiTail == null)</span><br><span class="line">76 // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br><span class="line">77 hiHead = e;</span><br><span class="line">78 else</span><br><span class="line">79 hiTail.next = e;</span><br><span class="line">80 hiTail = e;</span><br><span class="line">81 &#125;</span><br><span class="line">82 &#125; while ((e = next) != null);</span><br><span class="line">83 // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br><span class="line">84 if (loTail != null) &#123;</span><br><span class="line">85 loTail.next = null;</span><br><span class="line">86 newTab[j] = loHead;</span><br><span class="line">87 &#125;</span><br><span class="line">88 if (hiTail != null) &#123;</span><br><span class="line">89 hiTail.next = null;</span><br><span class="line">90 newTab[j + oldCap] = hiHead;</span><br><span class="line">91 &#125;</span><br><span class="line">92 &#125;</span><br><span class="line">93 &#125;</span><br><span class="line">94 &#125;</span><br><span class="line">95 &#125;</span><br><span class="line">96 return newTab;</span><br><span class="line">97 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；什么是哈希？</p>
<p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p>
<h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
<h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109163448750.png" alt="image-20201109163448750"></p>
<p>这样我们就可以将拥有相同哈希值的对象(img)组织成一个链表放在hash值所对应的 bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	static final int hash(Object key) &#123;</span><br><span class="line">2	int h;</span><br><span class="line">3	return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p>
<h4 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h4><p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109163526813.png" alt="image-20201109163526813"></p>
<p>通过上面的链地址法（使用散列表）和扰(img)动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个 bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；总结</p>
<p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>
<ol>
<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>
<li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li>
<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li>
</ol>
<h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：  如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p>
<p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p>
<p>用户自定义 Key 类 佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<h3 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<p>\1.   都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同的情况</p>
<p>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</p>
<h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写hashCode()和equals()方法</p>
<p>\1.  重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p>
<p>\2.  重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对</p>
<p>于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p>
<h3 id="HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？</h3><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到 大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<p>那怎么解决呢？</p>
<p>\1. HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
<p>\2. 在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算</p>
<p>（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取</p>
<p>余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;</p>
<p>(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题</p>
<h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操</p>
<p>作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 </p>
<p>hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p>那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，  终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的</p>
<h3 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h3><ol>
<li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；</li>
</ol>
<p>HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
<ol start="2">
<li><p>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在</p>
</li>
</ol>
<p>HashTable 中 put 进的键值只要有一个 null，直接抛</p>
<p>NullPointerException。</p>
<ol start="4">
<li><p>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2 的幂次方。</p>
</li>
<li><p>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
<li><p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
</li>
</ol>
<h3 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是 好的选择。然</p>
<p>而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol>
<li><p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized 锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启了一种全新的方式实现,利用CAS算法。）</p>
</li>
<li><p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>
</li>
</ol>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<p> 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组</p>
<p>+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑</p>
<p>二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p>​           实现线程安全的方式（重要）： ① 在JDK1.7的时候，</p>
<p>ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16</p>
<p>倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 </p>
<p>Node 数组+链表+红黑树的数据结构来实现，并发控制使用 </p>
<p>synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还</p>
<p>能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② </p>
<p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<p>两者的对比图：</p>
<p>HashTable:</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165808848.png" alt="image-20201109165808848"></p>
<p>JDK1.7的ConcurrentHashMap：</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165820466.png" alt="image-20201109165820466"></p>
<p>JDK1.8的ConcurrentHashMap（TreeBi(img)n: 红黑二叉树节点 Node: 链表节点）：</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165840129.png" alt="image-20201109165840129"></p>
<p>答：ConcurrentHashMap 结合了 Hash(img)Map 和 HashTable 二者的优势。 HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<h3 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p>JDK1.7</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实</p>
<p>现，结构如下：</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165916185.png" alt="image-20201109165916185"></p>
<ol>
<li><p>该类包含两个静态内部类 HashE(img)ntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p>
</li>
<li><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p>
</li>
</ol>
<p>JDK1.8</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N 倍。</p>
<p>结构如下：</p>
<p><img src="/02-Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109165939912.png" alt="image-20201109165939912"></p>
<p>看插入元素过程（建议去看看源码）：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	else if ((f = tabAt(tab, i = (n ‐ 1) &amp; hash)) == null) &#123;</span><br><span class="line">2	if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">3	break; // no lock when adding to empty bin</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加</p>
<p>synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 if (fh &gt;= 0) &#123; </span><br><span class="line">2 binCount = 1;</span><br><span class="line">3	for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">4	K ek;</span><br><span class="line">5	if (e.hash == hash &amp;&amp;</span><br><span class="line">6	((ek = e.key) == key ||</span><br><span class="line">7	(ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">8	oldVal = e.val;</span><br><span class="line">9	if (!onlyIfAbsent)</span><br><span class="line">10	e.val = value;</span><br><span class="line">11	break;</span><br><span class="line">12	&#125;</span><br><span class="line">13	Node&lt;K,V&gt; pred = e;</span><br><span class="line">14	if ((e = e.next) == null) &#123;</span><br><span class="line">15	pred.next = new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">16	break;</span><br><span class="line">17	&#125;</span><br><span class="line">18	&#125;</span><br><span class="line">19	&#125;</span><br></pre></td></tr></table></figure>

<p>\1.    如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过 putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
<p>\2.    如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数 baseCount；</p>
<h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或 compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>
<h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了 大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p>
<p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>
<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:20" itemprop="dateModified" datetime="2021-03-03T13:51:20+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h2><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并 终得到结果的过程。 </p>
<p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、 和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一 步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编 程。 </p>
<h2 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h2><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易 用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对 象理论，允许程序员以优雅的思维方式进行复杂的编程 。 </p>
<h2 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h2><ul>
<li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使 用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java  ME提供基础。 </li>
<li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器 端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、 管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented  architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名 为 JakartaEE </li>
<li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视 机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用 户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序 的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可 以利用每个设备的本机功能。</li>
</ul>
<h2 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h2><p>JVM </p>
<p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平 台有自己的虚拟机，因此Java语言可以实现跨平台。 </p>
<p>JRE </p>
<p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数 据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p> 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK</p>
<p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等 </p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106172325865.png" alt="image-20201106172325865"></p>
<h2 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上 运行。 </p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚拟机，该系统就可以运行java程序。</p>
<h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><p>简单易学（Java语言的语法与C语言和C++语言很接近） </p>
<p>面向对象（封装，继承，多态） </p>
<p>平台无关性（Java虚拟机实现平台无关性） </p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） </p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任） </p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） </p>
<p>安全性</p>
<h2 id="什么是字节码？采用字节码的大好处是什么"><a href="#什么是字节码？采用字节码的大好处是什么" class="headerlink" title="什么是字节码？采用字节码的大好处是什么"></a>什么是字节码？采用字节码的大好处是什么</h2><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文 件），它不面向任何特定的处理器，只面向虚拟机。 </p>
<p><strong>采用字节码的好处：</strong> </p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效， 而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可 在多种不同的计算机上运行。</p>
<p><strong>先看下java中的编译器和解释器：</strong> </p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程 序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节 码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每 一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译 器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运 行，这就是上面提到的Java的特点的编译与解释并存的解释。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java源代码‐‐‐‐&gt;编译器‐‐‐‐&gt;jvm可执行的Java字节码(即虚拟指令)‐‐‐‐&gt;jvm‐‐‐‐&gt;jvm中 解释器‐‐‐‐‐&gt;机器可执行的二进制机器码‐‐‐‐&gt;程序运行。</span><br></pre></td></tr></table></figure>

<h2 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主 类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统 类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序 的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h2 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h2><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main 方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏 览器这点跟flash的小游戏类似。</p>
<h2 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h2><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！ 没办法！！！就算没学过C++，也要记下来！ </p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态 </li>
<li>Java不提供指针来直接访问内存，程序内存更加安全 </li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是 接口可以多继承。 </li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h2 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h2><ol>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一 次； </li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是 OpenJDK的一个实现，并不是完全开源的； </li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎 相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企 业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳 定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程 序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； </li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的 性能； </li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过 更新到最新版本获得支持来获取最新版本； </li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li>
</ol>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类 型，在内存中分配了不同大小的内存空间。 </p>
<p><strong>分类</strong>：</p>
<p>基本数据类型 </p>
<ul>
<li>​	数值型<br>​		整数类型(byte,short,int,long)<br>​		浮点类型(float,double) </li>
<li>​	字符型(char) </li>
<li>​	布尔型(boolean)</li>
</ul>
<p>引用数据类型 </p>
<ul>
<li>​	类(class) </li>
<li>​	接口(interface) </li>
<li>​	数组([])</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201020121024259.png" alt="image-20201020121024259"></p>
<h3 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否-能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否-能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否 能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否 能作用在 String 上</h3><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从  Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7  开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版 本中都是不可以的</p>
<h3 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h3><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次 方）。</p>
<h3 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少</h3><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍 五入的原理是在参数上加 0.5 然后进行下取整。 </p>
<h3 id="loat-f-x3D-3-4-是否正确"><a href="#loat-f-x3D-3-4-是否正确" class="headerlink" title="loat f&#x3D;3.4;是否正确"></a>loat f&#x3D;3.4;是否正确</h3><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转 换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p>
<h3 id="short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗"><a href="#short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</h3><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是  int型，需要强制转换类型才能赋值给 short 型。 而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1  + 1);其中有隐含的强制类型转换。 </p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h3><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一 个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h3><h4 id="定义：用于解释说明程序的文字"><a href="#定义：用于解释说明程序的文字" class="headerlink" title="定义：用于解释说明程序的文字"></a>定义：用于解释说明程序的文字</h4><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>单行注释 格式： &#x2F;&#x2F; 注释文字 </li>
<li>多行注释 格式： &#x2F;* 注释文字 *&#x2F; </li>
<li>文档注释 格式：&#x2F;** 注释文字 *&#x2F;</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利 于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生 目标代码，注释的部分不会对程序的执行结果产生任何影响。 注意事项：多行和文档注释都不能嵌套使用。 访问修饰符</p>
<h3 id="访问修饰符-public-private-protected-以及不写（默认）时的-区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的-区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的 区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的 区别</h3><p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访 问。Java 支持 4 种不同的访问权限。 </p>
<p><strong>分类</strong>：</p>
<ul>
<li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部 类） </li>
<li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用 任何修饰符。使用对象：类、接口、变量、方法。 </li>
<li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意： 不能修饰类（外部类）。 </li>
<li>public : 对所有类可见。使用对象：类、接口、变量、方法</li>
</ul>
<p><strong>访问修饰符图</strong></p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201020130327174.png" alt="image-20201020130327174"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。 </p>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要 求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称<br>为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直 接短路掉，不会进行运算。 </p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 </p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h3><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<h3 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h3><p>用于修饰类、属性和方法；</p>
<ul>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<h3 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h3><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li>
</ul>
<h3 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h3><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指<br>针。</p>
<p>this的用法在java中大体可以分为3种：</p>
<p>1.普通的直接引用，this相当于是指向当前对象本身。</p>
<p>2.形参与成员名字重名，用this来区分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 public Person(String name, int age) &#123;</span><br><span class="line">2 this.name = name;</span><br><span class="line">3 this.age = age;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>3.引用本类的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 class Person&#123;</span><br><span class="line">2 private String name;</span><br><span class="line">3 private int age;</span><br><span class="line">4</span><br><span class="line">5 public Person() &#123;</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 public Person(String name) &#123;</span><br><span class="line">9 this.name = name;</span><br><span class="line">10 &#125;</span><br><span class="line">11 public Person(String name, int age) &#123;</span><br><span class="line">12 this(name);</span><br><span class="line">13 this.age = age;</span><br><span class="line">14 &#125;</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h3><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离<br>自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<p>1.普通的直接引用<br>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用<br>super.xxx来引用父类的成员。<br>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区<br>分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 class Person&#123;</span><br><span class="line">2 protected String name;</span><br><span class="line">3</span><br><span class="line">4 public Person(String name) &#123;</span><br><span class="line">5 this.name = name;</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 class Student extends Person&#123;</span><br><span class="line">11 private String name;</span><br><span class="line">12</span><br><span class="line">13 public Student(String name, String name1) &#123;</span><br><span class="line">14 super(name);</span><br><span class="line">15 this.name = name1;</span><br><span class="line">16 &#125;</span><br><span class="line">17</span><br><span class="line">18 public void getInfo()&#123;</span><br><span class="line">19 System.out.println(this.name); //Child</span><br><span class="line">20 System.out.println(super.name); //Father</span><br><span class="line">21 &#125;</span><br><span class="line">22</span><br><span class="line">23 &#125;</span><br><span class="line">24</span><br><span class="line">25 public class Test &#123;</span><br><span class="line">26 public static void main(String[] args) &#123;</span><br><span class="line">27 Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);</span><br><span class="line">28 s1.getInfo();</span><br><span class="line">29</span><br><span class="line">30 &#125;</span><br><span class="line">31 &#125;</span><br></pre></td></tr></table></figure>

<p>3.引用父类构造函数</p>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><ul>
<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：<br>static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
<h3 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</p>
<p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候<br>执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h3 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h3><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</p>
<blockquote>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p>
</blockquote>
<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p>
<p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<h3 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h3><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p>
<p>因此比较常见的static应用场景有：</p>
<blockquote>
<p>1、修饰成员变量<br>2、修饰成员方法<br>3、静态代码块<br>4、修饰类【只能修饰内部类也就是静态内部类】<br>5、静态导包</p>
</blockquote>
<h3 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h3><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<h3 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 ok:</span><br><span class="line">3 for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">4 for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">5 System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">6 if (j == 5) &#123;</span><br><span class="line">7 break ok;</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p>
<h4 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h4><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低<br>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步<br>一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p>**面向对象的特征主要有以下几个方面： **</p>
<p><strong>抽象：</strong>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行 为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是 什么。 </p>
<ul>
<li><p>封装 : 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如 果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没 有提供给外界访问的方法，那么这个类也没有什么意义了。 </p>
</li>
<li><p>继承 : 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新 的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用 继承我们能够非常方便地复用以前的代码。</p>
<p>​	关于继承如下 3 点请记住：</p>
<p>​		1.子类拥有父类非 private 的属性和方法。</p>
<p>​		2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 </p>
<p>​		3.子类可以用自己的方式实现父类的方法。 </p>
</li>
<li><p>多态 : 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出 的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到 底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的 方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。</p>
</li>
</ul>
<p>其中Java 面向对象编程三大特性：封装 继承 多态</p>
<p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便 于使用，提高复用性和安全性。 </p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以 增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通 过使用继承可以提高代码复用性。继承是多态的前提。 </p>
<p>**关于继承如下 3 点请记住： **</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。 </li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 </li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提 高了程序的拓展性。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重 写（override）实现的是运行时的多态性（也称为后绑定）。 </p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是 哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对 象精髓的东西，要实现多态需要做两件事： </p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据 子类对象的不同而表现出不同的行为）。</li>
</ul>
<h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出 的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒 底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的 方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这 样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而 导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时 所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的 重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不 同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来 实现的，也就是我们所说的多态性</p>
<p><strong>多态的实现</strong> </p>
<p>Java实现多态有三个必要条件：继承、重写、向上转型。 </p>
<p>继承：在多态中必须存在有继承关系的子类和父类。 </p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的 方法。 </p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具 备技能调用父类的方法和子类的方法。 </p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现 代码处理不同的对象，从而达到执行不同的行为。 </p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类 对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但 是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 </p>
<h2 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h2><ul>
<li>单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。<br>开放封闭原则OCP(Open－Close Principle)</li>
<li>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，<br>一万个不乐意。</li>
<li>里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li>
<li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li>
<li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有<br>打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的<br>多。</li>
</ul>
<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><h2 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h2><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间 的差异。 </p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。 接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则： </p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量 少用抽象类。 </li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用 的功能。</li>
</ul>
<h3 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h3><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。 </li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承， 这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h3 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h3><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实 例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根 绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以 用n条绳子系住一个气球）</p>
<h1 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h1><h2 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h2><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上 讲，变量其实是内存中的一小块区域 成员变量：方法外部，类内部定义的变量 局部变量：类的方法中的变量。 成员变量和局部变量的区别</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>成员变量：针对整个类有效。 </p>
<p>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
<h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。 </p>
<p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>成员变量：随着对象的创建而存在，随着对象的消失而消失 </p>
<p>局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>成员变量：有默认初始值。 </p>
<p>局部变量：没有默认初始值，使用前必须赋值。 </p>
<p>使用原则 </p>
<p>在使用变量时需要遵循的原则为：就近原则 首先在局部范围找，有就使用；接着在成员位置找。</p>
<h2 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h2><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构 造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了 有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定 的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构 造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h2 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其-目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其-目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其 目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其 目的是？</h2><p>帮助子类做初始化工作。</p>
<h2 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，-改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，-改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法， 改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法， 改程序能正确执行吗？为什么？</h2><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构 造方法也会有默认的不带参数的构造方法。</p>
<h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><p>名字与类名相同； </p>
<p>没有返回值，但不能用void声明构造函数； </p>
<p>生成类的对象时自动执行，无需调用。</p>
<h2 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h2><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会 有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。 </p>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量 是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h2 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h2><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有 的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始 化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副 本，各个对象拥有的副本互不影响。</p>
<p> 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><p>静态方法和实例方法的区别主要体现在两个方面： </p>
<ol>
<li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使 用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调 用静态方法可以无需创建对象。 </p>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量 和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此 限制</p>
</li>
</ol>
<h2 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静 态变量，也不可以访问非静态变量成员。</p>
<h2 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提 是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的 操作！</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h2><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内 部类本身就是类的一个属性，与其他属性定义方式一致。 </p>
<h2 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h2><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类。</strong> </p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private static int radius = 1;</span><br><span class="line">4</span><br><span class="line">5 static class StaticInner &#123;</span><br><span class="line">6 public void visit() &#123;</span><br><span class="line">7 System.out.println(&quot;visit outer static variable:&quot; + radius);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量； 静态内部类的创建方式，new 外部类.静态内部类()，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">2 inner.visit</span><br></pre></td></tr></table></figure>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private static int radius = 1;</span><br><span class="line">4 private int count =2;</span><br><span class="line">5</span><br><span class="line">6 class Inner &#123;</span><br><span class="line">7 public void visit() &#123;</span><br><span class="line">8 System.out.println(&quot;visit outer static variable:&quot; + radius);</span><br><span class="line">9 System.out.println(&quot;visit outer variable:&quot; + count);</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公 有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如 下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Outer outer = new Outer();</span><br><span class="line">2 Outer.Inner inner = outer.new Inner();</span><br><span class="line">3 inner.visit();</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private int out_a = 1;</span><br><span class="line">4 private static int STATIC_b = 2;</span><br><span class="line">5</span><br><span class="line">6 public void testFunctionClass()&#123;</span><br><span class="line">7 int inner_c =3;</span><br><span class="line">8 class Inner &#123;</span><br><span class="line">9 private void fun()&#123;</span><br><span class="line">10 System.out.println(out_a);</span><br><span class="line">11 System.out.println(STATIC_b);</span><br><span class="line">12 System.out.println(inner_c);</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15 Inner inner = new Inner();</span><br><span class="line">16 inner.fun();</span><br><span class="line">17 &#125;</span><br><span class="line">18 public static void testStaticFunctionClass()&#123;</span><br><span class="line">19 int d =3;</span><br><span class="line">20 class Inner &#123;</span><br><span class="line">21 private void fun()&#123;</span><br><span class="line">22 // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外</span><br><span class="line">部类的实例变量</span><br><span class="line">23 System.out.println(STATIC_b);</span><br><span class="line">24 System.out.println(d);</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br><span class="line">27 Inner inner = new Inner();</span><br><span class="line">28 inner.fun();</span><br><span class="line">29 &#125;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法 中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应 方法内，new 内部类()，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 public static void testStaticFunctionClass()&#123;</span><br><span class="line">2 class Inner &#123;</span><br><span class="line">3 &#125;</span><br><span class="line">4 Inner inner = new Inner();</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 private void test(final int i) &#123;</span><br><span class="line">4 new Service() &#123;</span><br><span class="line">5 public void method() &#123;</span><br><span class="line">6 for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">7 System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10 &#125;.method();</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br><span class="line">13 //匿名内部类必须继承或实现一个已有的接口</span><br><span class="line">14 interface Service&#123;</span><br><span class="line">15 void method();</span><br><span class="line">16 &#125;</span><br></pre></td></tr></table></figure>

<p>除了没有名字，匿名内部类还有以下特点： </p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。 </li>
<li>匿名内部类不能定义任何静态成员和静态方法。 </li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 </li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方 法。</li>
</ul>
<h4 id="匿名内部类创建方式："><a href="#匿名内部类创建方式：" class="headerlink" title="匿名内部类创建方式："></a>匿名内部类创建方式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 new 类/接口&#123;</span><br><span class="line">2 //匿名内部类实现部分</span><br><span class="line">3 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h2><p>我们为什么要使用内部类呢？因为它有以下优点： </p>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ </li>
<li>内部类不为同一包的其他类所见，具有很好的封装性； </li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。 </li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h2 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h2><ol>
<li><p>一些多算法场合 </p>
</li>
<li><p>解决一些非面向对象的语句块。 </p>
</li>
<li><p>适当使用内部类，使得代码更加灵活和富有扩展性。 </p>
</li>
<li><p>当某个类除了它的外部类，不再被其他的类使用时。</p>
</li>
</ol>
<h2 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须-要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须-要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须 要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须 要加上final？</h2><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？ 它内部原理是什么呢？ </p>
<p>先看这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2</span><br><span class="line">3 void outMethod()&#123;</span><br><span class="line">4 final int a =10;</span><br><span class="line">5 class Inner &#123;</span><br><span class="line">6 void innerMethod()&#123;</span><br><span class="line">7 System.out.println(a);</span><br><span class="line">8 &#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在 栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变 量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final， 可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。 </p>
<h2 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Outer &#123;</span><br><span class="line">2 private int age = 12;</span><br><span class="line">3</span><br><span class="line">4 class Inner &#123;</span><br><span class="line">5 private int age = 13;</span><br><span class="line">6 public void print() &#123;</span><br><span class="line">7 int age = 14;</span><br><span class="line">8 System.out.println(&quot;局部变量：&quot; + age);</span><br><span class="line">9 System.out.println(&quot;内部类变量：&quot; + this.age);</span><br><span class="line">10 System.out.println(&quot;外部类变量：&quot; + Outer.this.age);</span><br><span class="line">11 &#125;</span><br><span class="line">12 &#125;</span><br><span class="line">13</span><br><span class="line">14 public static void main(String[] args) &#123;</span><br><span class="line">15 Outer.Inner in = new Outer().new Inner();</span><br><span class="line">16 in.print();</span><br><span class="line">17 &#125;</span><br><span class="line">18</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 局部变量：14</span><br><span class="line">2 内部类变量：13</span><br><span class="line">3 外部类变量：12</span><br></pre></td></tr></table></figure>

<h1 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h1><h2 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h2><p>构造器不能被继承，因此不能被重写，但可以被重载。 </p>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能-否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能-否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能 否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能 否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态 性，而后者实现的是运行时的多态性。 </p>
<p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不 同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回 类型进行区分 </p>
<p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛 出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类 方法访问修饰符为private则子类中就不是重写。</p>
<h1 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h1><h2 id="x3D-x3D-和-equals-的区别是什么"><a href="#x3D-x3D-和-equals-的区别是什么" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h2><p>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同 一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址) </p>
<p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时， 等价于通过“&#x3D;&#x3D;”比较这两个对象。 </p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象 的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 </p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 public class test1 &#123;</span><br><span class="line">2 public static void main(String[] args) &#123;</span><br><span class="line">3 String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">4 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">5 String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">6 String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">7 if (aa == bb) // true</span><br><span class="line">8 System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">9 if (a == b) // false，非同一对象</span><br><span class="line">10 System.out.println(&quot;a==b&quot;);</span><br><span class="line">11 if (a.equals(b)) // true</span><br><span class="line">12 System.out.println(&quot;aEQb&quot;);</span><br><span class="line">13 if (42 == 42.0) &#123; // true</span><br><span class="line">14 System.out.println(&quot;true&quot;);</span><br><span class="line">15 &#125;</span><br><span class="line">16 &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>

<p>说明： </p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的 内存地址，而String的equals方法比较的是对象的值。 </li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要 创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建 一个String对象。</li>
</ul>
<h2 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h2><p>HashSet如何检查重复 </p>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？ </p>
<p>hashCode和equals方法的关系 </p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时 必须重写hashCode方法？”</p>
<h3 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整 数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。 </p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出 对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><h3 id="我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode："><a href="#我们以“HashSet-如何检查重复”为例子来说明为什么要有-hashCode：" class="headerlink" title="我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode："></a>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对 象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果 没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相 同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对 象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不 同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》 第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速 度。</p>
<h3 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h3><p>如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的</p>
<h3 id="因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖"><a href="#因此，equals-方法被覆盖过，则-hashCode-方法也必须被覆盖" class="headerlink" title="因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖"></a>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</h3><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 </p>
<p>hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指 向相同的数据）</p>
<h2 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h2><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的 内存地址是否相等。</p>
<h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><h2 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对-象的属性，并可返回变化后的结果，那么这里到底是值传递还是-引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对-象的属性，并可返回变化后的结果，那么这里到底是值传递还是-引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对 象的属性，并可返回变化后的结果，那么这里到底是值传递还是 引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对 象的属性，并可返回变化后的结果，那么这里到底是值传递还是 引用传递</h2><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一 个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被 调用过程中被改变，但对对象引用的改变是不会影响到调用者的 </p>
<h2 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术 语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用 （call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以 修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用 来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p> <strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的 一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong> </p>
<p>下面通过 3 个例子来给大家说明</p>
<p>example 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 int num1 = 10;</span><br><span class="line">3 int num2 = 20;</span><br><span class="line">4</span><br><span class="line">5 swap(num1, num2);</span><br><span class="line">6</span><br><span class="line">7 System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">8 System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br><span class="line">11 public static void swap(int a, int b) &#123;</span><br><span class="line">12 int temp = a;</span><br><span class="line">13 a = b;</span><br><span class="line">14 b = temp;</span><br><span class="line">15</span><br><span class="line">16 System.out.println(&quot;a = &quot; + a);</span><br><span class="line">17 System.out.println(&quot;b = &quot; + b);</span><br><span class="line">18 &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 a = 20</span><br><span class="line">2 b = 10</span><br><span class="line">3 num1 = 10</span><br><span class="line">4 num2 = 20</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190311218.png" alt="image-20201106190311218"></p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、 b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 </p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而 对象引用作为参数就不一样，请看 example2.</p>
<p>example 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 public static void main(String[] args) &#123;</span><br><span class="line">2 int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">3 System.out.println(arr[0]);</span><br><span class="line">4 change(arr);</span><br><span class="line">5 System.out.println(arr[0]);</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br><span class="line">8 public static void change(int[] array) &#123;</span><br><span class="line">9 // 将数组的第一个元素变为0</span><br><span class="line">10 array[0] = 0;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 0</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190416793.png" alt="image-20201106190416793"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向 的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象 上。 </p>
<p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件 难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时 引用同一个对象。</p>
<p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调 用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象 采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍 性，所以下面给出一个反例来详细地阐述一下这个问题。</p>
<p>example 3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Test &#123;</span><br><span class="line">2</span><br><span class="line">3 public static void main(String[] args) &#123;</span><br><span class="line">4 // TODO Auto‐generated method stub</span><br><span class="line">5 Student s1 = new Student(&quot;小张&quot;);</span><br><span class="line">6 Student s2 = new Student(&quot;小李&quot;);</span><br><span class="line">7 Test.swap(s1, s2);</span><br><span class="line">8 System.out.println(&quot;s1:&quot; + s1.getName());</span><br><span class="line">9 System.out.println(&quot;s2:&quot; + s2.getName());</span><br><span class="line">10 &#125;</span><br><span class="line">11</span><br><span class="line">12 public static void swap(Student x, Student y) &#123;</span><br><span class="line">13 Student temp = x;</span><br><span class="line">14 x = y;</span><br><span class="line">15 y = temp;</span><br><span class="line">16 System.out.println(&quot;x:&quot; + x.getName());</span><br><span class="line">17 System.out.println(&quot;y:&quot; + y.getName());</span><br><span class="line">18 &#125;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 x:小李</span><br><span class="line">2 y:小张</span><br><span class="line">3 s1:小张</span><br><span class="line">4 s2:小李</span><br></pre></td></tr></table></figure>

<p>解析： </p>
<p>交换之前：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190608690.png" alt="image-20201106190608690"></p>
<p>交换之后：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201106190619059.png" alt="image-20201106190619059"></p>
<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的 对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交 换的是这两个拷贝</p>
<p>总结</p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 </p>
<p>下面再总结一下Java中方法参数的使用情况： </p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》 </li>
<li>一个方法可以改变一个对象参数的状态。 </li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h2 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h2><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷 贝，也就是说传递后就互不相关了。 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引 用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说 传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h1 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h1><h2 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h2><ul>
<li>java.lang：这个是系统的基础类； </li>
<li>java.io：这里面是所有输入输出有关的类，比如文件操作等； </li>
<li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包； </li>
<li>java.net：这里面是与网络有关的类； </li>
<li>java.util：这个是系统辅助类，特别是集合类； </li>
<li>java.sql：这个是数据库操作的类。</li>
</ul>
<h2 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部 分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现 有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h2><p>按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼 此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类 中派生出来的。</p>
<ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符 输入流。 </li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输 出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109141513794.png" alt="image-20201109141513794"></p>
<p>IO­操作方式分类按操作对象分类结构图：</p>
<p><img src="/01-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109142101756.png" alt="image-20201109142101756"></p>
<h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h2><p>简答</p>
<ul>
<li><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>
</li>
<li><p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过<br>  Channel（通道）通讯，实现了多路复用。</p>
</li>
<li><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO<br>  ，异步 IO 的操作基于事件和回调机制。</p>
</li>
</ul>
<p>详细回答</p>
<ul>
<li><p>BIO (Blocking I&#x2F;O): 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
</li>
<li><p>NIO (New I&#x2F;O): NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的 N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
</li>
<li><p>AIO (Asynchronous I&#x2F;O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</li>
</ul>
<h2 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h2><ul>
<li>Files. exists()：检测文件路径是否存在。 </li>
<li>Files. createFile()：创建文件。 </li>
<li>Files. createDirectory()：创建文件夹。 </li>
<li>Files. delete()：删除一个文件或目录。 </li>
<li>Files. copy()：复制文件。 </li>
<li>Files. move()：移动文件。 </li>
<li>Files. size()：查看文件个数。 </li>
<li>Files. read()：读取文件。 </li>
<li>Files. write()：写入文件。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<p><strong>静态编译：</strong>在编译时确定类型，绑定对象</p>
<p><strong>动态编译：</strong>运行时确定类型，绑定对象</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能</p>
<p>比直接的java代码要慢很多。</p>
<h2 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h2><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制， 经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<h2 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h2><p>1.通过new对象实现反射机制 </p>
<p>2.通过路径实现反射机制 </p>
<p>3.通过类名实现反射机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1  public class Student &#123;</span><br><span class="line">2  private int id;</span><br><span class="line">3  String name;</span><br><span class="line">4  protected boolean sex;</span><br><span class="line">5  public float score;</span><br><span class="line">6  &#125;</span><br><span class="line">1   public class Get &#123;</span><br><span class="line">2   //获取反射机制三种方式</span><br><span class="line">3   public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">4   //方式一(通过建立对象)</span><br><span class="line">5   Student stu = new Student();</span><br><span class="line">6   Class classobj1 = stu.getClass();</span><br><span class="line">7   System.out.println(classobj1.getName());</span><br><span class="line">8   //方式二（所在通过路径‐相对路径）</span><br><span class="line">9   Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">10  System.out.println(classobj2.getName());</span><br><span class="line">11  //方式三（通过类名）</span><br><span class="line">12  Class classobj3 = Student.class;</span><br><span class="line">13  System.out.println(classobj3.getName());</span><br><span class="line">14  &#125;</span><br><span class="line">15  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程的面试题可以查看我的这篇文章重学TCP&#x2F;IP协议和三次握手四次挥手，内容不仅包括TCP&#x2F;IP协议和三次握手四次挥手的知识，还包括计算机网络</p>
<p>体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等，欢迎大家阅读。</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</p>
</li>
</ol>
<h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
<h3 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h3><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、 double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 </p>
<p>char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
<h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h3><ul>
<li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li>
<li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li>
<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>
</ul>
<h3 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h3><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  /** The value is used for character storage. */</span><br><span class="line"></span><br><span class="line">2  private final char value[];</span><br></pre></td></tr></table></figure>

<h3 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h3><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<ol>
<li>String不可变但不代表引用不可以变</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  String str = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">2  str = str + &quot; World&quot;;</span><br><span class="line"></span><br><span class="line">3  System.out.println(&quot;str=&quot; + str);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 str=Hello World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<ol start="2">
<li>通过反射是可以修改所谓的“不可变”对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1  // 创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br><span class="line"></span><br><span class="line">2  String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4 System.out.println(&quot;s = &quot; + s); // Hello World</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">6  // 获取String类中的value字段</span><br><span class="line"></span><br><span class="line">7  Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">9  // 改变value属性的访问权限</span><br><span class="line"></span><br><span class="line">10  valueFieldOfString.setAccessible(true);</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">12  // 获取s对象上的value属性的值</span><br><span class="line"></span><br><span class="line">13  char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">15  // 改变value所引用的数组中的第5个字符</span><br><span class="line"></span><br><span class="line">16  value[5] = &#x27;_&#x27;;</span><br><span class="line"></span><br><span class="line">17</span><br><span class="line"></span><br><span class="line">18 System.out.println(&quot;s = &quot; + s); // Hello_World</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  s = Hello World</span><br><span class="line"></span><br><span class="line">2  s = Hello_World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h3 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h3><p>String 类是 final 类，不可以被继承。</p>
<p>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。 String s &#x3D; new String(“xyz”);创建了几个字符串对象两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1	String str1 = &quot;hello&quot;; //str1指向静态区</span><br><span class="line">2	String str2 = new String(&quot;hello&quot;); //str2指向堆上的对象</span><br><span class="line">3	String str3 = &quot;hello&quot;;</span><br><span class="line">4	String str4 = new String(&quot;hello&quot;);</span><br><span class="line">5	System.out.println(str1.equals(str2)); //true</span><br><span class="line">6	System.out.println(str2.equals(str4)); //true</span><br><span class="line">7	System.out.println(str1 == str3); //true</span><br><span class="line">8	System.out.println(str1 == str2); //false</span><br><span class="line">9	System.out.println(str2 == str4); //false</span><br><span class="line">10	System.out.println(str2 == &quot;hello&quot;); //false</span><br><span class="line">11	str2 = str1;</span><br><span class="line">12	System.out.println(str2 == &quot;hello&quot;); //true</span><br></pre></td></tr></table></figure>

<p>如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	// StringBuffer reverse</span><br><span class="line">2	StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">3	stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">4	System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">5	// StringBuilder reverse</span><br><span class="line">6	StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">7	stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">8	System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure>

<h3 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h3><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。 JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p>
<h3 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h3><ul>
<li>indexOf()：返回指定字符的索引。 </li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。 </li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。 </li>
<li>toLowerCase()：将字符串转成小写字母。 </li>
<li>toUpperCase()：将字符串转成大写字符。 </li>
<li>substring()：截取字符串。 </li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h3 id="String和StringBuffer、StringBuilder的区别是什么？String-为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String-为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String 为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String 为什么是不可变的</h3><p>可变性</p>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以 string对象是不可变的。StringBuilder与StringBuffer都继承自</p>
<p>AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。线程安全性</p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>性能</p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操</p>
<p>作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结</p>
<p>如果要操作少量的数据用 &#x3D; String 单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder 多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p>
<h2 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h2><h2 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h2><p>自动装箱与拆箱</p>
<p>装箱：将基本类型用它们对应的引用类型包装起来；</p>
<h3 id="拆箱：将包装类型转换为基本数据类型；-int-和-Integer-有什么区别"><a href="#拆箱：将包装类型转换为基本数据类型；-int-和-Integer-有什么区别" class="headerlink" title="拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别"></a>拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别</h3><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，</p>
<p>Double</p>
<h3 id="Integer-a-x3D-127-与-Integer-b-x3D-127相等吗"><a href="#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗" class="headerlink" title="Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗"></a>Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗</h3><p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。</p>
<p>对于基本数据类型：&#x3D;&#x3D;比较的是值。如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer 对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1	public static void main(String[] args) &#123;</span><br><span class="line">2	Integer a = new Integer(3);</span><br><span class="line">3	Integer b = 3; // 将3自动装箱成Integer类型</span><br><span class="line">4	int c = 3;</span><br><span class="line">5	System.out.println(a == b); // false 两个引用没有引用同一对象</span><br><span class="line">6	System.out.println(a == c); // true a自动拆箱成int类型再和c比较</span><br><span class="line">7	System.out.println(b == c); // true</span><br><span class="line">8</span><br><span class="line">9	Integer a1 = 128;</span><br><span class="line">10	Integer b1 = 128;</span><br><span class="line">11	System.out.println(a1 == b1); // false</span><br><span class="line">12</span><br><span class="line">13	Integer a2 = 127;</span><br><span class="line">14	Integer b2 = 127;</span><br><span class="line">15	System.out.println(a2 == b2); // true</span><br><span class="line">16	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/09/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/09/redis/" class="post-title-link" itemprop="url">redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-09 17:00:38" itemprop="dateCreated datePublished" datetime="2022-10-09T17:00:38+08:00">2022-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-10 15:39:43" itemprop="dateModified" datetime="2022-10-10T15:39:43+08:00">2022-10-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis常用配置</p>
<img src="/2022/10/09/redis/mywechat.jpg" class="" title="myWechat">



<p>daemonize no</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置 redis server 是否以守护进程的方式启动。</span><br><span class="line">no：不以守护进程启动。</span><br><span class="line">yes：以守护进程启动。</span><br></pre></td></tr></table></figure>



<p>pidfile “&#x2F;var&#x2F;run&#x2F;redis&#x2F;redis-server.pid”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 Redis 以守护进程方式启动时，会在该文件里面写入 redis 的进程 id。</span><br></pre></td></tr></table></figure>



<p>port 6379</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置 redis server 启动的端口，默认为 6379。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>tcp-backlog 511</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP 监听的最大容纳数量。</span><br><span class="line">在高并发的环境下，需要把这个值调高以避免客户端连接缓慢的问题。</span><br><span class="line">如果该值大于 Linux 内核的值，则 Linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值， 此时要同时修改这两个值才能生效。</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/09/redis/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="善善332"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">善善332</p>
  <div class="site-description" itemprop="description">运气和努力一样重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CHl332" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CHl332" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2541621686@qq.com" title="E-Mail → mailto:2541621686@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/mywechat.jpg" title="Wechar → &#x2F;images&#x2F;mywechat.jpg"><i class="fa-weixin fa-fw"></i>Wechar</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/shanshan3.32/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;shanshan3.32&#x2F;" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.yuque.com/docs/share/4fda01be-199a-4d34-aa02-eb4960d4fa2b#%20%E3%80%8ASpringCloud%E3%80%8B" title="YuQue → https:&#x2F;&#x2F;www.yuque.com&#x2F;docs&#x2F;share&#x2F;4fda01be-199a-4d34-aa02-eb4960d4fa2b?# 《SpringCloud》" rel="noopener" target="_blank"><i class="fa-file-text fa-fw"></i>YuQue</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://funnylog.gitee.io/mysql45/iframe/" title="https:&#x2F;&#x2F;funnylog.gitee.io&#x2F;mysql45&#x2F;iframe&#x2F;" rel="noopener" target="_blank">MySQL45讲</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fishc.com.cn/" title="https:&#x2F;&#x2F;fishc.com.cn" rel="noopener" target="_blank">鱼C论坛</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-09 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">善善332</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


<!-- 自定义加上的 -->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共255.2k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>

<script type="text/javascript">
var OriginTitile = document.title,
    st;
document.addEventListener("visibilitychange", function () {
    document.hidden ? (document.title = "暂时离开一下", clearTimeout(st)) : (document.title =
        "回来了O(∩_∩)O~", st = setTimeout(function () {
            document.title = OriginTitile
        }, 3e3))
})
</script>
</html>
