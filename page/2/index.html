<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="运气和努力一样重要">
<meta property="og:type" content="website">
<meta property="og:title" content="和善寺">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="和善寺">
<meta property="og:description" content="运气和努力一样重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="善善332">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>和善寺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="和善寺" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和善寺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:30" itemprop="dateModified" datetime="2021-03-03T13:51:30+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许 可）高性能非关系型（NoSQL）的键值对数据库。 </p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值 支持五种数据类型：字符串、列表、集合、散列表、有序集合。 </p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快， 因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已<br>知性能快的Key-Value DB。</p>
<p>另外，Redis 也经常用来做分布式锁。除此之 外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </p>
<h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>**优点 **</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。 </li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。 </li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并 后的原子性执行。 </li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等 数据结构。 </li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>**缺点 **</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。 </li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求 失败，需要等待机器重启或者手动切换前端的IP才能恢复。 </li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一 致的问题，降低了系统的可用性。 </li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避 免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的 浪费。</li>
</ul>
<h2 id="为什么要用-Redis-x2F-为什么要用缓存"><a href="#为什么要用-Redis-x2F-为什么要用缓存" class="headerlink" title="为什么要用 Redis &#x2F;为什么要用缓存"></a>为什么要用 Redis &#x2F;为什么要用缓存</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。 </p>
<p>高性能： </p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上 读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候 就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如 果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%AB%98%E6%80%A7%E8%83%BD.png" alt="高性能"></p>
<p>高并发： </p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑 把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这 里而不用经过数据库。</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%AB%98%E5%B9%B6%E5%8F%91.png" alt="高并发"></p>
<h2 id="为什么要用-Redis-而不用-map-x2F-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-x2F-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map&#x2F;guava 做缓存?"></a>为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava  实现的是本地缓存，主要的特点是轻量以及快速，生命周期随着 jvm 的销毁 而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具 有一致性。 </p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实 例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。 </p>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存 中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)； </li>
<li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计 的；</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者 多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁 操作，没有因为可能出现死锁而导致的性能消耗； </li>
<li>使用多路 I&#x2F;O 复用模型，非阻塞 IO； </li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协 议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的 话，会浪费一定的时间去移动和请求；</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分 的使用要求 数据类型 可以存储 的值 操作 应用场景</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="left">可以存储 的值</th>
<th align="left">操作</th>
<th align="left">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="left">字符串、 整数或者 浮点数</td>
<td align="left">对整个字 符串或者 字符串的 其中一部 分执行操 作 对整数和 浮点数执 行自增或 者自减操 作</td>
<td align="left">做简单的 键值对缓 存</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="left">列表</td>
<td align="left">从两端压 入或者弹 出元素 对单个或 者多个元 素进行修 剪， 只保留一 个范围内 的元素</td>
<td align="left">存储一些 列表型的 数据结 构，类似 粉丝列 表、文章 的评论列 表之类的 数据</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="left">无序集合</td>
<td align="left">添加、获 取、移除 单个元素 检查一个 元素是否 存在于集 合中</td>
<td align="left">交集、并 集、差集 的操作， 比如交 集，可以 把两个人 的粉丝列</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="left">包含键值 对的无序 散列表</td>
<td align="left">添加、获 取、移除 单个键值 对 获取所有 键值对  检查某个 键是否存 在</td>
<td align="left">结构化的 数据，比 如一个对 象</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="left">有序集合</td>
<td align="left">添加、获 取、删除 元素 根据分值 范围或者 成员来获 取元素  计算一个 键的排名</td>
<td align="left">去重但可 以排序， 如获取排 名前几名 的用户</td>
</tr>
</tbody></table>
<h2 id="7Redis的应用场景"><a href="#7Redis的应用场景" class="headerlink" title="7Redis的应用场景"></a>7Redis的应用场景</h2><h3 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h3><p>计数器 </p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数 据库的读写性能非常高，很适合存储频繁读写的计数量。 </p>
<p>缓存 </p>
<p>将热点数据放到内存中，设置内存的大使用量以及淘汰策略来保证缓存的命中率。 </p>
<p>会话缓存 </p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存 储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务 器，从而更容易实现高可用性以及可伸缩性。 </p>
<p>全页缓存（FPC） </p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例， Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以 快速度加载你曾浏览过的页面。 </p>
<p>查找表 </p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了  Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效， 因为缓存不作为可靠的数据来源。 </p>
<p>消息队列(发布&#x2F;订阅功能) </p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过好使用  Kafka、RabbitMQ 等消息中间件。 </p>
<p>分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可 以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提 供的 RedLock 分布式锁实现。 </p>
<p>其它 </p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有 序性操作，从而实现排行榜等功能。 </p>
<h3 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a>总结二</h3><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 </p>
<p>数据类型说明string字符串，简单的k-v存储hashhash格式，value为field和 value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末 尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有 序的set </p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 </p>
<p>string——适合简单的k-v存储，类似于memcached的存储结构，短信验证 码，配置信息等，就用这种类型来存储。 </p>
<p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情， 个人信息详情，新闻详情等。</p>
<p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省 市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：新 的***，消息队列等。</p>
<p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set 牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人 共同的好友等。 </p>
<p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的 值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很 多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅 有利于提升开发效率，也能有效利用Redis的性能。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 </p>
<h2 id="9Redis-的持久化机制是什么？各自的优缺点？"><a href="#9Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="9Redis 的持久化机制是什么？各自的优缺点？"></a>9Redis 的持久化机制是什么？各自的优缺点？</h2><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: </p>
<h3 id="RDB：是Redis-DataBase缩写快照"><a href="#RDB：是Redis-DataBase缩写快照" class="headerlink" title="RDB：是Redis DataBase缩写快照"></a>RDB：是Redis DataBase缩写快照</h3><p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保 存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来 定义快照的周期。</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/RDB.png" alt="RDB"></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>只有一个文件 dump.rdb，方便持久化。 </li>
<li>容灾性好，一个文件可以保存到安全的磁盘。 </li>
<li>性能大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是  IO 大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了  redis 的高性能 </li>
<li>相对于数据集大时，比 AOF 的启动效率更高。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候) </li>
<li>AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命 令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ol>
<h3 id="AOF：持久化"><a href="#AOF：持久化" class="headerlink" title="AOF：持久化"></a>AOF：持久化</h3><p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录 到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/AOF.png" alt="AOF"></p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一 次 命令操作就记录到 aof 文件中一次。 </li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-checkaof 工具解决数据一致性问题。 </li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命 令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>AOF 文件比 RDB 文件大，且恢复速度慢。 </li>
<li>数据集大的时候，比 rdb 启动效率低。</li>
</ol>
<h3 id="优缺点是什么？"><a href="#优缺点是什么？" class="headerlink" title="优缺点是什么？"></a>优缺点是什么？</h3><ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。 </li>
<li>AOF比RDB更安全也更大 </li>
<li>RDB性能比AOF好 </li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载 入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集 要比RDB文件保存的数据集要完整。 </li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用RDB持久化。 </li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生 成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据 集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免 AOF程序的bug。 </li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任 何持久化方式。</li>
</ul>
<h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><p>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>
<p>如果Redis被当做一个持久化存储使用，必须使用固定的keys-tonodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p>
<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过</p>
<p>期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<p> 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<p>​          惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。</p>
<p>该策略可以  大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定</p>
<p>时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到 优的平衡效果。</p>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该</p>
<p>Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><p>EXPIRE和PERSIST命令。</p>
<h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li><p>定时去清理过期的缓存；</p>
</li>
<li><p>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</p>
<p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h2 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除</p>
<p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</p>
<p> allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除  近 少使用的key。（这个是最常用的）</p>
<p> allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p>
<p>设置过期时间的键空间选择性移除</p>
<p> volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除   近  少使用的key。</p>
<p> volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</p>
<p> volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
<p>总结</p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h3><p>内存。</p>
<h2 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表</p>
<p>（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面线程模型</p>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处</p>
<p>理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<p>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>​         当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入</p>
<p>（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I&#x2F;O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 </p>
<p>Redis 内部单线程设计的简单性。</p>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支</p>
<p>持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><p>\1. 事务开始 MULTI</p>
<p>\2. 命令入队</p>
<p>\3. 事务执行 EXEC</p>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p>
<h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<p>\1.  redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</p>
<p>\2.  如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</p>
<p>\3.  如果在一个事务中出现运行错误，那么正确的命令会被执行。</p>
<p> WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p>
<p> MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p>
<p> EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p>
<p> 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</p>
<p>​          UNWATCH命令可以取消watch对所有key的监控。</p>
<h2 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h2><p>原子性（Atomicity）</p>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性（Consistency）</p>
<p>事务前后数据的完整性必须保持一致。</p>
<p>隔离性（Isolation）</p>
<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h2 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h2><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h2 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h2><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><p> 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p>
<p> 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐集群方案哨兵模式</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5.jpg" alt="集群哨兵"></p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<p>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</p>
<p>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p>
<p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p>
<p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<p> 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</p>
<p> 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p>
<p>哨兵的核心知识</p>
<p>  哨兵至少需要 3 个实例，来保证自己的健壮性。</p>
<p> 哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</p>
<p> 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p>
<h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Redis_Cluster%E6%96%B9%E6%A1%88.jpg" alt="Redis_Cluster方案"></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？简介</p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis </p>
<p>Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个</p>
<p>槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p>方案说明</p>
<ol>
<li><p>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值) 区间的数据，默认分配了16384 个槽位</p>
</li>
<li><p>每份数据分片会存储在多个互为主从的多节点上</p>
</li>
<li><p>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</p>
</li>
<li><p>同一分片多个节点间的数据不保持一致性</p>
</li>
<li><p>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</p>
</li>
<li><p>扩容时时需要需要把旧节点的数据迁移一部分到新节点</p>
</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p>节点间的内部通信机制</p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p>分布式寻址算法</p>
<p>hash 算法（大量缓存重建）</p>
<p>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） redis cluster 的 hash slot 算法优点</p>
<p>无中心架构，支持动态扩容，对业务透明</p>
<p>具备Sentinel的监控和自动Failover(故障转移)能力</p>
<p>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可高性能，客户端直连redis运维也很复杂，数据迁移需要人工干预只能使用0号数据库</p>
<p>不支持批量操作(pipeline管道操作) 分布式逻辑和存储模块耦合等基于客户端分配</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E9%85%8D.jpg" alt="客户端分配"></p>
<p>简介</p>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持</p>
<p>Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool 优点</p>
<p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强缺点</p>
<p>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</p>
<p>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化基于代理服务器分片</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%BB%A3%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%89%87.jpg" alt="代里服务器分片"></p>
<p>简介客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点， 后将结果回复给客户端特征</p>
<p>透明接入，业务程序不用关心后端Redis实例，切换成本低</p>
<p>Proxy 的逻辑和存储的逻辑是隔离的代理层多了一次转发，性能有所损耗业界开源方案</p>
<p>Twtter开源的Twemproxy 豌豆荚开源的Codis</p>
<h2 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h2><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多</p>
<p>从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png" alt="主从架构"></p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -(redis­master­slave)&gt; 水平扩容支撑读高并发 redis replication 的核心机制</p>
<p> redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</p>
<p>一个 master node 是可以配置多个 slave node 的； slave node 也可以连接其他的 slave node；</p>
<p>slave node 做复制的时候，不会 block master node 的正常工作；</p>
<p>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</p>
<p> slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</p>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p>redis 主从复制的核心原理当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full </p>
<p>resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 </p>
<p>RDB 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="主从复制原理"></p>
<ol>
<li><p>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</p>
</li>
<li><p>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令存起来</p>
</li>
<li><p>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从</p>
</li>
</ol>
<p>Redis</p>
<ol start="4">
<li><p>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</p>
</li>
<li><p>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</p>
</li>
</ol>
<p>缺点</p>
<p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p>
<h2 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品生产环境中的 redis 是怎么部署的？</p>
<p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署</p>
<p>了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器 多是 25 万读写请求&#x2F;s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的</p>
<p>是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h2 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h2><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<p>Redis集群之间是如何复制的？</p>
<p>异步复制</p>
<p>Redis集群最大节点个数是多少？</p>
<p>16384个</p>
<p>Redis集群如何选择数据库？</p>
<p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h2><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个</p>
<p>CPU，你可以考虑一下分片（shard）。</p>
<h2 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h2><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你  多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h2 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h2><p> 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个 redis节点读取。大多数客户端已经实现了客户端分区。</p>
<p> 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</p>
<p> 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</p>
<h2 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h2><p> 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p>
<p>同时操作多个key,则不能使用Redis事务.</p>
<p>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The </p>
<p>partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</p>
<p> 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis 实例和主机同时收集RDB &#x2F; AOF文件。</p>
<p> 分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis 节点，能做到  大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p>
<h1 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h1><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户</p>
<p>端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则</p>
<p>SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。<img src="/12-Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/img.jpg" alt="img"></p>
<p>使用SETNX完成同步锁的流程及事项如下(img)：使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用SETNX命令总是返回</p>
<p>0而进入死锁状态，需要为该key设置一个“合理”的过期时间释放锁，使用DEL命令将锁数据删除</p>
<h2 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h2><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是 后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号 小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<h2 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h2><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容， 好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 </p>
<p>Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li><p>安全特性：互斥访问，即永远只有一个 client 能拿到锁</p>
</li>
<li><p>避免死锁： 终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</p>
</li>
<li><p>容错性：只要大部分 Redis 节点存活就可以正常提供服务缓存异常缓存雪崩</p>
</li>
</ol>
<p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p>
</li>
<li><p>一般并发量不是特别多的时候，使用   多的解决方案是加锁排队。</p>
</li>
<li><p>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p>
</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
</li>
<li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-</p>
</li>
</ol>
<p>value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p>
<ol start="3">
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力附加</li>
</ol>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap： 典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）</p>
<p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash</p>
<p>函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是</p>
<p>Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<p>1.设置热点数据永远不过期。</p>
<p>2.加互斥锁，互斥锁缓存预热</p>
<p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！解决方案</p>
<ol>
<li><p>直接写个缓存刷新页面，上线时手工操作一下；</p>
</li>
<li><p>数据量不大，可以在项目启动的时候自动进行加载；</p>
</li>
<li><p>定时刷新缓存；</p>
</li>
</ol>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的  终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li><p>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
</li>
<li><p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
</li>
<li><p>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的 大阀值，此时可以根据情况自动降级或者人工降级；</p>
</li>
<li><p>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h2><p>热点数据，缓存才有价值对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是  基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享</p>
<p>数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到</p>
<p>Redis缓存，减少数据库压力。</p>
<h2 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h2><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>解决方案对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其</p>
<p>他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询常用工具</p>
<p>Redis支持的Java客户端都有哪些？官方推荐用哪个？</p>
<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, </p>
<p>ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, </p>
<p>Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, </p>
<p>ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, </p>
<p>HyperLogLog)。</p>
<h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支</p>
<p>持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</p>
<p>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h2><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th>对比参数</th>
<th>Redis</th>
<th>Memcac hed</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>1. 支持内存 2. 非关系型数据库</td>
<td>1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td>数据存储类型</td>
<td>1. String 2. List 3.    Set 4.   Hash 5.   Sort Set   【俗称  ZSet】</td>
<td>1.    文本型   2.    二进制类型</td>
</tr>
<tr>
<td>查询【操作】类型</td>
<td>1. 批量操作 2. 事务支持 3. 每个类型不同的  CRUD</td>
<td>1.常用的  CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td>附加功能</td>
<td>1.  发布&#x2F;订阅模式 2. 主从分区 3. 序列化  支持 4. 脚本支持  【Lua脚本】</td>
<td>1. 多线程服务支持</td>
</tr>
<tr>
<td>网络IO模型</td>
<td>1. 单线程的多路 IO 复用模型</td>
<td>1. 多线程，非阻塞IO模式</td>
</tr>
<tr>
<td>事件库</td>
<td>自封转简易事件库 AeEvent</td>
<td>贵族血统的  LibEvent 事件库</td>
</tr>
<tr>
<td>持久化支持</td>
<td>1. RDB 2.   AOF</td>
<td>不支持</td>
</tr>
<tr>
<td>集群模式</td>
<td>原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存管理机制</td>
<td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用  的 value 交换到磁盘</td>
<td>Memcach ed 的数据则会一直在内存中，  Memcach  ed 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128   bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
<tr>
<td></td>
<td>复杂数据</td>
<td>纯key-  value，数据量非常大，并发量非常大的业务</td>
</tr>
<tr>
<td>适用场景</td>
<td>结构，有持久化，高可用需求，value 存储内容较大</td>
<td></td>
</tr>
</tbody></table>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况， 好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。</p>
<table>
<thead>
<tr>
<th>问题场景</th>
<th>描述</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
<tr>
<td></td>
<td>救措施）时候</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li><p>Master 好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</p>
</li>
<li><p>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
</li>
<li><p>为了主从复制的速度和连接的稳定性，Slave和Master  好在同一个局域网内。</p>
</li>
<li><p>尽量避免在压力较大的主库上增加从库</p>
</li>
<li><p>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
</li>
<li><p>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果</p>
</li>
</ol>
<p>Master挂了，可以立马启用Slave1做Master，其他不变。</p>
<h2 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h2><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p>
<p>Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h2 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h2><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过 pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h2 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h2><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</p>
<h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><ol>
<li><p>一个客户端运行了新的命令，添加了新的数据。</p>
</li>
<li><p>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</p>
</li>
<li><p>一个新的命令被执行，等等。</p>
</li>
<li><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p>
</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h2><p>LRU算法</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:29" itemprop="dateModified" datetime="2021-03-03T13:51:29+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><h2 id="1-什么是Linux"><a href="#1-什么是Linux" class="headerlink" title="1. 什么是Linux"></a>1. 什么是Linux</h2><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix 的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工 具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网 络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 </p>
<h2 id="2-Unix和Linux有什么区别？"><a href="#2-Unix和Linux有什么区别？" class="headerlink" title="2. Unix和Linux有什么区别？"></a>2. Unix和Linux有什么区别？</h2><p>Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很 多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然 而，事实并非如此，以下是两者的区别。 </p>
<ol>
<li>开源性 Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知 识产权保护的传统商业软件，使用需要付费授权使用。 </li>
<li>跨平台性 Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系 统跨平台性能较弱，大多需与硬件配套使用。 </li>
<li>可视化界面 Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。 </li>
<li>硬件环境 Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛 刻，按照难度较大。 </li>
<li>用户群体 Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是 安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使 用，如Sun等。</li>
</ol>
<p>相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因 是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实 现全部的Unix特性，开源免费的特性，更容易普及使用！ </p>
<h2 id="3-什么是-Linux-内核？"><a href="#3-什么是-Linux-内核？" class="headerlink" title="3. 什么是 Linux 内核？"></a>3. 什么是 Linux 内核？</h2><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要 时分配硬件，并根据需要执行软件。 </p>
<p>系统内存管理 </p>
<p>应用程序管理 </p>
<p>硬件设备管理 </p>
<p>文件系统管理 </p>
<h2 id="4-Linux的基本组件是什么？"><a href="#4-Linux的基本组件是什么？" class="headerlink" title="4. Linux的基本组件是什么？"></a>4. Linux的基本组件是什么？</h2><p>就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和 GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面 都附带其他功能，所有代码都可以免费下载。 </p>
<h2 id="5-Linux-的体系结构"><a href="#5-Linux-的体系结构" class="headerlink" title="5. Linux 的体系结构"></a>5. Linux 的体系结构</h2><p>从大的方面讲，Linux 体系结构可以分为两块：</p>
<p><img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Linux%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Linux体系结构"></p>
<ul>
<li>用户空间(User Space) ：用户空间又包括用户的应用程序(User  Applications)、C 库(C Library) 。 </li>
<li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call  Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel  Code) 。</li>
</ul>
<p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p>
<ul>
<li>现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问 的寄存器不同。 </li>
<li>Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li>
</ul>
<p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成 用户空间到内核空间的转移：1）系统调用；2）硬件中断。 </p>
<h2 id="6-BASH和DOS之间的基本区别是什么？"><a href="#6-BASH和DOS之间的基本区别是什么？" class="headerlink" title="6. BASH和DOS之间的基本区别是什么？"></a>6. BASH和DOS之间的基本区别是什么？</h2><p>BASH和DOS控制台之间的主要区别在于3个方面： </p>
<ul>
<li>BASH命令区分大小写，而DOS命令则不区分; </li>
<li>在BASH下，&#x2F; character是目录分隔符，\作为转义字符。在DOS下，&#x2F;用作命令 参数分隔符，\是目录分隔符 </li>
<li>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字 符。BASH没有遵循这样的惯例。</li>
</ul>
<h2 id="7-Linux-开机启动过程？"><a href="#7-Linux-开机启动过程？" class="headerlink" title="7. Linux 开机启动过程？"></a>7. Linux 开机启动过程？</h2><p>**了解即可。 **</p>
<ol>
<li>主机加电自检，加载 BIOS 硬件信息。 </li>
<li>读取 MBR 的引导文件(GRUB、LILO)。 </li>
<li>引导 Linux 内核。 </li>
<li>运行第一个进程 init (进程号永远为 1 )。 </li>
<li>进入相应的运行级别。 </li>
<li>运行终端，输入用户名和密码。</li>
</ol>
<h2 id="8-Linux系统缺省的运行级别？"><a href="#8-Linux系统缺省的运行级别？" class="headerlink" title="8. Linux系统缺省的运行级别？"></a>8. Linux系统缺省的运行级别？</h2><ul>
<li>关机。 </li>
<li>单机用户模式。 </li>
<li>字符界面的多用户模式(不支持网络)。 </li>
<li>字符界面的多用户模式。 </li>
<li>未分配使用。 </li>
<li>图形界面的多用户模式。 </li>
<li>重启。</li>
</ul>
<h2 id="9-Linux-使用的进程间通信方式？"><a href="#9-Linux-使用的进程间通信方式？" class="headerlink" title="9. Linux 使用的进程间通信方式？"></a>9. Linux 使用的进程间通信方式？</h2><p>**了解即可，不需要太深入。 **</p>
<ol>
<li>管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li>
<li>信号(signal) 。 </li>
<li>消息队列。 </li>
<li>共享内存。 </li>
<li>信号量。 </li>
<li>套接字(socket) 。</li>
</ol>
<h2 id="10-Linux-有哪些系统日志文件？"><a href="#10-Linux-有哪些系统日志文件？" class="headerlink" title="10. Linux 有哪些系统日志文件？"></a>10. Linux 有哪些系统日志文件？</h2><p>**比较重要的是 <code>/var/log/messages </code>日志文件。 **<br>    该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入 侵。<br>    另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。 </p>
<h1 id="Linux系统安装多个桌面环境有帮助吗？"><a href="#Linux系统安装多个桌面环境有帮助吗？" class="headerlink" title="Linux系统安装多个桌面环境有帮助吗？"></a>Linux系统安装多个桌面环境有帮助吗？</h1><p>通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。</p>
<h1 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h1><p>交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p>
<h1 id="什么是root帐户"><a href="#什么是root帐户" class="headerlink" title="什么是root帐户"></a>什么是root帐户</h1><p>root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</p>
<h1 id="什么是LILO？"><a href="#什么是LILO？" class="headerlink" title="什么是LILO？"></a>什么是LILO？</h1><p>LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。什么是BASH？</p>
<p>BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始</p>
<p>Bourne Shell（由&#x2F; bin &#x2F; sh表示）的替代品。它结合了原始版本的Bourne </p>
<p>Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。</p>
<h1 id="什么是CLI？"><a href="#什么是CLI？" class="headerlink" title="什么是CLI？"></a>什么是CLI？</h1><p>命令行界面（英语<strong>：command-line interface</strong>，缩写]：CLI）是在图形用</p>
<p>户界面得到普及之前使用  为广泛的用户界面，它通常不支持鼠标，用户通过键</p>
<p>盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面</p>
<p>（CUI）。</p>
<p>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。</p>
<p>因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</p>
<h1 id="什么是GUI？"><a href="#什么是GUI？" class="headerlink" title="什么是GUI？"></a>什么是GUI？</h1><p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p>
<p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</p>
<h1 id="开源的优势是什么？"><a href="#开源的优势是什么？" class="headerlink" title="开源的优势是什么？"></a>开源的优势是什么？</h1><p>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这  终使社区中的每个人受益。</p>
<h1 id="GNU项目的重要性是什么？"><a href="#GNU项目的重要性是什么？" class="headerlink" title="GNU项目的重要性是什么？"></a>GNU项目的重要性是什么？</h1><p>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</p>
<h1 id="磁盘、目录、文件"><a href="#磁盘、目录、文件" class="headerlink" title="磁盘、目录、文件"></a>磁盘、目录、文件</h1><h2 id="简单-Linux-文件系统？"><a href="#简单-Linux-文件系统？" class="headerlink" title="简单 Linux 文件系统？"></a>简单 Linux 文件系统？</h2><p>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱</p>
<p>动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</p>
<p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是</p>
<p>Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>
<p>Linux 支持 5 种文件类型，如下图所示：<img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.jpg" alt="文件类型"></p>
<h2 id="Linux-的目录结构是怎样的？"><a href="#Linux-的目录结构是怎样的？" class="headerlink" title="Linux 的目录结构是怎样的？"></a>Linux 的目录结构是怎样的？</h2><p>这个问题，一般不会问。更多是实际使用时，需要知道。</p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，  顶层是其根目录：</p>
<p><img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="Linux的目录结构"></p>
<p>常见目录说明：</p>
<ul>
<li>&#x2F;bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</li>
<li>&#x2F;etc： 存放系统管理和配置文件；</li>
<li>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示；</li>
<li>**&#x2F;usr **： 用于存放系统应用程序；</li>
<li>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把</li>
<li>tomcat等都安装到这里；</li>
<li>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级o）；</li>
<li>&#x2F;sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li>
<li>&#x2F;dev： 用于存放设备文件；</li>
<li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li>&#x2F;boot： 存放用于系统引导时使用的各种文件；</li>
<li>**&#x2F;lib **： 存放着和系统运行相关的库文件 ；</li>
<li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li>
</ul>
<h2 id="什么是-inode-？"><a href="#什么是-inode-？" class="headerlink" title="什么是 inode ？"></a>什么是 inode ？</h2><p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。</p>
<p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的 小存储单位叫做”扇区”（Sector）。每个扇区储存</p>
<p>512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的 小单位。”块”的大小， 常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>
<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<p>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</p>
<p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p>
<p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p>
<ul>
<li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中 重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>
<li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构</li>
</ul>
<h2 id="什么是硬链接和软链接？"><a href="#什么是硬链接和软链接？" class="headerlink" title="什么是硬链接和软链接？"></a>什么是硬链接和软链接？</h2><p>1）     硬链接</p>
<p>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</p>
<ul>
<li>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。</li>
</ul>
<p>2）     软链接软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>
<ul>
<li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li>
</ul>
<p>实际场景下，基本是使用软链接。总结区别如下：</p>
<ul>
<li>硬链接不可以跨分区，软件链可以跨分区。</li>
<li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li>
<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li>
</ul>
<p>RAID 是什么?</p>
<p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p>
<p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p>
<p>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="一台-Linux-系统初始化环境后需要做一些什么安全工作？"><a href="#一台-Linux-系统初始化环境后需要做一些什么安全工作？" class="headerlink" title="一台 Linux 系统初始化环境后需要做一些什么安全工作？"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h2><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p>
<p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p>
<p>2、服务器使用密钥登陆，禁止密码登陆。</p>
<p> 3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p>
<p>4、   装 fail2ban 这种防止 SSH 暴力破击的软件。</p>
<p>5、   设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p>
<p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p>
<p>6、   只允许有需要的服务器可以访问外网，其它全部禁止。</p>
<p>7、   做好软件层面的防护。</p>
<p>7.1 设置 nginx_waf 模块防止 SQL 注入。</p>
<p>7.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</p>
<h2 id="什么叫-CC-攻击？什么叫-DDOS-攻击？"><a href="#什么叫-CC-攻击？什么叫-DDOS-攻击？" class="headerlink" title="什么叫 CC 攻击？什么叫 DDOS 攻击？"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h2><ul>
<li>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</li>
<li>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</li>
</ul>
<p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p>
<p>怎么预防 CC 攻击和 DDOS 攻击？防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p>
<p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p>
<h2 id="什么是网站数据库注入？"><a href="#什么是网站数据库注入？" class="headerlink" title="什么是网站数据库注入？"></a>什么是网站数据库注入？</h2><ul>
<li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li>
<li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li>
<li>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li>
</ul>
<p>如何过滤与预防？</p>
<p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>本小节为选读。我也不太会写 Shell 脚本，都是写的时候，在网络上拼拼凑凑。。。</p>
<h2 id="Shell-脚本是什么？"><a href="#Shell-脚本是什么？" class="headerlink" title="Shell 脚本是什么？"></a>Shell 脚本是什么？</h2><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p>
<p>什么是默认登录 Shell ？在 Linux 操作系统，”&#x2F;bin&#x2F;bash” 是默认登录 Shell，是在创建用户时分配的。</p>
<p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	## chsh &lt;用户名&gt; ‐s &lt;新shell&gt;</span><br><span class="line">2	## chsh ThinkWon ‐s /bin/sh</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，如何写入注释？</p>
<p>注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 # 开头。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 ## This is a command</span><br><span class="line">3  echo “I am logged in as $USER”</span><br></pre></td></tr></table></figure>

<h2 id="语法级"><a href="#语法级" class="headerlink" title="语法级"></a>语法级</h2><p>可以在 Shell 脚本中使用哪些类型的变量？</p>
<p>在 Shell 脚本，我们可以使用两种类型的变量：</p>
<ul>
<li><p>系统定义变量<br>系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 set 命令查看。</p>
</li>
<li><p>用户定义变量<br>用户变量由系统用户来生成和定义，变量的值可以通过命令 “echo $&lt;变量名&gt;” 查看。<br>Shell脚本中 $? 标记的用途是什么？在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 if 条件中使用 $? 可以来检查前一命令的结束状态。</p>
</li>
<li><p>如果结束状态是 0 ，说明前一个命令执行成功。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	root@localhost:~## ls /usr/bin/shar</span><br><span class="line">2	/usr/bin/shar</span><br><span class="line">3	root@localhost:~## echo $?</span><br><span class="line">4	0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果结束状态不是0，说明命令执行失败。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	root@localhost:~## ls /usr/bin/share</span><br><span class="line">2	ls: cannot access /usr/bin/share: No such file or directory 3 root@localhost:~## echo $?</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Bourne Shell(bash) 中有哪些特殊的变量？下面的表列出了 Bourne Shell 为命令行设置的特殊变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	内建变量 解释</span><br><span class="line">2	$0 命令行中的脚本名字</span><br><span class="line">3	$1 第一个命令行参数</span><br><span class="line">4	$2 第二个命令行参数</span><br><span class="line">5	….. …….</span><br><span class="line">6	$9 第九个命令行参数</span><br><span class="line">7	$## 命令行参数的数量</span><br><span class="line">8	$* 所有命令行参数，以空格隔开</span><br></pre></td></tr></table></figure>

<p>如何取消变量或取消变量赋值？ unset 命令用于取消变量或取消变量赋值。语法如下所示：</p>
<p><code>1 ## unset &lt;变量名&gt;</code></p>
<p>Shell 脚本中 if 语法如何嵌套?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1  if [ 条件 ]</span><br><span class="line">2  then</span><br><span class="line">3  命令1</span><br><span class="line">4  命令2</span><br><span class="line">5 …..</span><br><span class="line">6  else</span><br><span class="line">7  if [ 条件 ]</span><br><span class="line">8  then</span><br><span class="line">9  命令1</span><br><span class="line">10  命令2</span><br><span class="line">11  ….</span><br><span class="line">12  else</span><br><span class="line">13  命令1</span><br><span class="line">14  命令2</span><br><span class="line">15  …..</span><br><span class="line">16  fi</span><br><span class="line">17  fi</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中如何比较两个数字？在 if-then 中使用测试命令（ -gt 等）来比较两个数字。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 x=10</span><br><span class="line">3 y=20</span><br><span class="line">4 if [ $x ‐gt $y ]</span><br><span class="line">5  then</span><br><span class="line">6  echo “x is greater than y”</span><br><span class="line">7  else</span><br><span class="line">8  echo “y is greater than x”</span><br><span class="line">9 fi</span><br></pre></td></tr></table></figure>

<p>Shell 脚本中 case 语句的语法?</p>
<p>基础语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1	case 变量 in</span><br><span class="line">2	值1)</span><br><span class="line">3	命令1</span><br><span class="line">4	命令2</span><br><span class="line">5	…..</span><br><span class="line">6	最后命令</span><br><span class="line">!!</span><br><span class="line">7</span><br><span class="line">8	值2)</span><br><span class="line">9	命令1</span><br><span class="line">10	命令2</span><br><span class="line">11	……</span><br><span class="line">12	最后命令</span><br><span class="line">13	;;</span><br><span class="line">14	esac</span><br></pre></td></tr></table></figure>

<p>Shell 脚本中 for 循环语法？基础语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  for 变量 in 循环列表</span><br><span class="line">2 do</span><br><span class="line">3  命令1</span><br><span class="line">4  命令2</span><br><span class="line">5 ….</span><br><span class="line">6  最后命令</span><br><span class="line">7  done</span><br></pre></td></tr></table></figure>

<p>Shell 脚本中 while 循环语法？如同 for 循环，while 循环只要条件成立就重复它的命令块。不同于 for循环，while 循环会不断迭代，直到它的条件不为真。基础语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	while [ 条件 ]</span><br><span class="line">2	do</span><br><span class="line">3	命令…</span><br><span class="line">4	done</span><br></pre></td></tr></table></figure>

<p>do-while 语句的基本格式？</p>
<p>do-while 语句类似于 while 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 do-while 语句的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	do</span><br><span class="line">2	&#123;</span><br><span class="line">3	命令</span><br><span class="line">4	&#125; while (条件)</span><br></pre></td></tr></table></figure>

<p>Shell 脚本中 break 命令的作用？</p>
<p>break 命令一个简单的用途是退出执行中的循环。我们可以在 while 和 until 循环中使用 break 命令跳出循环。 Shell 脚本中 continue 命令的作用？ continue 命令不同于 break 命令，它只跳出当前循环的迭代，而不是整个循环。 continue 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p>
<p>如何使脚本可执行?</p>
<p>使用 chmod 命令来使脚本可执行。例子如下：chmod a+x myscript.sh 。</p>
<p>#!&#x2F;bin&#x2F;bash 的作用？</p>
<p>#!&#x2F;bin&#x2F;bash 是 Shell 脚本的第一行，称为释伴（shebang）行。</p>
<p>这里 # 符号叫做 hash ，而 ! 叫做 bang。它的意思是命令通过 &#x2F;bin&#x2F;bash 来执行。</p>
<p>如何调试 Shell脚本？</p>
<p>使用 -x’ 数（sh -x myscript.sh）可以调试 Shell脚本。另一个种方法是使用 -nv 参数(sh -nv myscript.sh)。</p>
<p>如何将标准输出和错误输出同时重定向到同一位置?</p>
<p>方法一：2&gt;&amp;1 (如## ls &#x2F;usr&#x2F;share&#x2F;doc &gt; out.txt 2&gt;&amp;1 ) 。</p>
<p>方法二：&amp;&gt; (如## ls &#x2F;usr&#x2F;share&#x2F;doc &amp;&gt; out.txt ) 。</p>
<p>在 Shell 脚本中，如何测试文件？</p>
<p>test 命令可以用来测试文件。基础用法如下表格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	Test 用法</span><br><span class="line">2	‐d 文件名 如果文件存在并且是目录，返回true</span><br><span class="line">3	‐e 文件名 如果文件存在，返回true</span><br><span class="line">4	‐f 文件名 如果文件存在并且是普通文件，返回true</span><br><span class="line">5	‐r 文件名 如果文件存在并可读，返回true</span><br><span class="line">6	‐s 文件名 如果文件存在并且不为空，返回true</span><br><span class="line">7	‐w 文件名 如果文件存在并可写，返回true</span><br><span class="line">8	‐x 文件名 如果文件存在并可执行，返回true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本如何定义函数呢？</p>
<p>函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	$ diskusage () &#123; df ‐h ; &#125;</span><br><span class="line">2	译注：下面是我给的shell函数语法，原文没有</span><br><span class="line">3	[ function ] 函数名 [()]</span><br><span class="line">4	&#123;</span><br><span class="line">5	命令;</span><br><span class="line">6	[return int;]</span><br><span class="line">7	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何让 Shell 就脚本得到来自终端的输入?</p>
<p>read 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	## vi /tmp/test.sh</span><br><span class="line">!/</span><br><span class="line">2	#bin/bash</span><br><span class="line">3	echo ‘Please enter your name’</span><br><span class="line">4	read name</span><br><span class="line">5	echo “My Name is $name”</span><br><span class="line">6	## ./test.sh</span><br><span class="line">7	Please enter your name</span><br><span class="line">8	ThinkWon</span><br><span class="line">9	My Name is ThinkWon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何执行算术运算？</p>
<p>有两种方法来执行算术运算：</p>
<p>1、使用 expr 命令：## expr 5 + 2 。</p>
<p> 2、用一个美元符号和方括号（$[ 表达式 ]）：test&#x3D;$[16 + 4] ; test&#x3D;$[16 + 4] </p>
<h2 id="编程题-。"><a href="#编程题-。" class="headerlink" title="编程题(。)"></a>编程题(。)</h2><p>判断一文件是不是字符设备文件，如果是将其拷贝到 &#x2F;dev 目录下？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2  read ‐p &quot;Input file name: &quot; FILENAME</span><br><span class="line">3 if [ ‐c &quot;$FILENAME&quot; ];then</span><br><span class="line">4	cp $FILENAME /dev</span><br><span class="line">5 fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> #!/bin/bash</span><br><span class="line">2  groupadd class1</span><br><span class="line">3 for((i=1;i&lt;31;i++))</span><br><span class="line">4 do</span><br><span class="line">5   if [ $i ‐le 10 ];then</span><br><span class="line">6   useradd ‐g class1 std0$i</span><br><span class="line">7   else</span><br><span class="line">8   useradd ‐g class1 std$i</span><br><span class="line">9   fi</span><br><span class="line">10  done</span><br></pre></td></tr></table></figure>

<p>编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/bash</span><br><span class="line">2 for((i=1;i&lt;51;i++))</span><br><span class="line">3 do</span><br><span class="line">4   userdel ‐r stud$i</span><br><span class="line">5  done</span><br></pre></td></tr></table></figure>

<p>写一个 sed 命令，修改 &#x2F;tmp&#x2F;input.txt 文件的内容？</p>
<p>要求：</p>
<p>删除所有空行。</p>
<p>一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 &#96;000111112222 的一行改为 0000AAA11111BBB2222 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1	[root@~]## cat ‐n /tmp/input.txt</span><br><span class="line">2	1 000011111222</span><br><span class="line">3	2</span><br><span class="line">4	3 000011111222222</span><br><span class="line">5	4 11111000000222</span><br><span class="line">6	5</span><br><span class="line">7	6</span><br><span class="line">8	7 111111111111122222222222</span><br><span class="line">9	8 2211111111</span><br><span class="line">10	9 112222222</span><br><span class="line">11	10 1122</span><br><span class="line">12	11</span><br><span class="line">13</span><br><span class="line">14	## 删除所有空行命令</span><br><span class="line">15	[root@~]## sed &#x27;/^$/d&#x27; /tmp/input.txt</span><br><span class="line">16	000011111222</span><br><span class="line">17	000011111222222</span><br><span class="line">18	11111000000222</span><br><span class="line">19	111111111111122222222222</span><br><span class="line">20	2211111111</span><br><span class="line">21	112222222</span><br><span class="line">22	1122</span><br><span class="line">23</span><br><span class="line">24	## 插入指定的字符</span><br><span class="line">25	[root@~]## sed &#x27;s#\(11111\)#AAA\1BBB#g&#x27; /tmp/input.txt</span><br><span class="line">26	0000AAA11111BBB222</span><br><span class="line">27	0000AAA11111BBB222222</span><br><span class="line">28	AAA11111BBB000000222</span><br><span class="line">29	AAA11111BBBAAA11111BBB11122222222222</span><br><span class="line">30	22AAA11111BBB111</span><br><span class="line">31	112222222</span><br><span class="line">32	1122</span><br></pre></td></tr></table></figure>

<p>实战如何选择 Linux 操作系统版本?</p>
<p>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</p>
<p>根据具体要求：</p>
<p>安全性要求较高，则选择 Debian 或者 FreeBSD 。</p>
<p>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</p>
<p>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</p>
<p> 【重点】根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS </p>
<p>更侧重服务器领域，并且无版权约束。</p>
<p>CentOS 7 系列，也慢慢使用的会比较多了。</p>
<h2 id="如何规划一台-Linux-主机，步骤是怎样？"><a href="#如何规划一台-Linux-主机，步骤是怎样？" class="headerlink" title="如何规划一台 Linux 主机，步骤是怎样？"></a>如何规划一台 Linux 主机，步骤是怎样？</h2><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p>
<p>不同的用途，机器的配置会有所不同。</p>
<p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p>
<p> 3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p>
<h2 id="请问当用户反馈网站访问慢，你会如何处理？"><a href="#请问当用户反馈网站访问慢，你会如何处理？" class="headerlink" title="请问当用户反馈网站访问慢，你会如何处理？"></a>请问当用户反馈网站访问慢，你会如何处理？</h2><p>有哪些方面的因素会导致网站网站访问慢？</p>
<p>1、服务器出口带宽不够用</p>
<ul>
<li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>
<li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>
</ul>
<p> 2、服务器负载过大，导致响应不过来</p>
<p>可以从两个方面入手分析：</p>
<ul>
<li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li>
<li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li>
</ul>
<p>3、数据库瓶颈</p>
<ul>
<li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>
<li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>
</ul>
<p>4、网站开发代码没有优化好</p>
<ul>
<li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li>
</ul>
<p>针对网站访问慢，怎么去排查？</p>
<p> 1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p>
<p> 2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p>
<p> 3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。  </p>
<p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。怎么去解决？</p>
<p>1、   如果是出口带宽问题，那么久申请加大出口带宽。</p>
<p>2、   如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</p>
<p>3、   如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</p>
<p>4、   申请购买 CDN 服务，加载用户的访问。</p>
<p>5、   如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</p>
<h2 id="Linux-性能调优都有哪几种方法？"><a href="#Linux-性能调优都有哪几种方法？" class="headerlink" title="Linux 性能调优都有哪几种方法？"></a>Linux 性能调优都有哪几种方法？</h2><p>1、Disabling daemons (关闭 daemons)。</p>
<p>2、Shutting down the GUI (关闭 GUI)。</p>
<p>3、Changing kernel parameters (改变内核参数)。</p>
<p>4、Kernel parameters (内核参数)。</p>
<p>5、Tuning the processor subsystem (处理器子系统调优)。</p>
<p>6、Tuning the memory subsystem (内存子系统调优)。</p>
<p>7、Tuning the file system (文件系统子系统调优)。</p>
<p>8、Tuning the network subsystem（网络子系统调优)。</p>
<h2 id="文件管理命令-cat-命令"><a href="#文件管理命令-cat-命令" class="headerlink" title="文件管理命令 cat 命令"></a>文件管理命令 cat 命令</h2><p>cat 命令用于连接文件并打印到标准输出设备上。</p>
<p>cat 主要有三大功能：</p>
<p>1.一次显示整个文件:</p>
<p><code>cat filename</code></p>
<p>2.从键盘创建一个文件</p>
<p><code>cat &gt; filename</code></p>
<p>只能创建新文件,不能编辑已有文件</p>
<p>3.将几个文件合并为一个文件:</p>
<p><code>cat file1 file2 &gt; file</code></p>
<ul>
<li>-b 对非空输出行号</li>
<li>-n 输出所有行号实例：</li>
</ul>
<p>（1）  把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p>
<p><code>1  cat ‐n log2012.log log2013.log</code></p>
<p>（2）  把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p>
<p><code>1  cat ‐b log2012.log log2013.log log.log</code></p>
<p>（3）  使用 here doc 生成新文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	cat &gt;log.txt &lt;&lt;EOF</span><br><span class="line">2	&gt;Hello</span><br><span class="line">3	&gt;World</span><br><span class="line">4	&gt;PWD=$(pwd)</span><br><span class="line">5	&gt;EOF</span><br><span class="line">6	ls ‐l log.txt</span><br><span class="line">7	cat log.txt</span><br><span class="line">8	Hello</span><br><span class="line">9	World</span><br><span class="line">=/</span><br><span class="line">10	PWD opt/soft/test</span><br></pre></td></tr></table></figure>

<p>（4）  反向列示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	tac log.txt</span><br><span class="line">=/</span><br><span class="line">2	PWD opt/soft/test</span><br><span class="line">3	World</span><br><span class="line">4	Hello</span><br></pre></td></tr></table></figure>

<h2 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h2><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p>
<p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>
<p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。</p>
<p>以文件 log2012.log 为例：</p>
<p><code>1 ‐rw‐r‐‐r‐‐ 1 root root 296K 11‐13 06:03 log2012.log</code></p>
<p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	‐c 当发生改变时，报告处理信息</span><br><span class="line">2	‐R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure>

<p>权限范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	u ：目录或者文件的当前的用户</span><br><span class="line">2	g ：目录或者文件的当前的群组</span><br><span class="line">3	o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">4	a ：所有的用户及群组</span><br></pre></td></tr></table></figure>

<p>权限代号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	r ：读权限，用数字4表示</span><br><span class="line">2	w ：写权限，用数字2表示</span><br><span class="line">3	x ：执行权限，用数字1表示</span><br><span class="line">4	‐ ：删除权限，用数字0表示</span><br><span class="line">5	s ：特殊权限</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  增加文件 t.log 所有用户可执行权限</p>
<p><code>1  chmod a+x t.log</code></p>
<p>（2）  撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p>
<p><code>1  chmod u=r t.log ‐c</code></p>
<p>（3）  给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行</p>
<p>(5)的权限，给其他用户分配执行(1)的权限</p>
<p><code>1  chmod 751 t.log ‐c（或者：chmod u=rwx,g=rx,o=x t.log ‐c)</code></p>
<p>（4）  将 test 目录及其子目录所有文件添加可读权限</p>
<p><code>1  chmod u+r,g+r,o+r ‐R text/ ‐c</code></p>
<h2 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h2><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	‐c 显示更改的部分的信息</span><br><span class="line">2	‐R 处理指定目录及子目录</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  改变拥有者和群组 并显示改变信息</p>
<p><code>1  chown ‐c mail:mail log2012.log</code></p>
<p>（1）  改变文件群组</p>
<p><code>1  chown ‐c :mail t.log</code></p>
<p>（2）  改变文件夹及子文件目录属主及属组为 mail</p>
<p><code>1  chown ‐cR mail: test/</code></p>
<h2 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h2><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	‐i 提示</span><br><span class="line">2	‐r 复制目录及目录内所有项目</span><br><span class="line">3	‐a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p>
<p><code>1  cp ‐ai a.txt test</code></p>
<p>（2）  为 a.txt 建议一个链接（快捷方式）</p>
<p><code>1  cp ‐s a.txt link_a.txt</code></p>
<h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><p>用于在文件树中查找文件，并作出相应的处理。</p>
<p>命令格式：</p>
<p><code>1 find pathname ‐options [‐print ‐exec ‐ok ...]</code></p>
<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</span><br><span class="line">2	‐print： find命令将匹配的文件输出到标准输出。</span><br><span class="line">3	‐exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;comm and&#x27; &#123; &#125; \;，注意&#123; &#125;和\；之间的空格。</span><br><span class="line">4	‐ok： 和‐exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure>

<p>命令选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	‐name 按照文件名查找文件</span><br><span class="line">2	‐perm 按文件权限查找文件</span><br><span class="line">3	‐user 按文件属主查找文件</span><br><span class="line">4	‐group 按照文件所属的组来查找文件。</span><br><span class="line">5	‐type 查找某一类型的文件，诸如：</span><br><span class="line">6	b ‐ 块设备文件</span><br><span class="line">7	d ‐ 目录</span><br><span class="line">8	c ‐ 字符设备文件</span><br><span class="line">9	l ‐ 符号链接文件</span><br><span class="line">10	p ‐ 管道文件</span><br><span class="line">11	f ‐ 普通文件</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  查找 48 小时内修改过的文件</p>
<p><code>1  find ‐atime ‐2</code></p>
<p>（2）  在当前目录查找 以 .log 结尾的文件。 . 代表当前目录</p>
<p><code>1  find ./ ‐name &#39;*.log&#39;</code></p>
<p>（3）  查找 &#x2F;opt 目录下 权限为 777 的文件</p>
<p><code>1  find /opt ‐perm 777</code></p>
<p>（4）  查找大于 1K 的文件</p>
<p><code>1  find ‐size +1000c</code></p>
<p>查找等于 1000 字符的文件</p>
<p><code>1 find ‐size 1000c</code></p>
<p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以</p>
<p>这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。</p>
<h2 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h2><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。常用参数：</p>
<p><code>1 ‐n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</code></p>
<p>实例：</p>
<p>（1）  显示 1.log 文件中前 20 行</p>
<p><code>1  head 1.log ‐n 20</code></p>
<p>（2）  显示 1.log 文件前 20 字节</p>
<p><code>1  head ‐c 20 log2014.log</code></p>
<p>（3）  显示 t.log  后 10 行</p>
<p><code>1  head ‐n ‐10 t.log</code></p>
<h2 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h2><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。常用命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1	‐i 忽略搜索时的大小写</span><br><span class="line">2	‐N 显示每行的行号</span><br><span class="line">3	‐o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">4	‐s 显示连续空行为一行</span><br><span class="line">5	/字符串：向下搜索“字符串”的功能</span><br><span class="line">6	?字符串：向上搜索“字符串”的功能</span><br><span class="line">7	n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">8	N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">9	‐x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">10	b 向后翻一页</span><br><span class="line">11	d 向后翻半页</span><br><span class="line">12	h 显示帮助界面</span><br><span class="line">13	Q 退出less 命令</span><br><span class="line">14	u 向前滚动半页</span><br><span class="line">15	y 向前滚动一行</span><br><span class="line">16	空格键 滚动一行</span><br><span class="line">17	回车键 滚动一页</span><br><span class="line">18	[pagedown]： 向下翻动一页</span><br><span class="line">19	[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  ps 查看进程信息并通过 less 分页显示</p>
<p><code>1  ps ‐aux | less ‐N</code></p>
<p>（2）  查看多个文件</p>
<p><code>1  less 1.log 2.log</code></p>
<p>可以使用 n 查看下一个，使用 p 查看前一个。</p>
<h2 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h2><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p>
<p>链接分类：软件链接及硬链接软链接：</p>
<p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</p>
<p>2.软链接可以 跨文件系统 ，硬链接不可以</p>
<p>3.软链接可以对一个不存在的文件名进行链接</p>
<p>4.软链接可以对目录进行链接硬链接:</p>
<p>1.硬链接，以文件副本的形式存在。但不占用实际空间。</p>
<p>2.不允许给目录创建硬链接</p>
<p>3.硬链接只有在同一个文件系统中才能创建需要注意：</p>
<p> 第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</p>
<p> 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</p>
<p> 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且  后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且  后的目的地并非是一个已存在的目录，则会出现错误信息。</p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	‐b 删除，覆盖以前建立的链接</span><br><span class="line">2	‐s 软链接（符号链接）</span><br><span class="line">3	‐v 显示详细处理过程</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  给文件创建软链接，并显示操作信息</p>
<p><code>1  ln ‐sv source.log link.log</code></p>
<p>（2）  给文件创建硬链接，并显示操作信息</p>
<p><code>1  ln ‐v source.log link1.log</code></p>
<p>（3）  给目录创建软链接</p>
<p><code>1  ln ‐sv /opt/soft/test/test3 /opt/soft/test/test5</code></p>
<h2 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h2><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb </p>
<p>程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 </p>
<p>locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是  近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 </p>
<p>(etc&#x2F;crontab)。</p>
<p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	‐l num（要显示的行数）</span><br><span class="line">2	‐f 将特定的档案系统排除在外，如将proc排除在外</span><br><span class="line">3	‐r 使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  查找和 pwd 相关的所有文件(文件名中包含 pwd）</p>
<p><code>1  locate pwd</code></p>
<p>（2）  搜索 etc 目录下所有以 sh 开头的文件</p>
<p><code>1  locate /etc/sh</code></p>
<p>（3）  查找 &#x2F;var 目录下，以 reason 结尾的文件</p>
<p><code>1  locate ‐r &#39;^/var.*reason$&#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</code></p>
<h2 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h2><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而 基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>
<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1  +n 从笫 n 行开始显示</span><br><span class="line">2  ‐n 定义屏幕大小为n行</span><br><span class="line">3  +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</span><br><span class="line">4  ‐c 从顶部清屏，然后显示</span><br><span class="line">5  ‐d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">6  ‐l 忽略Ctrl+l（换页）字符</span><br><span class="line">7  ‐p 通过清除窗口而不是滚屏来对文件进行换页，与‐c选项相似</span><br><span class="line">8  ‐s 把连续的多个空行显示为一行</span><br><span class="line">9  ‐u 把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure>

<p>常用操作命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1  Enter 向下 n 行，需要定义。默认为 1 行</span><br><span class="line">2  Ctrl+F 向下滚动一屏</span><br><span class="line">3  空格键 向下滚动一屏</span><br><span class="line">4  Ctrl+B 返回上一屏</span><br><span class="line">5  = 输出当前行的行号</span><br><span class="line">6  :f 输出文件名和当前行的行号</span><br><span class="line">7  V 调用vi编辑器</span><br><span class="line">8  !命令 调用Shell，并执行命令</span><br><span class="line">9  q 退出more</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  显示文件中从第3行起的内容</p>
<p><code>1  more +3 text.txt</code></p>
<p>（2）  在所列出文件目录详细信息，借助管道使每次显示 5 行</p>
<p><code>1  ls ‐l |more ‐5</code></p>
<p>按空格显示下 5 行。</p>
<h2 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h2><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p>
<p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p>
<p>实例：</p>
<p>（1）  将文件 test.log 重命名为 test1.txt</p>
<p><code>1  mv test.log test1.txt</code></p>
<p>（2）  将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p>
<p><code>1  mv llog1.txt log2.txt log3.txt /test3</code></p>
<p>（3）  将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p>
<p><code>1  mv ‐i log1.txt log2.txt</code></p>
<p>（4）  移动当前文件夹下的所有文件到上一级目录</p>
<p><code>1  mv * ../</code></p>
<h2 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h2><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>
<p><code>1 rm[选项] 文件…</code></p>
<p>实例：</p>
<p>（1）  删除任何 .log 文件，删除前逐一询问确认：</p>
<p><code>1  rm ‐i *.log</code></p>
<p>（2）  删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p>
<p><code>1  rm ‐rf test</code></p>
<p>（3）  删除以 -f 开头的文件</p>
<p><code>1  rm ‐‐ ‐f*</code></p>
<h2 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h2><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	‐f 循环读取（常用于查看递增的日志文件）</span><br><span class="line">2	‐n&lt;行数&gt; 显示行数（从后向前）</span><br></pre></td></tr></table></figure>

<p>（1）循环读取逐渐增加的文件内容</p>
<p><code>1 ping 127.0.0.1 &gt; ping.log &amp;</code></p>
<p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p>
<p><code>1 tail ‐f ping.log</code></p>
<h2 id="（查看日志）-touch-命令"><a href="#（查看日志）-touch-命令" class="headerlink" title="（查看日志） touch 命令"></a>（查看日志） touch 命令</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 touch [‐acfm][‐d&lt;日期时间&gt;][‐r&lt;参考文件或目录&gt;] [‐t&lt;日期时间&gt;][‐‐help][‐‐ver sion][文件或目录…]</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<p>实例</p>
<p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<p><code>1 $ touch testfile #修改文件的时间属性</code></p>
<p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	$ ls ‐l testfile #查看文件的时间属性</span><br><span class="line">2	#原来文件的修改时间为16:09</span><br><span class="line">3	‐rw‐r‐‐r‐‐ 1 hdd hdd 55 2011‐08‐22 16:09 testfile</span><br></pre></td></tr></table></figure>

<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	$ touch testfile #修改文件时间属性为当前系统时间</span><br><span class="line">2	$ ls ‐l testfile #查看文件的时间属性</span><br><span class="line">3	#修改后文件的时间属性为当前系统时间</span><br><span class="line">4	‐rw‐r‐‐r‐‐ 1 hdd hdd 55 2011‐08‐22 19:53 testfile</span><br></pre></td></tr></table></figure>

<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<p><code>1 $ touchfile#创建一个名为“file”的新的空白文件</code></p>
<h2 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a>vim 命令</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>打开文件并跳到第 10 行：vim +10 filename.txt 。</p>
<p>打开文件跳到第一个匹配的行：vim +&#x2F;search-term filename.txt 。</p>
<p>以只读模式打开文件：vim -R &#x2F;etc&#x2F;passwd 。</p>
<p>基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。简单的说，我们可以将这三个模式想成底下的图标来表示：<img src="/11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Vim%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.jpg" alt="Vim工作模式"></p>
<h2 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h2><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、</p>
<p>man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	‐b 定位可执行文件。</span><br><span class="line">2	‐m 定位帮助文件。</span><br><span class="line">3	‐s 定位源代码文件。</span><br><span class="line">4	‐u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  查找 locate 程序相关文件</p>
<p><code>1  whereislocate</code></p>
<p>（2）  查找 locate 的源码文件</p>
<p><code>1  whereis ‐s locate</code></p>
<p>（3）  查找 lcoate 的帮助文件</p>
<p><code>1  whereis ‐m locate</code></p>
<h2 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h2><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	which 查看可执行文件的位置。</span><br><span class="line">2	whereis 查看文件的位置。</span><br><span class="line">3	locate 配合数据库查看文件位置。</span><br><span class="line">4	find 实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure>

<p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>常用参数：</p>
<p><code>1 ‐n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</code></p>
<p>实例：</p>
<p>（1）  查看 ls 命令是否存在，执行哪个</p>
<p><code>1  whichls</code></p>
<p>（2）  查看 which</p>
<p><code>1  whichwhich</code></p>
<p>（3）  查看 cd</p>
<p><code>1  which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</code></p>
<p>查看当前 PATH 配置：</p>
<p>&#96;1 echo$PATH</p>
<p>或使用 env 查看所有环境变量及对应值文档编辑命令 grep 命令</p>
<p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p>
<p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>命令格式：</p>
<p><code> grep [option] pattern file|dir</code></p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1	‐A n ‐‐after‐context显示匹配字符后n行</span><br><span class="line">2	‐B n ‐‐before‐context显示匹配字符前n行</span><br><span class="line">3	‐C n ‐‐context 显示匹配字符前后n行</span><br><span class="line">4	‐c ‐‐count 计算符合样式的列数</span><br><span class="line">5	‐i 忽略大小写</span><br><span class="line">6	‐l 只列出文件内容符合指定的样式的文件名称</span><br><span class="line">7	‐f 从文件中读取关键词</span><br><span class="line">8	‐n 显示匹配内容的所在文件中行数</span><br><span class="line">9	‐R 递归查找文件夹</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>grep 的规则表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ^ #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。 2 $ #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。</span><br><span class="line">3	. #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。</span><br><span class="line">4	* #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。</span><br><span class="line">5	.* #一起用代表任意字符。</span><br><span class="line">6	[] #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。</span><br><span class="line">7	[^] #匹配一个不在指定范围内的字符，如：&#x27;[^A‐FH‐Z]rep&#x27;匹配不包含A‐R和T‐Z的一个</span><br><span class="line">字母开头，紧跟rep的行。</span><br><span class="line">8	\(..\) #标记匹配字符，如&#x27;\(love\)&#x27;，love被标记为1。</span><br><span class="line">9	\&lt; #锚定单词的开始，如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行。</span><br><span class="line">10	\&gt; #锚定单词的结束，如&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行。</span><br><span class="line">11	x\&#123;m\&#125; #重复字符x，m次，如：&#x27;0\&#123;5\&#125;&#x27;匹配包含5个o的行。</span><br><span class="line">12	x\&#123;m,\&#125; #重复字符x,至少m次，如：&#x27;o\&#123;5,\&#125;&#x27;匹配至少有5个o的行。</span><br><span class="line">13	x\&#123;m,n\&#125; #重复字符x，至少m次，不多于n次，如：&#x27;o\&#123;5,10\&#125;&#x27;匹配5‐‐10个o的行。</span><br><span class="line">14	\w #匹配文字和数字字符，也就是[A‐Za‐z0‐9]，如：&#x27;G\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。</span><br><span class="line">15	\W #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。</span><br><span class="line">16	\b #单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：（1）查找指定进程</p>
<p><code>1 ps ‐ef |grep svn</code></p>
<p>（2）  查找指定进程个数</p>
<p><code>1  ps ‐ef |grep svn ‐c</code></p>
<p>（3）  从文件中读取关键词</p>
<p><code>1  cat test1.txt |grep ‐f key.log</code></p>
<p>（4）  从文件夹中递归查找以grep开头的行，并只列出文件</p>
<p><code>1  grep ‐lR &#39;^grep&#39; /tmp</code></p>
<p>（5）  查找非x开关的行内容</p>
<p><code>1  grep&#39;^[^x]&#39; test.txt</code></p>
<p>（6）  显示包含 ed 或者 at 字符的内容行</p>
<p><code>1  grep ‐E &#39;ed|at&#39; test.txt</code></p>
<h2 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h2><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出命令格式：</p>
<p><code>1 wc [option] file..</code></p>
<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	‐c 统计字节数</span><br><span class="line">2	‐l 统计行数</span><br><span class="line">3	‐m 统计字符数</span><br><span class="line">4	‐w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  查找文件的 行数 单词数 字节数 文件名</p>
<p><code>1  wc text.txt</code></p>
<p>结果：</p>
<p><code>1 7 8 70 test.txt</code></p>
<p>（2）  统计输出结果的行数</p>
<p><code>1  cat test.txt |wc ‐l</code></p>
<h1 id="磁盘管理命令-cd-命令"><a href="#磁盘管理命令-cd-命令" class="headerlink" title="磁盘管理命令 cd 命令"></a>磁盘管理命令 cd 命令</h1><p>cd(changeDirectory) 命令语法：</p>
<p><code>1 cd [目录名]</code></p>
<p>说明：切换当前目录至 dirName。</p>
<p>实例：（1）进入要目录</p>
<p><code>1 cd /</code></p>
<p>（2）  进入 “home” 目录</p>
<p><code>1  cd ~</code></p>
<p>（3）  进入上一次工作路径</p>
<p><code>1  cd ‐</code></p>
<p>（4）  把上个命令的参数作为cd参数使用。</p>
<p><code>1  cd!$</code></p>
<h2 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h2><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显</p>
<p>示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 </p>
<p>POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	‐a 全部文件系统列表</span><br><span class="line">2	‐h 以方便阅读的方式显示信息</span><br><span class="line">3	‐i 显示inode信息</span><br><span class="line">4	‐k 区块为1024字节</span><br><span class="line">5	‐l 只显示本地磁盘</span><br><span class="line">6	‐T 列出文件系统类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  显示磁盘使用情况</p>
<p>1  df ‐l</p>
<p>（2）  以易读方式列出所有文件系统及其类型</p>
<p>1  df ‐haT</p>
<h2 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h2><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：命令格式：</p>
<p>1 du [选项] [文件]</p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	‐a 显示目录中所有文件大小</span><br><span class="line">2	‐k 以KB为单位显示文件大小</span><br><span class="line">3	‐m 以MB为单位显示文件大小</span><br><span class="line">4	‐g 以GB为单位显示文件大小</span><br><span class="line">5	‐h 以易读方式显示文件大小</span><br><span class="line">6	‐s 仅显示总计</span><br><span class="line">7	‐c或‐‐total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  以易读方式显示文件夹内及子文件夹大小</p>
<p><code>1  du ‐h scf/</code></p>
<p>（2）  以易读方式显示文件夹内所有文件大小</p>
<p><code>1  du ‐ah scf/</code></p>
<p>（3）  显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>
<p><code>1  du ‐hc test/ scf/</code></p>
<p>（4）  输出当前目录下各个子目录所使用的空间</p>
<p><code>1  du ‐hc ‐‐max‐depth=1 scf/</code></p>
<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限) 查看目录信息等等。</p>
<p>常用参数搭配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	ls ‐a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="line">2	ls ‐A 列出除.及..的其它文件</span><br><span class="line">3	ls ‐r 反序排列</span><br><span class="line">4	ls ‐t 以文件修改时间排序</span><br><span class="line">5	ls ‐S 以文件大小排序</span><br><span class="line">6	ls ‐h 以易读大小显示</span><br><span class="line">7	ls ‐l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p>
<p><code>1  ls ‐lhrt</code></p>
<p>(2) 按大小反序显示文件详细信息</p>
<p><code>1  ls ‐lrS</code></p>
<p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p>
<p><code>1 ls ‐l t*</code></p>
<p>(4) 列出文件绝对路径（不包含隐藏文件）</p>
<p><code>1  ls|sed&quot;s:^:</code>pwd<code>/:&quot;</code></p>
<p>(5) 列出文件绝对路径（包含隐藏文件）</p>
<p><code>1  find$pwd ‐maxdepth 1 |xargsls ‐ld</code></p>
<h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><p>mkdir 命令用于创建文件夹。</p>
<p>可用选项：</p>
<p>-m: 对新建目录设置存取权限，也可以用 chmod 命令设置;</p>
<p> -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</p>
<p>实例：</p>
<p>（1）  当前工作目录下创建名为 t的文件夹</p>
<p><code>1 mkdir t</code></p>
<p>（2）  在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建：</p>
<p> <code>1 mkdir ‐p /tmp/test/t1/t  </code></p>
<h2 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h2><p>pwd 命令用于查看当前工作目录路径。</p>
<p>实例：</p>
<p>（1）  查看当前路径</p>
<p><code>1 pwd</code></p>
<p>（2）  查看软链接的实际路径</p>
<p><code>1 pwd</code></p>
<h2 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h2><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p>
<p>注意：不能删除非空目录实例：</p>
<p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p>
<p>  <code>1 rmdir ‐p parent/child/child11  </code></p>
<h2 id="网络通讯命令-ifconfig-命令"><a href="#网络通讯命令-ifconfig-命令" class="headerlink" title="网络通讯命令 ifconfig 命令"></a>网络通讯命令 ifconfig 命令</h2><ul>
<li>ifconfig 用于查看和配置 Linux 系统的网络接口。</li>
<li>查看所有网络接口及其状态：ifconfig -a 。</li>
<li>使用 up 和 down 命令启动或停止某个接口：ifconfig eth0 up 和 ifconfig eth0 down 。</li>
</ul>
<p>iptables 命令</p>
<p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于</p>
<p>我们开发来说，主要掌握如何开放端口即可。例如：</p>
<p> 把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝： iptables -I INPUT -s 192.168.1.101 -p tcp –dport 80 -j REJECT 。 </p>
<p> 开启 80 端口，因为web对外都是这个端口</p>
<p>iptables -A INPUT -p tcp –dport 80 -j ACCEP</p>
<p>​                    1</p>
<p> 另外，要注意使用 iptables save 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p>
<h2 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h2><p>Linux netstat命令用于显示网络状态。</p>
<p>利用netstat指令可让你得知整个Linux系统的网络情况。语法</p>
<p>  <code>1 netstat [‐acCeFghilMnNoprstuvVwx][‐A&lt;网络类型&gt;][‐‐ip]</code></p>
<p>参数说明：</p>
<ul>
<li>-a或–all 显示所有连线中的Socket。</li>
<li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li>
<li>-c或–continuous 持续列出网络状态。</li>
<li>-C或–cache 显示路由器配置的快取信息。</li>
<li>-e或–extend 显示网络其他相关信息。</li>
<li>-F或–fib 显示FIB。</li>
<li>-g或–groups 显示多重广播功能群组组员名单。</li>
<li>-h或–help 在线帮助。</li>
<li>-i或–interfaces 显示网络界面信息表单。</li>
<li>-l或–listening 显示监控中的服务器的Socket。</li>
<li>-M或–masquerade 显示伪装的网络连线。</li>
<li>-n或–numeric 直接使用IP地址，而不通过域名服务器。</li>
<li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。</li>
<li>-o或–timers 显示计时器。</li>
<li>-p或–programs 显示正在使用Socket的程序识别码和程序名称。</li>
<li>-r或–route 显示Routing Table。</li>
<li>-s或–statistice 显示网络工作信息统计表。</li>
<li>-t或–tcp 显示TCP传输协议的连线状况。</li>
<li>-u或–udp 显示UDP传输协议的连线状况。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V或–version 显示版本信息。</li>
<li>-w或–raw 显示RAW传输协议的连线状况。</li>
<li>-x或–unix 此参数的效果和指定”-A unix”参数相同。</li>
<li>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</li>
</ul>
<p>实例如何查看系统都开启了哪些端口？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	[root@centos6 ~ 13:20 #55]# netstat ‐lnp</span><br><span class="line">2	Active Internet connections (only servers)</span><br><span class="line">3	Proto Recv‐Q Send‐Q Local Address Foreign Address State PID/Program name</span><br><span class="line">4	tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1035/sshd</span><br><span class="line">5	tcp 0 0 :::22 :::* LISTEN 1035/sshd</span><br><span class="line">6	udp 0 0 0.0.0.0:68 0.0.0.0:* 931/dhclient 7 Active UNIX domain sockets (only servers)</span><br><span class="line">8	Proto RefCnt Flags Type State I‐Node PID/Program name Path</span><br><span class="line">9	unix 2 [ ACC ] STREAM LISTENING 6825 1/init @/com/ubuntu/upstart</span><br><span class="line">10	unix 2 [ ACC ] STREAM LISTENING 8429 1003/dbus‐daemon /var/run/dbus/syst em_bus_socket</span><br></pre></td></tr></table></figure>

<p>如何查看网络连接状况？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	[root@centos6 ~ 13:22 #58]# netstat ‐an</span><br><span class="line">2	Active Internet connections (servers and established)</span><br><span class="line">3	Proto Recv‐Q Send‐Q Local Address Foreign Address State</span><br><span class="line">4	tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN</span><br><span class="line">5	tcp 0 0 192.168.147.130:22 192.168.147.1:23893 ESTABLISHED</span><br><span class="line">6	tcp 0 0 :::22 :::* LISTEN</span><br><span class="line">7	udp 0 0 0.0.0.0:68 0.0.0.0:*</span><br></pre></td></tr></table></figure>

<p>如何统计系统当前进程连接数？输入命令 netstat -an | grep ESTABLISHED | wc -l 。输出结果 177 。一共有 177 连接数。用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 </p>
<p>ESTABLISHED 状态链接的个数？严格来说，这个题目考验的是对 awk 的使用。</p>
<p>首先，使用 netstat -an|grep ESTABLISHED 命令。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 tcp 0 0 120.27.146.122:80 113.65.18.33:62721 ESTABLISHED 2 tcp 0 0 120.27.146.122:80 27.43.83.115:47148 ESTABLISHED</span><br><span class="line">3	tcp 0 0 120.27.146.122:58838 106.39.162.96:443 ESTABLISHED</span><br><span class="line">4	tcp 0 0 120.27.146.122:52304 203.208.40.121:443 ESTABLISHED</span><br><span class="line">5	tcp 0 0 120.27.146.122:33194 203.208.40.122:443 ESTABLISHED</span><br><span class="line">6	tcp 0 0 120.27.146.122:53758 101.37.183.144:443 ESTABLISHED</span><br><span class="line">7	tcp 0 0 120.27.146.122:27017 23.105.193.30:50556 ESTABLISHED</span><br></pre></td></tr></table></figure>

<h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><p>Linux ping命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。指定接收包的次数</p>
<p><code>1 ping ‐c 2 www.baidu.com</code></p>
<h2 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h2><p>Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 telnet [‐8acdEfFKLrx][‐b&lt;主机别名&gt;][‐e&lt;脱离字符&gt;][‐k&lt;域名&gt;][‐l&lt;用户名称&gt;][n&lt;记录文件&gt;][‐S&lt;服务类型&gt;][‐X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li>8 允许使用8位字符资料，包括输入与输出。 -a 尝试自动登入远端系统。</li>
<li>-b&lt;主机别名&gt; 使用别名指定远端主机名称。</li>
<li>-c 不读取用户专属目录里的.telnetrc文件。</li>
<li>-d 启动排错模式。</li>
<li>-e&lt;脱离字符&gt; 设置脱离字符。</li>
<li>-E 滤除脱离字符。</li>
<li>-f 此参数的效果和指定”-F”参数相同。</li>
<li>-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li>
<li>-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li>
<li>-K 不自动登入远端主机。</li>
<li>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</li>
<li>-L 允许输出8位字符资料。</li>
<li>-n&lt;记录文件&gt; 指定文件记录相关信息。</li>
<li>-r 使用类似rlogin指令的用户界面。</li>
<li>-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</li>
<li>-x 假设主机有支持数据加密的功能，就使用它。</li>
<li>-X&lt;认证形态&gt; 关闭指定的认证形态。</li>
</ul>
<p>实例</p>
<p>登录远程主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	# 登录IP为 192.168.0.5 的远程主机</span><br><span class="line">2	telnet 192.168.0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="系统管理命令-date-命令"><a href="#系统管理命令-date-命令" class="headerlink" title="系统管理命令 date 命令"></a>系统管理命令 date 命令</h2><p>显示或设定系统的日期与时间。</p>
<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1	‐d&lt;字符串&gt;  显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class="line">2	‐s&lt;字符串&gt;  根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class="line">3	‐u  显示GMT。</span><br><span class="line">4	%H 小时(00‐23)</span><br><span class="line">5	%I 小时(00‐12)</span><br><span class="line">6	%M 分钟(以00‐59来表示)</span><br><span class="line">7	%s 总秒数。起算时间为1970‐01‐01 00:00:00 UTC。</span><br><span class="line">8	%S 秒(以本地的惯用法来表示) 9 %a 星期的缩写。</span><br><span class="line">10	%A 星期的完整名称。</span><br><span class="line">11	%d 日期(以01‐31来表示)。</span><br><span class="line">12	%D 日期(含年月日)。</span><br><span class="line">13	%m 月份(以01‐12来表示)。</span><br><span class="line">14	%y 年份(以00‐99来表示)。</span><br><span class="line">15	%Y 年份(以四位数来表示)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  显示下一天</p>
<p><code>1 date +%Y%m%d ‐‐date=&quot;+1 day&quot; //显示下一天的日期</code></p>
<p>（2）  -d参数使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  date ‐d &quot;nov 22&quot; 今年的 11 月 22 日是星期三</span><br><span class="line">2  date ‐d &#x27;2 weeks&#x27; 2周后的日期</span><br><span class="line">3  date ‐d &#x27;next monday&#x27; (下周一的日期)</span><br><span class="line">4  date ‐d next‐day +%Y%m%d（明天的日期）或者：date ‐d tomorrow +%Y%m%d</span><br><span class="line">5  date ‐d last‐day +%Y%m%d(昨天的日期) 或者：date ‐d yesterday +%Y%m%d</span><br><span class="line">6  date ‐d last‐month +%Y%m(上个月是几月)</span><br><span class="line">7  date ‐d next‐month +%Y%m(下个月是几月)</span><br></pre></td></tr></table></figure>

<h2 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h2><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>
<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	‐b 以Byte显示内存使用情况</span><br><span class="line">2	‐k 以kb为单位显示内存使用情况</span><br><span class="line">3	‐m 以mb为单位显示内存使用情况</span><br><span class="line">4	‐g 以gb为单位显示内存使用情况</span><br><span class="line">5	‐s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">6	‐t 显示内存使用总合</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  显示内存使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	free</span><br><span class="line">2	free ‐k</span><br><span class="line">3	free ‐m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（1）  以总和的形式显示内存的使用信息</p>
<p><code>1  free ‐t</code></p>
<p>（2）  周期性查询内存使用情况</p>
<p><code>1  free ‐s 10</code></p>
<h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进</p>
<p>程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p>
<p>常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	‐l 信号，若果不加信号的编号参数，则使用“‐l”参数会列出全部的信号名称</span><br><span class="line">2	‐a 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line">3	‐p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line">4	‐s 指定发送信号</span><br><span class="line">5	‐u 指定用户</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）先使用ps查找进程pro1，然后用kill杀掉</p>
<p>1 kill ‐9 $(ps ‐ef |grep pro1)</p>
<h2 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h2><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top linux上进程有5种状态:</p>
<ol>
<li><p>运行(正在运行或在运行队列中等待)</p>
</li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p>
</li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p>
</li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p>
</li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运</p>
</li>
</ol>
<p>行)</p>
<p>ps 工具标识进程的5种状态码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	D 不可中断 uninterruptible sleep (usually IO)</span><br><span class="line">2	R 运行 runnable (on run queue)</span><br><span class="line">3	S 中断 sleeping</span><br><span class="line">4	T 停止 traced or stopped</span><br><span class="line">5	Z 僵死 a defunct (”zombie”) process</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	‐A 显示所有进程</span><br><span class="line">2	a 显示所有进程</span><br><span class="line">3	‐a 显示同一终端下所有进程</span><br><span class="line">4	c 显示进程真实名称</span><br><span class="line">5	e 显示环境变量</span><br><span class="line">6	f 显示进程间的关系</span><br><span class="line">7	r 显示当前终端运行的进程</span><br><span class="line">8	‐aux 显示所有包含其它使用的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  显示当前所有进程环境变量及进程间关系</p>
<p><code>1  ps ‐ef</code></p>
<p>（2）  显示当前所有进程</p>
<p><code>1  ps ‐A</code></p>
<p>（3）  与grep联用查找某进程</p>
<p><code>1  ps ‐aux |grep apache</code></p>
<p>（4）  找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<p><code>1  ps aux |grep&#39;(cron|syslog)&#39;</code></p>
<h2 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a>rpm 命令</h2><p>Linux rpm 命令用于管理套件。</p>
<p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 </p>
<p>Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	# 查看系统自带jdk</span><br><span class="line">2	rpm ‐qa | grep jdk</span><br><span class="line">3	# 删除系统自带jdk</span><br><span class="line">4	rpm ‐e ‐‐nodeps 查看jdk显示的数据</span><br><span class="line">5	# 安装jdk</span><br><span class="line">6	rpm ‐ivh jdk‐7u80‐linux‐x64.rpm</span><br></pre></td></tr></table></figure>

<h2 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h2><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	‐c 显示完整的进程命令</span><br><span class="line">2	‐s 保密模式</span><br><span class="line">3	‐p &lt;进程号&gt; 指定进程显示</span><br><span class="line">4	‐n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	top ‐ 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35</span><br><span class="line">2	Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie</span><br><span class="line">3	Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st</span><br><span class="line">4	Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers</span><br><span class="line">5	Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached</span><br><span class="line">6	PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">7	28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前五行是当前系统情况整体的统计信息区。</p>
<p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p>
<p>14:06:23 — 当前系统时间</p>
<p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p>
<p>2 users — 当前有2个用户登录系统</p>
<p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5 分钟、15分钟的负载情况。</p>
<p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
<p>第二行，Tasks — 任务（进程），具体信息说明如下：系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep）， stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行，cpu状态信息，具体属性说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	5.9%us — 用户空间占用CPU的百分比。</span><br><span class="line">2	3.4% sy — 内核空间占用CPU的百分比。</span><br><span class="line">3	0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class="line">4	90.4% id — 空闲CPU百分比</span><br><span class="line">5	0.0% wa — IO等待占用CPU的百分比</span><br><span class="line">6	0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class="line">7	0.2% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure>

<p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p>
<p>第四行，内存状态，具体信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	32949016k total — 物理内存总量（32GB）</span><br><span class="line">2	14411180k used — 使用中的内存总量（14GB）</span><br><span class="line">3	18537836k free — 空闲内存总量（18GB）</span><br><span class="line">4  169884k buffers — 缓存的内存量 （169M）</span><br></pre></td></tr></table></figure>

<p>第五行，swap交换分区信息，具体信息说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  32764556k total — 交换区总量（32GB）</span><br><span class="line">2  0k used — 使用的交换区总量（0K）</span><br><span class="line">3  32764556k free — 空闲交换区总量（32GB）</span><br><span class="line">4  3612636k cached — 缓冲的交换区总量（3.6GB）</span><br></pre></td></tr></table></figure>

<p>第六行，空行。</p>
<p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1	PID — 进程id</span><br><span class="line">2	USER — 进程所有者</span><br><span class="line">3	PR — 进程优先级</span><br><span class="line">4	NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">5	VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">6	RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">7	SHR — 共享内存大小，单位kb</span><br><span class="line">8	S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line">9	%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class="line">10	%MEM — 进程使用的物理内存百分比</span><br><span class="line">11	TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">12	COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure>

<p>top 交互命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	 h 显示top交互命令帮助信息</span><br><span class="line">2	c 切换显示命令名称和完整命令行</span><br><span class="line">3	m 以内存使用率排序</span><br><span class="line">4	 P 根据CPU使用百分比大小进行排序</span><br><span class="line">5	T 根据时间/累计时间进行排序</span><br><span class="line">6  W 将当前设置写入~/.toprc文件中</span><br><span class="line">7	o或者O 改变显示项目的顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="yum-命令"><a href="#yum-命令" class="headerlink" title="yum 命令"></a>yum 命令</h2><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及</p>
<p>SUSE中的Shell前端软件包管理器。</p>
<p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>1.列出所有可更新的软件清单命令：yum check-update</p>
<p>2.更新所有软件命令：yum update</p>
<p>3.仅安装指定的软件命令：yum install</p>
<p>4.仅更新指定的软件命令：yum update</p>
<p>5.列出所有可安裝的软件清单命令：yum list</p>
<p>6.删除软件包命令：</p>
<ul>
<li>yum remove 7.查找软件包 命令：</li>
<li>yum search 8.清除缓存命令:</li>
<li>yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers</li>
<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>
<li>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>
</ul>
<p>实例</p>
<p>安装 pam-devel</p>
<p>1 [root@www ~]# yum install pam‐devel</p>
<h2 id="备份压缩命令-bzip2-命令"><a href="#备份压缩命令-bzip2-命令" class="headerlink" title="备份压缩命令 bzip2 命令"></a>备份压缩命令 bzip2 命令</h2><p>创建 *.bz2 压缩文件：bzip2 test.txt 。解压 *.bz2 文件：bzip2 -d test.txt.bz2 。</p>
<h2 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h2><p>创建一个 *.gz 的压缩文件：gzip test.txt 。解压 *.gz 文件：gzip -d test.txt.gz 。</p>
<p>显示压缩的比率：gzip -l *.gz 。</p>
<h2 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h2><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p>
<p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1	‐c 建立新的压缩文件</span><br><span class="line">2	‐f 指定压缩文件</span><br><span class="line">3	‐r 添加文件到已经压缩文件包中</span><br><span class="line">4	‐u 添加改了和现有的文件到压缩包中</span><br><span class="line">5	‐x 从压缩包中抽取文件</span><br><span class="line">6	‐t 显示压缩文件中的内容</span><br><span class="line">7	‐z 支持gzip压缩</span><br><span class="line">8	‐j 支持bzip2压缩</span><br><span class="line">9	‐Z 支持compress解压文件</span><br><span class="line">10	‐v 显示操作过程</span><br></pre></td></tr></table></figure>

<p>有关 gzip 及 bzip2 压缩:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	gzip 实例：压缩 gzip fileName .tar.gz 和.tgz 解压：gunzip filename.gz 或 gz ip ‐d filename.gz</span><br><span class="line">2	对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz</span><br><span class="line">3</span><br><span class="line">4	bz2实例：压缩 bzip2 ‐z filename .tar.bz2 解压：bunzip filename.bz2或bzip ‐d filename.bz2</span><br><span class="line">5	对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>（1）  将文件全部打包成 tar 包</p>
<p><code>1  tar ‐cvf log.tar 1.log,2.log 或tar ‐cvf log.*</code></p>
<p>（2）  将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p>
<p><code>1  tar ‐zcvf /tmp/etc.tar.gz /etc</code></p>
<p>（3）  查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）</p>
<p><code>1  tar ‐ztvf /tmp/etc.tar.gz</code></p>
<p>（4）  要压缩打包 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai</p>
<p><code>1  tar ‐‐exclude /home/dmtsai ‐zcvf myfile.tar.gz /home/* /etc</code></p>
<h2 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h2><p>解压 *.zip 文件：unzip test.zip 。查看 *.zip 文件的内容：unzip -l jasper.zip 。</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:28" itemprop="dateModified" datetime="2021-03-03T13:51:28+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Tomcat是什么？"><a href="#1-Tomcat是什么？" class="headerlink" title="1. Tomcat是什么？"></a>1. Tomcat是什么？</h2><p>Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放 源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问 用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 </p>
<h2 id="2-Tomcat的缺省端口是多少，怎么修改"><a href="#2-Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="2. Tomcat的缺省端口是多少，怎么修改"></a>2. Tomcat的缺省端口是多少，怎么修改</h2><p>找到Tomcat目录下的conf文件夹 </p>
<p>进入conf文件夹里面找到server.xml文件 </p>
<p>打开server.xml文件 </p>
<p>在server.xml文件里面找到下列信息 </p>
<p>把Connector标签的8080端口改成你想要的端口 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;Service name=&quot;Catalina&quot;&gt; </span><br><span class="line">2 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; </span><br><span class="line">3  connectionTimeout=&quot;20000&quot; </span><br><span class="line">4  redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-tomcat-有哪几种Connector-运行模式-优化-？"><a href="#3-tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="3. tomcat 有哪几种Connector 运行模式(优化)？"></a>3. tomcat 有哪几种Connector 运行模式(优化)？</h2><p>下面，我们先大致了解Tomcat Connector的三种运行模式。 </p>
<ul>
<li><strong>BIO：同步并阻塞</strong> 一个线程处理一个请求。缺点：并发量高时，线程数较 多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。<br><strong>配制项：</strong>protocol&#x3D;”HTTP&#x2F;1.1” </li>
<li><strong>NIO：同步非阻塞IO</strong> 利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一 个线程处理多个connection(多路复用)。<br>Tomcat8在Linux系统中默认使用这种方式。<br>Tomcat7必须修改Connector配置来启动。<br><strong>配制项：</strong>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol”<br><strong>备注：</strong>我们常用的Jetty，Mina，ZooKeeper等都是基于java nio实现. </li>
<li><strong>APR：</strong>即Apache Portable Runtime，从操作系统层面解决io阻塞问 题。<strong>AIO方式，异步非阻塞IO</strong>(Java NIO2又叫AIO) 主要与NIO的区别 主要是操作系统的底层区别.可以做个比喻:比作快递，NIO就是网购后要自 己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就 是快递员送货上门了(不用关注快递进度)。<br><strong>配制项：</strong>protocol&#x3D;”org.apache.coyote.http11.Http11AprProtocol”<br><strong>备注：</strong>需在本地服务器安装APR库。Tomcat7或Tomcat8在Win7或以上的系统 中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就 支持apr。</li>
</ul>
<h2 id="4-Tomcat有几种部署方式？"><a href="#4-Tomcat有几种部署方式？" class="headerlink" title="4. Tomcat有几种部署方式？"></a>4. Tomcat有几种部署方式？</h2><p>**在Tomcat中部署Web应用的方式主要有如下几种： **</p>
<ul>
<li>利用Tomcat的自动部署。<br>把web应用拷贝到webapps目录。Tomcat在启动时会加载目录下的应用，并将 编译后的结果放入work目录下。 </li>
<li>使用Manager App控制台部署。<br>在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个 web应用的路径或war文件。</li>
<li>修改conf&#x2F;server.xml文件部署。<br>修改conf&#x2F;server.xml文件，增加Context节点可以部署应用。 </li>
<li>增加自定义的Web部署文件。<br>在conf&#x2F;Catalina&#x2F;localhost&#x2F; 路径下增加 xyz.xml文件，内容是Context节点， 可以部署应用</li>
</ul>
<h2 id="5-tomcat容器是如何创建servlet类实例？用到了什么-原理？"><a href="#5-tomcat容器是如何创建servlet类实例？用到了什么-原理？" class="headerlink" title="5. tomcat容器是如何创建servlet类实例？用到了什么 原理？"></a>5. tomcat容器是如何创建servlet类实例？用到了什么 原理？</h2><ol>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml 文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个 应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候 也是在第一次请求时实例化） </li>
<li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或 为负数，则第一次请求实例化。</li>
</ol>
<h2 id="6-Tomcat工作模式"><a href="#6-Tomcat工作模式" class="headerlink" title="6. Tomcat工作模式"></a>6. Tomcat工作模式</h2><p>Tomcat作为servlet容器，有三种工作模式： </p>
<ol>
<li>独立的servlet容器，servlet容器是web服务器的一部分； </li>
<li>进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实 现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反 应速度快但伸缩性不足； </li>
<li>进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作 为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性 比进程内优； 进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</li>
</ol>
<ul>
<li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是 Apache, IIS, Nginx等； </li>
<li>Tomcat作为独立服务器：请求来自于web浏览器；</li>
</ul>
<p>面试时问到Tomcat相关问题的几率并不高，正式因为如此，很多人忽略了对 Tomcat相关技能的掌握，下面这一篇文章整理了Tomcat相关的系统架构，介 绍了Server、Service、Connector、Container之间的关系，各个模块的功 能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！</p>
<p>另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常 见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是 可以往Tomcat处理请求的这个过程去说的！掌握了Tomcat这些技能，面试官 一定会佩服你的！ </p>
<p>学了本章之后你应该明白的是：</p>
<ul>
<li>Server、Service、Connector、Container四大组件之间的关系和联系，以及他 们的主要功能点； </li>
<li>Tomcat执行的整体架构，请求是如何被一步步处理的； </li>
<li>Engine、Host、Context、Wrapper相关的概念关系； </li>
<li>Container是如何处理请求的； </li>
<li>Tomcat用到的相关设计模式；</li>
</ul>
<h2 id="7-Tomcat顶层架构"><a href="#7-Tomcat顶层架构" class="headerlink" title="7. Tomcat顶层架构"></a>7. Tomcat顶层架构</h2><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后 逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但 是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而 解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！ 先上一张Tomcat的顶层结构图（图A），如下：</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E9%A1%B6%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="Tomcat顶层结构"></p>
<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一 个Server可以包含至少一个Service，即可以包含多个Service，用于具体提供服 务。 </p>
<p>Service主要包含两个部分：Connector和Container。从上图中可以看出  Tomcat 的心脏就是这两个组件，他们的作用如下： </p>
<ul>
<li>Connector用于处理连接相关的事情，并提供Socket与Request请求和 Response响应相关的转化; </li>
<li>Container用于封装和管理Servlet，以及具体处理Request请求；</li>
</ul>
<p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个 Service只有一个Container，但是可以有多个Connectors，这是因为一个服务 可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端 口的连接，示意图如下（Engine、Host、Context下面会说到）：</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Service_Service_Connector.png" alt="Service_Service_Connector"></p>
<p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可 以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生 命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由  Server 控制。 </p>
<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的 server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的 server.xml配置文件（Tomcat版本为8.0）</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/server.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="server.xml配置文件"></p>
<p>详细的配置文件内容可以到Tomcat官网查看：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">Tomcat配置文件 </a></p>
<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9B%BE%E8%A7%A3.png" alt="Tomcat配置文件图解"></p>
<p>Server标签设置的端口号为8005，shutdown&#x3D;”SHUTDOWN” ，表示在 8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个 Server有一个Service，当然还可以进行配置，一个Service有多个Connector， Service左边的内容都属于Container的，Service下边是Connector。</p>
<p>**Tomcat顶层架构小结 **</p>
<ol>
<li>Tomcat中只有一个Server，一个Server可以有多个Service，一个 Service可以有多个Connector和一个Container； </li>
<li>Server掌管着整个Tomcat的生死大权；</li>
<li>Service 是对外提供服务的； </li>
<li>Connector用于接受请求并将请求封装成Request和Response来具体 处理； </li>
<li>Container用于封装和管理Servlet，以及具体处理request请求；</li>
</ol>
<p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大 多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大 部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下 Connector和Container。 </p>
<h2 id="8-Connector和Container的微妙关系"><a href="#8-Connector和Container的微妙关系" class="headerlink" title="8. Connector和Container的微妙关系"></a>8. Connector和Container的微妙关系</h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然 后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为 Request和Response来具体处理，Request和Response封装完之后再交由 Container进行处理，Container处理完请求之后再返回给Connector，最后在 由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理 完了！ </p>
<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照 HTTP协议来封装的，所以Connector同时需要实现TCP&#x2F;IP协议和HTTP协议！ </p>
<p>Tomcat既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东 西我们首先就需要看一下Connector！ </p>
<p>Connector架构分析 </p>
<p>Connector用于接受请求并将请求封装成Request和Response，然后交给 Container进行处理，Container处理完之后在交给Connector返回给客户端。 因此，我们可以把Connector分为四个方面进行理解： </p>
<ol>
<li>Connector如何接受请求的？ </li>
<li>如何将请求封装成Request和Response的？ </li>
<li>封装完之后的Request和Response如何交给Container进行处理的？</li>
<li>Container处理完之后如何交给Connector并返回给客户端的？ 首先看一下Connector的结构图，如下所示：</li>
</ol>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Connector%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Connector结构图"></p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler 代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的， Http11NioProtocol使用的是NioSocket来连接的。 </p>
<p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。 </p>
<ol>
<li>Endpoint用来处理底层Socket的网络连接，Processor用于将 Endpoint接收到的Socket封装成Request，Adapter用于将Request交给 Container进行具体的处理。 </li>
<li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实 现TCP&#x2F;IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适 配到Servlet容器进行具体的处理。 </li>
<li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和 AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请 求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收 到的Socket，在内部调用Processor进行处理。</li>
</ol>
<p>至此，我们应该很轻松的回答1，2，3的问题了，但是4还是不知道，那么我们 就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果 返回给Connector的？</p>
<h2 id="9-Container架构分析"><a href="#9-Container架构分析" class="headerlink" title="9. Container架构分析"></a>9. Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Container 内部包含了4个子容器，结构图如下：</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Container%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90.png" alt="Container架构分析"></p>
<p>4个子容器的作用分别是： </p>
<ol>
<li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个 Engine； </li>
<li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加 站点； </li>
<li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个 WEB-INF目录以及下面的web.xml文件； </li>
<li>Wrapper：每一Wrapper封装着一个Servlet； 下面找一个Tomcat的文件目录对照一下，如下图所示：</li>
</ol>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Tomcat%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="Tomcat文件目录"></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置 下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着 主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。 </p>
<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问， 例如：<a target="_blank" rel="noopener" href="http://www.baidu.com,如果是host(webapps)下的其他应用,则可以使/">www.baidu.com，如果是Host（webapps）下的其他应用，则可以使</a> 用<a target="_blank" rel="noopener" href="http://www.baidu.com/docs%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%BD%93%E7%84%B6%E9%BB%98%E8%AE%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A0%B9%E5%BA%94%E7%94%A8%EF%BC%88ROOT%EF%BC%89%E6%98%AF%E5%8F%AF%E4%BB%A5">www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以</a> 进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。 </p>
<p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行请 求处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下 边就开始探讨一下Container是如何进行处理的！</p>
<h2 id="10-Container如何处理请求的"><a href="#10-Container如何处理请求的" class="headerlink" title="10. Container如何处理请求的"></a>10. Container如何处理请求的</h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之 意） </p>
<p>Pipeline-Valve是<strong>责任链模式</strong>，责任链模式是指在一个请求处理的过程中有很多 处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将 处理后的结果返回，再让下一个处理者继续处理。</p>
<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主 要有以下两点： </p>
<p>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个 Valve叫做BaseValve，BaseValve是不可删除的； </p>
<p>在上层容器的管道的BaseValve中会调用下层容器的管道。 </p>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别 </p>
<p>在：StandardEngineValve、StandardHostValve、StandardContextValve、 StandardWrapperValve。 </p>
<p>Pipeline的处理流程图如下：</p>
<p><img src="/10-Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Container%E5%9B%9B%E4%B8%AA%E5%AD%90%E5%AE%B9%E5%99%A8%E7%9A%84BaseValve.png" alt="Container四个子容器的BaseValve"></p>
<ul>
<li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处 理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管 道）； </li>
<li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等， 最后会执行StandardEngineValve，在StandardEngineValve中会调用 Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在 执行StandardHostValve，然后再依次调用Context的管道和Wrapper的 管道，最后执行到StandardWrapperValve。 </li>
<li>当执行到StandardWrapperValve的时候，会在 StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处 理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和 Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet 的service方法，这样请求就得到了处理！ </li>
<li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求， 这个时候就可以将返回的结果交给Connector了，Connector在通过 Socket的方式将结果返回给客户端。</li>
</ul>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:27" itemprop="dateModified" datetime="2021-03-03T13:51:27+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h1><h2 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h2><h3 id="数据保存在内存"><a href="#数据保存在内存" class="headerlink" title="数据保存在内存"></a>数据保存在内存</h3><p>优点：存取速度快</p>
<p>缺点：数据不能永久保存</p>
<h3 id="数据保存在文件"><a href="#数据保存在文件" class="headerlink" title="数据保存在文件"></a>数据保存在文件</h3><p>优点：数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的IO操作。</p>
<p>​			2）查询数据不方便</p>
<h3 id="数据保存在数据库"><a href="#数据保存在数据库" class="headerlink" title="数据保存在数据库"></a>数据保存在数据库</h3><p>1）数据永久保存</p>
<p>2）使用SQL语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
<h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>结构化查询语言(StructuredQueryLanguage)简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h2 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQLAB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS(RelationalDatabaseManagementSystem，关系数据库管理系统)应用软件之一。在Java企业级开发中非常常用，因为MySQL是开源免费的，并且方便扩展。</p>
<h2 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p>
<p>db权限表：记录各个帐号在各个数据库上的操作权限。</p>
<p>table_priv权限表：记录数据表级的操作权限。</p>
<p>columns_priv权限表：记录数据列级的操作权限。</p>
<p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p>
<h2 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如altertable)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h2><table>
<thead>
<tr>
<th>分类</th>
<th>类型名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
<td></td>
</tr>
<tr>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
<td></td>
</tr>
<tr>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
<td></td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td></td>
</tr>
<tr>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
<td></td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY1901~2155</td>
</tr>
<tr>
<td>time</td>
<td>HH:MM:SS-838:59:59~838:59:59</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>YYYYMM-DD1000-01-01~9999-12-3</td>
<td></td>
</tr>
<tr>
<td>datetime</td>
<td>YYYYMM-DDHH:MM:SS1000-01-0100:00:00~9999-12-3123:59:59</td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td>YYYYMM-DDHH:MM:SS1970010100:00:01UTC~2038-01-1903:14:07UTC</td>
<td></td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td><strong>CHAR(M)</strong></td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
<td></td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
<td></td>
</tr>
<tr>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
<td></td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
<td></td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
<td></td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
<td></td>
</tr>
<tr>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
<td></td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
<td></td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
<td></td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
<td></td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
<td></td>
</tr>
</tbody></table>
<p><strong>整数类型</strong>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p>
<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNEDZEROFILL属性配合使用才有意义。</p>
<p>例子，假定类型设定为INT(5)，属性为UNSIGNEDZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
<p><strong>实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
<p><strong>字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p><strong>使用策略：</strong></p>
<p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</p>
<p>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</p>
<p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
<p><strong>枚举类型（ENUM）</strong>，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数</p>
<p><strong>日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。</p>
<p>看到这里，这道真题是不是就比较容易回答了。</p>
<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><h2 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h2><p>存储引擎Storageengine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<p><strong>Innodb引擎：</strong>Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p>
<p><strong>MyIASM引擎(原本Mysql的默认引擎)：</strong>不提供事务的支持，也不支持行级锁和外键。</p>
<p><strong>MEMORY引擎：</strong>所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p>
<p><strong>MyISAM与InnoDB区别</strong></p>
<table>
<thead>
<tr>
<th>MyISAM</th>
<th>Innodb</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份binlog，或者用mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据.MYD，索引.MYI</td>
<td>数据和索引是集中存储的，.ibd</td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td>InnoDB更优</td>
<td></td>
</tr>
<tr>
<td>selectcount(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam是堆表</td>
<td>B+树索引，Innodb是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a><strong>MyISAM索引与InnoDB索引的区别？</strong></h2><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h2 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a><strong>InnoDB引擎的4大特性</strong></h2><ul>
<li>插入缓冲（insertbuffer)</li>
<li>二次写(doublewrite)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(readahead)</li>
</ul>
<h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>如果没有特别的需求，使用默认的Innodb即可。<br>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。<br>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，<br>支持事务和外键。比如OA自动化办公系统。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它<br>们包含着对数据表里所有记录的引用指针。<br>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，<br>以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种<br>B+树。<br>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索<br>引形成目录。索引是一个文件，它是要占据物理空间的。</p>
<h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201111145020510.png" alt="image-20201111145020510"></p>
<p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选<br>的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1‐‐增加一个没有建立索引的字段</span><br><span class="line">2altertableinnodb1addsexchar(1);</span><br><span class="line">3‐‐按sex检索时可选的索引为null</span><br><span class="line">4EXPLAINSELECT*frominnodb1wheresex=&#x27;男&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.jpg" alt="09-MySQL数据库面试题（2020最新版）-重点"></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引<br>（altertable表名addindex(字段名)），同样的SQL执行的效率，你会发现查询效率<br>会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<p>orderby<br>当我们使用orderby将查询结果按照某个字段排序时，如果该字段没有建立索<br>引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取<br>到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需<br>要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过<br>多都会降低效率），更无论读到内存之后的排序了。<br>但是如果我们对该字段建立索引altertable表名addindex(字段名)，那么由于索引<br>本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如<br>果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那</p>
<p>取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能<br>的）<br>join<br>对join语句匹配关系（on）涉及的字段建立索引能够提高效率<br>索引覆盖<br>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原<br>始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。<br>因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几<br>率。<br>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在<br>于其体积小。</p>
<h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><p>**主键索引:**数据列不允许重复，不允许为NULL，<br>一个表只能有一个主键。</p>
<p>**唯一索引:**数据列不允许重复，允许为NULL值，<br>一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过ALTERTABLEtable_nameADDUNIQUE(column);<br>创建唯一索引</li>
<li>可以通过ALTERTABLEtable_nameADDUNIQUE(column1,column2);<br>创建唯一组合索引</li>
</ul>
<p>**普通索引:**基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li><p>可以通过ALTERTABLEtable_nameADDINDEXindex_name(column);<br>创建普通索引</p>
</li>
<li><p>可以通过ALTERTABLEtable_nameADDINDEXindex_name(column1,column2,column3);<br>创建组合索引</p>
</li>
<li><p><strong>全文索引：</strong>是目前搜索引擎使用的一种关键技术。<br>可以通过ALTERTABLEtable_nameADDFULLTEXT(column);<br>创建全文索引</p>
</li>
</ul>
<h2 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h2><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有</p>
<p>Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；其余大部分场景，建议选择BTree索引。</p>
<p>1）B树索引mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持</p>
<p>BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B%E6%A0%91.jpg" alt="B树"></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度快</p>
<p>B+tree性质：</p>
<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字。</p>
<p>4.）B+树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+树有2个头指针，一个是树的根节点，一个是小关键码的叶节点。2）哈希索引简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在</p>
<p>mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生</p>
<p>Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.jpg" alt="哈希索引"></p>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li><p>把创建了索引的列的内容进行排序</p>
</li>
<li><p>对排序结果生成倒排表</p>
</li>
<li><p>在倒排表内容上拼上数据地址链</p>
</li>
<li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>
</li>
</ol>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><p>索引算法有BTree算法和Hash算法</p>
<p>BTree算法</p>
<p>BTree是常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	‐‐只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">2	select*fromuserwherenamelike&#x27;jack%&#x27;;</span><br><span class="line">3	‐‐如果一通配符开头，或者没有使用常量，则不会使用索引，例如：</span><br><span class="line">4	select*fromuserwherenamelike&#x27;%jack&#x27;;</span><br></pre></td></tr></table></figure>

<p>Hash算法</p>
<p>HashHash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><p>\1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列</p>
<p>\2.基数较小的类，索引效果较差，没有必要在此列建立索引</p>
<p>\3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</p>
<p>\4.不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<h3 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，好符合一下几个原则</p>
<p>1）左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a&#x3D;1andb&#x3D;2andc&gt;3andd&#x3D;4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立</p>
<p>(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。8）对于定义为text、image和bit的数据类型的列不要建立索引。创建索引的三种方式，删除索引</p>
<p>第一种方式：在执行CREATETABLE时创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	CREATETABLEuser_index2(</span><br><span class="line">2	idINTauto_incrementPRIMARYKEY,</span><br><span class="line">3	first_nameVARCHAR(16),</span><br><span class="line">4	last_nameVARCHAR(16),</span><br><span class="line">5	id_cardVARCHAR(18),</span><br><span class="line">6	informationtext,</span><br><span class="line">7	KEYname(first_name,last_name),</span><br><span class="line">8	FULLTEXTKEY(information),</span><br><span class="line">9	UNIQUEKEY(id_card));</span><br></pre></td></tr></table></figure>

<p>第二种方式：使用ALTERTABLE命令去增加索引</p>
<p><code>1ALTERTABLEtable_nameADDINDEXindex_name(column_list);</code></p>
<p>ALTERTABLE用来创建普通索引、UNIQUE索引或PRIMARYKEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTERTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用CREATEINDEX命令创建</p>
<p><code>1CREATEINDEXindex_nameONtable_name(column_list);</code></p>
<p>CREATEINDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARYKEY索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：altertable表名dropKEY索引名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	altertableuser_indexdropKEYname;</span><br><span class="line">2	altertableuser_indexdropKEYid_card;</span><br><span class="line">3	altertableuser_indexdropKEYinformation;</span><br></pre></td></tr></table></figure>

<p>删除主键索引：altertable表名dropprimarykey（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%88%A0%E9%99%A4%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg" alt="删除主键索引"></p>
<p>需要取消自增长再行删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	altertableuser_index</span><br><span class="line">2	‐‐重新定义字段</span><br><span class="line">3	MODIFYidint,</span><br><span class="line">4	dropPRIMARYKEY</span><br></pre></td></tr></table></figure>

<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOTNULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<p>索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5次的磁盘I&#x2F;O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEXRANGESCAN)适用于两种情况:</p>
<p>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</p>
<p>基于非唯一性索引的检索</p>
<h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li><p>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</p>
</li>
<li><p>然后删除其中无用数据（此过程需要不到两分钟）</p>
</li>
<li><p>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分</p>
</li>
</ol>
<p>钟左右。</p>
<ol start="4">
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相</p>
<p>同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>我们可以利用selectcount(*)&#x2F;count(distinctleft(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p>
<h2 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h2><p>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中</p>
<p>使用最频繁的一列放在最左边。</p>
<p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a&#x3D;1andb&#x3D;2andc&gt;3andd&#x3D;4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>&#x3D;和in可以乱序，比如a&#x3D;1andb&#x3D;2andc&#x3D;3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树</p>
<p>中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
<p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="B树和B+树的区别"></p>
<h2 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h2><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h2 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h2><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应</p>
<p>的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。</p>
<p>对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然</p>
<p>后根据查询判断是否需要回表查询数据。</p>
<p>么可以看出他们有以下的不同：</p>
<p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<p>hash索引不支持使用索引进行排序，原理同上。</p>
<p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函</p>
<p>数的不可预测。AAAA和AAAAB的索引没有相关性。</p>
<p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索</p>
<p>引，覆盖索引等)的时候可以只通过索引完成查询。</p>
<p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。</p>
<p>而不需要使用hash索引。</p>
<h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p>
<p>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般来说，索引本</p>
<p>身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结</p>
<p>点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读</p>
<p>写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p>
<p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p>
<p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p>
<p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以</p>
<p>有序的链表结构存储，这样可很好提高增删效率。</p>
<h2 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据</h2><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再</p>
<p>次进行回表查询。</p>
<h2 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h2><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
<p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg" alt="何时使用聚簇索引"></p>
<h2 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h2><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了</p>
<p>索引，那么就不必再进行回表查询</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h2 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h2><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h2 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h2><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/ACID%E8%A7%84%E5%88%99.jpg" alt="ACID规则"></p>
<p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作</p>
<p>要么全部完成，要么完全不起作用；</p>
<ol start="2">
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的</li>
</ol>
<p>结果是相同的；</p>
<ol start="3">
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各</li>
</ol>
<p>并发事务之间数据库是独立的；</p>
<ol start="4">
<li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h2 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h2><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这</p>
<p>可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<h2 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复  读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ- UNCOM MITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-  COMMIT  TED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATA BLE- READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZ  ABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle默认采用的 READ_COMMITTED隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h2><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来</p>
<p>保证访问的次序，锁机制就是这样的一个机制。</p>
<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>
<h2 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h2><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修</p>
<p>改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不</p>
<p>释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
<h2 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h2><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，</p>
<p>并发度也最高。</p>
<p>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，</p>
<p>并发度最低。</p>
<p>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和</p>
<p>行锁之间，并发度一般</p>
<h2 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h2><h2 id="像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="像上面那样子进行锁定岂不是有点阻碍并发效率了"></a>像上面那样子进行锁定岂不是有点阻碍并发效率了</h2><p>从锁的类别上来讲，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>
<h2 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h2><p>答：InnoDB是基于索引来完成行锁</p>
<p>例: select * from tab_with_index where id &#x3D; 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>
<h2 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h2><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>相关知识点：</p>
<ol>
<li><p>innodb对于行的查询使用next-key lock </p>
</li>
<li><p>Next-locking keying为了解决Phantom Problem幻读问题</p>
</li>
<li><p>当查询的索引含有唯一属性时，将next-key lock降级为record key</p>
</li>
<li><p>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</p>
</li>
<li><p>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</p>
</li>
</ol>
<h2 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
<h2 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<p>两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行</p>
<p>retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h2><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性</p>
<h2 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h2><p>视图的特点如下:</p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。视图的操作包括创建视图，查看视图，删除视图和修改视图。</li>
</ul>
<h2 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h2><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<p>下面是视图的常见使用场景：重用SQL语句；</p>
<ul>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据</li>
</ul>
<h2 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h2><ol>
<li><p>查询简单化。视图能简化用户的操作</p>
</li>
<li><p>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</p>
</li>
</ol>
<p>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</p>
<h2 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h2><ol>
<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的这些视图有如下特征：</p>
<ol>
<li>有UNIQUE等集合操作符的视图。<br>2.有GROUP BY子句的视图。<br>3.有诸如AVG\SUM\MAX等聚合函数的视图。<br>4.使用DISTINCT关键字的视图。<br>5.连接表的视图（其中有些例外）</li>
</ol>
</li>
</ol>
<h2 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h2><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理</p>
<h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<p>优点</p>
<p>1）     存储过程是预编译过的，执行效率高。</p>
<p>2）     存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）     安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）     存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<p>缺点</p>
<p>1）     调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）     移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）     重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）     如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，   后如果用</p>
<p>户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h2 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h2><ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete </li>
<li>After Delete</li>
</ul>
<h1 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h1><h2 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h2><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER 主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，</p>
<p>DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，</p>
<p>COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等</p>
<h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><p> 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>​             候选键：是  小超键，即没有冗余元素的超键。</p>
<p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。</p>
<p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<p>​            外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h2 id="SQL约束有哪几种？"><a href="#SQL约束有哪几种？" class="headerlink" title="SQL约束有哪几种？"></a>SQL约束有哪几种？</h2><p>SQL 约束有哪几种？</p>
<p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p>
<p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p>
<p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p>
<p> FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<p>​            CHECK: 用于控制字段的值范围。</p>
<h2 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h2><p>交叉连接（CROSS JOIN）</p>
<p>内连接（INNER JOIN）</p>
<p>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</p>
<p>联合查询（UNION与UNION ALL）</p>
<p>全连接（FULL JOIN）</p>
<p>交叉连接（CROSS JOIN）</p>
<p>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER </p>
<p>JOIN）SELECT * FROM A,B WHERE A.id&#x3D;B.id或者SELECT * FROM A INNER JOIN B </p>
<p>ON A.id&#x3D;B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p>
<p>​            </p>
<p>内连接分为三类</p>
<p>等值连接：ON A.id&#x3D;B.id 不等值连接：ON A.id &gt; B.id</p>
<p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id&#x3D;T2.pid</p>
<p>外连接（LEFT JOIN&#x2F;RIGHT JOIN） </p>
<p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联</p>
<p>条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN </p>
<p>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关</p>
<p>联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p>
<p>联合查询（UNION与UNION ALL）</p>
<p>SELECT * FROM A UNION SELECT * FROM B UNION …</p>
<p>1</p>
<p>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查</p>
<p>询的列数要相等，相同的记录行会合并如果使用UNION ALL，不会合并重复的记录行效率 UNION 高于 UNION ALL</p>
<p>全连接（FULL JOIN）</p>
<p>MySQL不支持全连接</p>
<p>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</p>
<p>SELECT * FROM A LEFT JOIN B ON A.id&#x3D;B.id UNION SELECT * FROM A RIGHT JOIN B ON A.id&#x3D;B.id</p>
<p>​            1</p>
<p>表连接面试题有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>
<p>R表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p>S表</p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol>
<li>交叉连接(笛卡尔积):</li>
</ol>
<p>select r.<em>,s.</em> from r,s</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol>
<li>内连接结果：</li>
</ol>
<p>select r.<em>,s.</em> from r inner join s on r.c&#x3D;s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<ol>
<li>左连接结果：</li>
</ol>
<p>select r.<em>,s.</em> from r left join s on r.c&#x3D;s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>右连接结果：</li>
</ol>
<p>select r.<em>,s.</em> from r right join s on r.c&#x3D;s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>全表连接的结果（MySql不支持，Oracle支持）：</li>
</ol>
<p>select r.<em>,s.</em> from r full join s on r.c&#x3D;s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h2><ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果 </li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<h2 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a>子查询的三种情况</h2><ol>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：&#x3D;、 &lt;、 &gt; 等运算符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	‐‐ 查询工资最高的员工是谁？</span><br><span class="line">2	select * from employee where salary=(select max(salary) from employee);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	‐‐ 查询工资最高的员工是谁？</span><br><span class="line">2	select * from employee where salary=(select max(salary) from employee);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where 条件，用于select子句中做为子表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	‐‐ 1) 查询出2011年以后入职的员工信息</span><br><span class="line">2	‐‐ 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span><br><span class="line">3	select * from dept d, (select * from employee where join_date &gt;&#x27;2011‐1‐</span><br><span class="line">1&#x27;) e where e.dept_id = d.id;</span><br><span class="line">4	‐‐ 使用表连接：</span><br><span class="line">5	select d.*, e.* from dept d inner join employee e on d.id = e.dept_id whe re e.join_date &gt;&#x27;2011‐1‐1&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="mysql中in和exists区别"><a href="#mysql中in和exists区别" class="headerlink" title="mysql中in和exists区别"></a>mysql中in和exists区别</h2><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop</p>
<p>循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<ol>
<li><p>如果查询的两个表大小相当，那么用in和exists差别不大。</p>
</li>
<li><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p>
</li>
<li><p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p>
</li>
</ol>
<h2 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h2><p>char的特点</p>
<p>char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；</p>
<p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法； </p>
<p>   对于char来说，   多能存放的字符个数为255，和编码无关 varchar的特点</p>
<p>varchar表示可变长字符串，长度是可变的；</p>
<p>插入的数据是多长，就按照多长来存储；</p>
<p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p>
<p> 对于varchar来说， 多能存放的字符个数为65532 总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h2 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h2><p>多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排</p>
<p>序时会消耗更多内存，因为order by col采用fixed_length计算col长度</p>
<p>(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<h2 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h2><p>是指显示字符的长度。20表示 大显示宽度为20，但仍占4字节存储，存储范围不变；</p>
<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h2 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h2><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和 int(20)存储和计算均一样；</p>
<h2 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h2><ul>
<li>int(10)的10表示显示的数据的长度，不是存储数据的大小； chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li>
</ul>
<p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位 char(10) 10位固定字符串，不足补空格   多10个字符</p>
<p>varchar(10) 10位可变字符串，不足补空格  多10个字符</p>
<ul>
<li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li>
<li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li>
</ul>
<h2 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h2><p>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</p>
<p>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</p>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><h3 id="三者都表示删除，但是三者有一些差别："><a href="#三者都表示删除，但是三者有一些差别：" class="headerlink" title="三者都表示删除，但是三者有一些差别："></a>三者都表示删除，但是三者有一些差别：</h3><table>
<thead>
<tr>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度快</td>
</tr>
</tbody></table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用truncate。</p>
<h2 id="UNION与UNIONALL的区别？"><a href="#UNION与UNIONALL的区别？" class="headerlink" title="UNION与UNIONALL的区别？"></a>UNION与UNIONALL的区别？</h2><p>如果使用UNION ALL，不会合并重复的记录行 </p>
<p>效率 UNION 高于 UNION ALL</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="如何定位及优化SQL语句的性能问题？"><a href="#如何定位及优化SQL语句的性能问题？" class="headerlink" title="如何定位及优化SQL语句的性能问题？"></a>如何定位及优化SQL语句的性能问题？</h2><h2 id="创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h2><p>对于低性能的SQL语句的定位， 重要也是 有效的方法就是使用执行计划， MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.jpg" alt="执行计划"></p>
<p>执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p>select_type 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_ty pe</th>
<th>descripti on</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询  或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询  外层查询就显示为   PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUER Y</td>
<td>在select或  where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在  union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION 中获取结果集，例如上文的</td>
</tr>
<tr>
<td></td>
<td></td>
<td>第三个例子</td>
</tr>
</tbody></table>
<p>table 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id </p>
<p>partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	create table tmp (</span><br><span class="line">2	id int unsigned not null AUTO_INCREMENT,</span><br><span class="line">3	name varchar(255),</span><br><span class="line">4	PRIMARY KEY(id))</span><br><span class="line">5	engine=innodb partition by key(id) partitions 5;</span><br></pre></td></tr></table></figure>

<p>type(非常重要，可以看到有没有走索引) 访问类型</p>
<p>ALL 扫描全表数据 index 遍历索引 range 索引范围查找 index_subquery 在子查询中使用 ref unique_subquery 在子查询中使用 eq_ref ref_or_null 对Null进行索引的优化的 ref fulltext 使用全文索引</p>
<p>ref 使用非唯一索引查找数据 eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</p>
<p>possible_keys 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p>key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。 TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>
<p>key_length 索引长度</p>
<p>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows 返回估算的结果集数目，并不是一个准确的值。</p>
<p>extra 的信息非常丰富，常见的有：</p>
<ol>
<li><p>Using index 使用覆盖索引</p>
</li>
<li><p>Using where 使用了用where子句来过滤结果集</p>
</li>
<li><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p>
</li>
<li><p>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</p>
</li>
</ol>
<p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是</p>
<p>consts 好。 说明： 1） consts 单表中  多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p>
<h2 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h2><ol>
<li><p>应用服务器与数据库服务器建立一个连接</p>
</li>
<li><p>数据库进程拿到请求sql</p>
</li>
<li><p>解析并生成执行计划，执行</p>
</li>
<li><p>读取数据到内存并进行逻辑处理</p>
</li>
<li><p>通过步骤一的连接，发送结果到客户端</p>
</li>
<li><p>关掉连接，释放资源</p>
</li>
</ol>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/sql%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="sql的生命周期"></p>
<h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><ol>
<li><p>优化shema、sql语句+索引；</p>
</li>
<li><p>第二加缓存，memcached, redis；</p>
</li>
<li><p>主从复制，读写分离；</p>
</li>
<li><p>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p>
</li>
<li><p>水平切分，针对数据量大的表，这一步 麻烦， 能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，</p>
</li>
</ol>
<p>做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p>
<h2 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h2><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种, 但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>
<p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset</p>
<p>行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联：</p>
<p><code> SELECT a.* FROM 表1 a,(select id from 表1 where 条件 LIMIT 100000,20) b w here a.id=b.id</code></p>
<h2 id="mysql分页"><a href="#mysql分页" class="headerlink" title="mysql分页"></a>mysql分页</h2><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的  大数目。初始记录行的偏移量是 0(而不是 1)</p>
<p>mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15 </p>
<p>​            1</p>
<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 </p>
<p>-1：</p>
<p>mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last. </p>
<p>​            1</p>
<p>如果只给定一个参数，它表示返回 大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行 </p>
<p>​            1</p>
<p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>
<p>开启慢查询日志</p>
<p>配置项：slow_query_log 可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为</p>
<p>OFF，可以使用set GLOBAL slow_query_log &#x3D; on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>
<p>设置临界时间</p>
<p>配置项：long_query_time 查看：show VARIABLES like ‘long_query_time’，单位秒设置：set long_query_time&#x3D;0.5</p>
<p>实操时应该从长时间设置到短的时间，即将 慢的SQL优化掉</p>
<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>
<h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><h3 id="慢查询都怎么优化过？"><a href="#慢查询都怎么优化过？" class="headerlink" title="慢查询都怎么优化过？"></a>慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是 load了不需要的数据列？还是数据量太大？所以优化也是针对这三个方向来的，</p>
<p> 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p>
<p> 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p>
<p>​          如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p>
<h2 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h2><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h2 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h2><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h2 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h2><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar 来存储，这样可以节省空间且提高检索效率。</p>
<h2 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h2><p>访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据，可能是太多行或列确认MySQL服务器是否在分析大量不必要的数据行避免犯如下SQL语句错误</p>
<p>查询不需要的数据。解决办法：使用limit解决</p>
<p>多表关联返回全部列。解决办法：指定列名</p>
<p>总是返回全部列。解决办法：避免使用SELECT * 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存是否在扫描额外的记录。解决办法：</p>
<p>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</p>
<p> 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</p>
<p>改变数据库和表的结构，修改数据表范式</p>
<p>重写SQL语句，让优化器可以以更优的方式执行查询。</p>
<h2 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h2><p>一个复杂查询还是多个简单查询</p>
<p>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</p>
<p>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</p>
<p>切分查询将一个大的查询分为多个小的相同的查询</p>
<p>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</p>
<p>分解关联查询，让缓存的效率更高。</p>
<p>执行单个查询可以减少锁的竞争。</p>
<p>在应用层做关联更容易对数据库进行拆分。</p>
<p>查询效率会有大幅提升。</p>
<p>较少冗余记录的查询</p>
<h2 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h2><p> count(<em>)会忽略所有的列，直接统计所有列数，不要使用count(列名) MyISAM中，没有任何where条件的count(</em>)非常快。</p>
<p>当有where条件时，MyISAM的count统计不一定比其它引擎快。</p>
<p>可以使用explain查询近似值，用近似值替代count(*) 增加汇总表使用缓存</p>
<h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><p>确定ON或者USING子句中是否有索引。</p>
<p>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引</p>
<h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>用关联查询替代</p>
<p>优化GROUP BY和DISTINCT</p>
<p>这两种查询据可以使用索引来优化，是  有效的优化方法关联查询中，使用标识列分组的效率更高</p>
<p>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</p>
<p> WITH ROLLUP超级聚合，可以挪到应用程序处理</p>
<h2 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h2><p>LIMIT偏移量大的时候，查询效率较低</p>
<p>可以记录上次查询的   大ID，下次查询时直接根据该ID来查询</p>
<h2 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h2><p>UNION ALL的效率高于UNION</p>
<h2 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h2><p>解题方法对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>
<p>SQL语句优化的一些方法？</p>
<p> 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p> 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p><code>1 select id from t where num is null ‐‐ 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</code></p>
<p> 3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
<p> 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p><code>1 select id from t where num=10 or num=20 ‐‐ 可以这样查询：select id from t where num=10 union all select id from t where num=20</code></p>
<p>​            5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<p><code>1 select id from t where num in(1,2,3) ‐‐ 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</code></p>
<p> 6.下面的查询也将导致全表扫描：select id from t where name like ‘% 李%’若要提高效率，可以考虑全文检索。</p>
<p> 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p><code>1 select id from t where num=@num ‐‐可以改为强制查询使用索引：select id from t with (index(索引名)) where num=@num</code></p>
<p> 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p><code>1 select id from t where num/2=100 ‐‐ 应改为:select id from t where num=100*2</code></p>
<p> 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p><code>1 select id from t where substring(name,1,3)=’abc’ ‐‐ name以abc开头的id应改为: select id from t where name like ‘abc%’</code></p>
<p> 10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><p>系统的吞吐量瓶颈往往出现在数据库的访问速度上随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢数据是存放在磁盘上的，读写速度无法和内存相比优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p>将字段很多的表分解成多个表对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p>增加中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>
<p>增加冗余字段设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
<p>注意：</p>
<p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题</p>
<h2 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h2><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整,比如说限制连接数等</p>
<h2 id="大表怎么优化？某个表有近千万数据，"><a href="#大表怎么优化？某个表有近千万数据，" class="headerlink" title="大表怎么优化？某个表有近千万数据，"></a>大表怎么优化？某个表有近千万数据，</h2><h2 id="CRUD比较慢，如何优化？分库分表了是怎么"><a href="#CRUD比较慢，如何优化？分库分表了是怎么" class="headerlink" title="CRUD比较慢，如何优化？分库分表了是怎么"></a>CRUD比较慢，如何优化？分库分表了是怎么</h2><h2 id="做的？分表分库了有什么问题？有用到中间"><a href="#做的？分表分库了有什么问题？有用到中间" class="headerlink" title="做的？分表分库了有什么问题？有用到中间"></a>做的？分表分库了有什么问题？有用到中间</h2><h2 id="件么？他们的原理知道么？"><a href="#件么？他们的原理知道么？" class="headerlink" title="件么？他们的原理知道么？"></a>件么？他们的原理知道么？</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><p>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</p>
</li>
<li><p>读&#x2F;写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</p>
</li>
<li><p>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p>
</li>
</ol>
<p>有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ol>
<li>垂直分区：</li>
</ol>
<p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86.jpg" alt="垂直拆分"></p>
<p>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少</p>
<p>I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可</p>
<p>以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.jpg" alt="垂直分表"></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>1、    如果一个表中某些列常用，另外一些列不常用</p>
<p>2、    可以使数据行变小，一个数据页能存储更多数据，查询时减少I&#x2F;O次数</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p> 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差 对于应用层来说，逻辑算法增加开发成本管理冗余列，查询所有数据需要join操作</p>
<ol start="2">
<li>水平分区：</li>
</ol>
<p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA.jpg" alt="水平分区"></p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升</p>
<p>MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p>
<p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p>
<h3 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a>水平分表：</h3><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.jpg" alt="水平分表"></p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p> 1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p>
<p>​                    2、需要把数据存放在多个介质上。</p>
<p>水平切分的缺点</p>
<p> 1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p>
<p> 2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<p> 客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-</p>
<p>JDBC 、阿里的TDDL是两种比较常用的实现。</p>
<p> 中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat </p>
<p>、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<p>分库分表后面临的问题</p>
<p> 事务支持 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
<p>​           跨库join</p>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>
<p> 跨节点的count,order by,group by以及聚合函数问题 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<p> 数据迁移，容量规划，扩容等问题 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是 1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是</p>
<p>十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了</p>
<p>Sharding扩容的难度。</p>
<p>ID问题</p>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行</p>
<p>SQL路由. 一些常见的主键生成策略</p>
<p>UUID 使用UUID作主键是   简单的方案，但是缺点也是非常明显的。由于</p>
<p>UUID非常的长，除占用大量存储空间外， 主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法</p>
<p>Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter 的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>
<p> 跨分片的排序分页般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了  终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，  后再返回给用户。如下图所示：</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%88%86%E7%89%87.jpg" alt="分片"></p>
<h2 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h2><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<p>主从复制的作用</p>
<ol>
<li><p>主数据库出现问题，可以切换到从数据库。</p>
</li>
<li><p>可以进行数据库层面的读写分离。</p>
</li>
<li><p>可以在从数据库上进行日常备份。</p>
</li>
</ol>
<p>MySQL主从复制解决的问题</p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份负载均衡：降低单个服务器的压力高可用和故障切换：帮助应用程序避免单点失败升级测试：可以用更高版本的MySQL作为从库</li>
<li>MySQL主从复制工作原理</li>
<li>在主库上把数据更高记录到二进制日志从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中基本原理流程，3个线程以及之间的关联</li>
</ul>
<p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的 binlog中；从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>
<p>从：sql执行线程——执行relay log中的语句；</p>
<p><img src="/09-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.jpg" alt="复制过程"></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog文件中。</p>
<p>第二步：salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程 终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h2 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h2><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running&#x3D;NO，此时你需要按照前面提到的手动同步一下slave）。</p>
<p>方案一</p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用缺点：降低性能， 不支持事务方案二</p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过</p>
<p>mybatis plugin拦截sql语句，所有的insert&#x2F;update&#x2F;delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下</p>
<p>DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>
<p>方案三</p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务. 缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理</p>
<h2 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h2><p>(1)备份计划视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 </p>
<p>mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p>(2)备份恢复时间</p>
<p>物理备份恢复快，逻辑备份恢复慢</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<p>20G的2分钟（mysqldump）</p>
<p>80G的30分钟(mysqldump)</p>
<p>111G的30分钟（mysqldump)</p>
<p>288G的3小时（xtra)</p>
<p>3T的4小时（xtra)</p>
<p>逻辑导入时间一般是备份时间的5倍以上</p>
<p>(3)备份恢复失败如何处理首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<p>(4)mysqldump和xtrabackup实现原理 mysqldump mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION </p>
<p>TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个</p>
<p>事务(START TRANSACTION &#x2F;*!40100 WITH CONSISTENTSNAPSHOT *&#x2F;)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data&#x3D;1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
<p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。  后完成 innodb 的备份后，会做一个 flush engine logs 的</p>
<p>操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢 后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>
<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
<h2 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h2><p>使用 myisamchk 来修复，具体步骤：</p>
<p>1）   修复前将mysql服务停止。</p>
<p>2）   打开命令行方式，然后进入到mysql的&#x2F;bin目录。</p>
<p>3）   执行myisamchk –recover 数据库所在路径&#x2F;*.MYI使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE </p>
<p>table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE </p>
<p>TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/08-Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/08-Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:26" itemprop="dateModified" datetime="2021-03-03T13:51:26+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h2><p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/JVM的主要组成部分.png" alt="JVM 的主要组成部分"></p>
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、 Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据 区)、Native Interface(本地接口)。 </p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。 </li>
<li>Execution engine（执行引擎）：执行classes中的指令。 </li>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语 言交互的接口。 </li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内 存。</li>
</ul>
<p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader） 再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方 法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作 系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将 字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他 语言的本地库接口（Native Interface）来实现整个程序的功能。 </p>
<p>**下面是Java程序运行机制详细说明 **</p>
<p>Java程序运行机制步骤 </p>
<p>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java； </p>
<p>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名 为.class； </p>
<p>运行字节码的工作是由解释器(java命令)来完成的。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/Java程序运行机制.png" alt="Java程序运行机制"></p>
<p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这 些.class文件加载到JVM中。 </p>
<p>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入 到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个  java.lang.Class对象，用来封装类在方法区内的数据结构。 </p>
<h2 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h2><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个 不同的数据区域。</strong>这些区域都有各自的用途，以及创建和销毁的时间，有些区域 随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销 毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/Java虚拟机内存区域.png" alt="Java虚拟机内存区域"></p>
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范，  Java 虚拟机规范规定的区域分为以下 5 个部分： </p>
<ul>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号 指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的 字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个 计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息； </li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚 拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的； </li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存大的一块，是被所有线程共享 的，几乎所有的对象实例都在这里分配内存； </li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址， </p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内存， </p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的 错误。 </p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来 的对象也会相应的改变。 </p>
<p>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。 </p>
<h2 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h2><p>物理地址 </p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到 不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩） 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性 能快。 </p>
<p>**内存分别 **</p>
<p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般 堆大小远远大于栈。 </p>
<p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。 </p>
<p>**存放的内容 **</p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储 </p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。<br>PS：</p>
<ol>
<li>静态变量放在方法区 </li>
<li>静态的对象还是放在堆。</li>
</ol>
<p>程序的可见度 </p>
<p>堆对于整个应用程序都是共享、可见的。 </p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h2 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。 </p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进 栈，栈的删除称为出栈。 </li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进 栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。 </li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原 则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列 头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当 前栈中新的元素，即后插入（进栈）的元素，而先插入的被放在栈的底部，要到后才能删除。</li>
</ul>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p> 说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p>下面是对象创建的主要流程:</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/对象创建的主要流程.png" alt="对象创建的主要流程"></p>
<p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有， 必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是 绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表 中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有 两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation  Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信 息、哈希码…)，后执行方法。 </p>
<h2 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java 堆是否规整，有两种方式： </p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的 放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小 相等的距离，这样便完成分配内存工作。 </li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录 那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对 象，并在分配后更新列表记录。</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所 采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/内存分配的两种方式.png" alt="内存分配的两种方式"></p>
<h2 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h2><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的 位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还 没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个 问题有两种方案： </p>
<p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的 原子性）； </p>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆 中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,  TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并 分配新的 TLAB 时，才需要同步锁。通过-XX:+&#x2F;-UserTLAB参数来设定虚拟机是否使 用TLAB。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/内存分配时保证线程安全的两种方式.png" alt="内存分配时保证线程安全的两种方式"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>Java</strong>程序需要通过 <strong>JVM</strong> 栈上的引用访问堆中的具体对象。对象的访问方式取决 于 JVM 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。 </p>
<p>指针： 指向对象，代表一个对象在内存中的起始地址。 </p>
<p>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是 指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的 真实内存地址。 </p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中 包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所 示：</p>
<p> <img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/句柄访问.png" alt="句柄访问"></p>
<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是 非常普遍的行为）时只会改变<strong>句柄</strong>中的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。 </p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么Java堆对象内 部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/直接指针.png" alt="直接指针"></p>
<p>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非 常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用 的就是这种方式。 </p>
<h2 id="内存溢出异常-Java会存在内存泄漏吗？请简单描述"><a href="#内存溢出异常-Java会存在内存泄漏吗？请简单描述" class="headerlink" title="内存溢出异常 Java会存在内存泄漏吗？请简单描述"></a>内存溢出异常 Java会存在内存泄漏吗？请简单描述</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收 掉，自动从内存中清除。 </p>
<p>但是， 即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因 很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景。</p>
<h1 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常**"></a><strong>内</strong>存溢出异常**</h1><p><strong>Java</strong>会存在内存泄漏吗？请简单描述**</p>
<p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收 掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因 很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景。</p>
<p><strong>垃</strong>圾收集器**</p>
<p><strong>简述Java垃圾回收机制</strong></p>
<p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行 执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会 执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没 有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<p><strong>GC</strong>是什么？为什么要GC**</p>
<p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问 题的地方，忘记或者错误的内存</p>
<p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测 对象是否超过作用域从而达到自动</p>
<p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<p><strong>垃圾回收的优点和原理。并考虑2种回收机制</strong></p>
<p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时 不再考虑内存管理的问题。</p>
<p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的 对象才有“作用域”。</p>
<p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存 堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p>
<p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p>
<p><strong>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收 内存吗？有什么办法主动通知虚拟机进行垃圾回收？</strong> 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及 使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式 确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可 达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不 保证GC一定会执行。</p>
<p><strong>Java</strong> <strong>中都有哪些引用类型？</strong></p>
<ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用</li>
</ul>
<p>PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
<p><strong>怎么判断对象是否可以被回收？</strong></p>
<p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收 的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需 要被回收。</p>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用 被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用 的问题；</li>
<li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。 当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<p><strong>在Java中，对象什么时候可以被垃圾回收</strong></p>
<p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被 回收了。</p>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全 垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代 也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原 因。</p>
<p><strong>JVM</strong>中的永久代中会发生垃圾回收吗**</p>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全 垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代 也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原 因。请参考下Java8：从永久代到元数据区</p>
<p>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存 区)</p>
<p><strong>说一下 JVM 有哪些垃圾回收算法？</strong></p>
<ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清 除垃圾碎片。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的 对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不 高，只有原来的一半。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清 除掉端边界以外的内存。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年 代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<p><strong>标记</strong>-<strong>清</strong>除算法**</p>
<p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收 集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法 的基础上进行改进的。</p>
<p><strong>优</strong>点**：实现简单，不需要对象进行移动。</p>
<p><strong>缺</strong>点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的 频率。</p>
<p>标记-清除算法的执行的过程如下图所示</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/标记-清除算法.png" alt="标记-清除算法"></p>
<p><strong>复制算</strong>法**</p>
<p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划 为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区 域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象 进行回收。</p>
<p><strong>优</strong>点<strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 <strong>缺</strong>点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。 复制算法的执行过程如下图所示</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/复制算法.png" alt="复制算法"></p>
<p><strong>标记</strong>-<strong>整</strong>理算法**</p>
<p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年 代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除 算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎 片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理 算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使 他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未 用的内存都各自一边。</p>
<p><strong>优</strong>点**：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺</strong>点**：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>标记-整理算法的执行过程如下图所示</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/标记-整理算法.png" alt="标记-整理算法"></p>
<p><strong>分代收</strong>集<strong>算法</strong></p>
<p>当前商业虚拟机都采用<strong>分</strong>代<strong>收</strong>集<strong>的垃圾收集算法。分代收集算法，顾名思义是根 据对象的</strong>存活周期<strong>将内存划分为几块。一般包括</strong>年轻代<strong>、</strong>老年代** 和 <strong>永久代</strong>，如 图所示：</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/分代收集算法.png" alt="分代收集算法"></p>
<p><strong>说一下 JVM 有哪些垃圾回收器？</strong></p>
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体 实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器 包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器 之间的连线表示它们可以搭配使用。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/垃圾回收器.png" alt="垃圾回收器"></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点 是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效 利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高 效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不 高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年 代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集 器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最 短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是 JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会 产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代 或老年代。</li>
</ul>
<p><strong>详细介绍一下 CMS 垃圾回收器？</strong></p>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得 最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾 回收器非常适合。在启动 JVM 的参数加上“- XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎 片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会 被降低。</p>
<p><strong>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么 区别？</strong></p>
<ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内 存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<p><strong>简述分代垃圾回收器是怎么工作的？</strong></p>
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年 龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的 执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<p><strong>内</strong>存分配策略**</p>
<p><strong>简述java内存分配与回收策率以及Minor GC和Major GC</strong></p>
<p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我 们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场 景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区， 如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直 接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种 垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵 循以下几种「普世」规则：</p>
<p><strong>对象优</strong>先<strong>在 Eden 区分配</strong></p>
<p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行 分配时，虚拟机将会发起一次 Minor GC。如果本次 GC后还是没有足够的空 间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中 发现 Major GC&#x2F;Full GC。</p>
<ul>
<li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所 有 Minor GC 非常频繁，一般回收速度也非常快；</li>
<li><strong>Major GC&#x2F;Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴 随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li>
</ul>
<p><strong>大对象</strong>直<strong>接进入老年代</strong></p>
<p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导 致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对 象。</p>
<p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象 直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p>
<p><strong>长期存</strong>活<strong>对象将进入老年代</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对 象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升 到老年代。</p>
<p><strong>虚</strong>拟机类加载机制**</p>
<p><strong>简述java类加载机制?</strong></p>
<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初 始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p><strong>描述一下JVM加载Class文件的原理机制</strong></p>
<p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也 是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时 候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊 的用法，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用 类装载器加载对应的类到jvm中，</p>
<p>2.显式装载， 通过class.forname() 等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证 程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候 才加载。这当然就是为了节省内存开销。</p>
<p><strong>什么是类加载器，类加载器有哪些?</strong></p>
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器:</p>
<ol>
<li><p>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被 java程序直接引用。</p>
</li>
<li><p>扩展类加载器(extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找 并加载 Java 类。</p>
</li>
<li><p>系统类加载器（system class loader ）：它根据 Java 应用的类路径 （CLASSPATH ）来加载 Java 类。一般来说，Java 应用的类都是由它来 完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取 它。</p>
</li>
<li><p>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实</p>
</li>
</ol>
<p>现。</p>
<p><strong>说一下类装载的执行过程？</strong></p>
<p>类装载分为以下 5个步骤：</p>
<p>加载：根据查找路径找到相应的 class 文件然后导入；</p>
<p>验证：检查加载的 class 文件的正确性；</p>
<p>准备：给类中的静态变量分配内存空间；</p>
<p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为 一个标示，而在直接引用直接指向内存中的地址；</p>
<p>初始化：对静态变量和静态代码块执行初始化工作。</p>
<p><strong>什么是双亲委派模型？</strong></p>
<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的 类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一 个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p><img src="F:\0马士兵\新建文件夹\BAT面试突击资料(1)\OUT\03-2020最新整理一线大厂面试题合集(重点看)\08-Java虚拟机(JVM)面试题（2020最新版）-重点.assets/双亲委派.png" alt="双亲委派"></p>
<p>类加载器分类：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚 拟机识别的类库；</p>
</li>
<li><p>其他类加载器：</p>
<ul>
<li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径 （classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我 们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载 这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如 此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无 法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加 载类。</p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父 类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加 载。</p>
<p><strong>JVM</strong>调<strong>优</strong></p>
<p><strong>说一下 JVM 调优的工具？</strong></p>
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序 死锁、监控内存的变化、gc 变化等。</li>
</ul>
<p><strong>常用的 JVM 调优的参数都有哪些？</strong></p>
<ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4； -XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2； –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合； -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组</li>
<li>合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组 合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:25" itemprop="dateModified" datetime="2021-03-03T13:51:25+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="1-MyBatis是什么？"><a href="#1-MyBatis是什么？" class="headerlink" title="1. MyBatis是什么？"></a>1. MyBatis是什么？</h2><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化  SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及 获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java  的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h2 id="2-ORM是什么"><a href="#2-ORM是什么" class="headerlink" title="2. ORM是什么"></a>2. ORM是什么</h2><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数 据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和 数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h2 id="3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时， 可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半 自动ORM映射工具。</p>
<h2 id="4-传统JDBC开发存在的问题"><a href="#4-传统JDBC开发存在的问题" class="headerlink" title="4. 传统JDBC开发存在的问题"></a>4. 传统JDBC开发存在的问题</h2><p>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池 解决这个问题。但是使用jdbc需要自己实现连接池。 </p>
<p>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大， 一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。 </p>
<p>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一 定，可能多也可能少，修改sql还要修改代码，系统不易维护。 </p>
<p>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</p>
<h2 id="5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><ol>
<li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接 池可解决此问题。<br>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</li>
<li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变 java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li>
<li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需 要和参数一一对应。<br>解决： Mybatis自动将java对象映射至sql语句。</li>
<li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记 录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象。</li>
</ol>
<h2 id="6-Mybatis优缺点"><a href="#6-Mybatis优缺点" class="headerlink" title="6. Mybatis优缺点"></a>6. Mybatis优缺点</h2><p>**优点 **</p>
<p>与传统的数据库访问技术相比，ORM有以下优点： </p>
<p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL语句，并可重用 </p>
<p>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接 </p>
<p>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数 据库MyBatis都支持） </p>
<p>**不同点 **</p>
<p>能够与Spring很好的集成</p>
<p><strong>缺点</strong></p>
<p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底 有一定要求 </p>
<p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 </p>
<h2 id="7-MyBatis框架适用场景"><a href="#7-MyBatis框架适用场景" class="headerlink" title="7. MyBatis框架适用场景"></a>7. MyBatis框架适用场景</h2><p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。 </p>
<p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。 </p>
<h2 id="8-Hibernate-和-MyBatis-的区别"><a href="#8-Hibernate-和-MyBatis-的区别" class="headerlink" title="8. Hibernate 和 MyBatis 的区别"></a>8. Hibernate 和 MyBatis 的区别</h2><p>**相同点 **</p>
<ul>
<li>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</li>
</ul>
<p>**不同点 **</p>
<p>**映射关系 **</p>
<p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单 </p>
<p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂 </p>
<p><strong>SQL优化和移植性</strong></p>
<p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性， 此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但 会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 </p>
<p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。 开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优 化容易。 </p>
<p><strong>开发难易程度和学习成本</strong></p>
<p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如： 办公自动化系统</p>
<p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互 联网电子商务系统</p>
<p><strong>总结</strong></p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h1 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h1><h2 id="9-MyBatis编程步骤是什么样的？"><a href="#9-MyBatis编程步骤是什么样的？" class="headerlink" title="9. MyBatis编程步骤是什么样的？"></a>9. MyBatis编程步骤是什么样的？</h2><ol>
<li>创建SqlSessionFactory</li>
<li>通过SqlSessionFactory创建SqlSession</li>
<li>通过sqlsession执行数据库操作</li>
<li>调用session.commit()提交事务</li>
<li>调用session.close()关闭会话</li>
</ol>
<h2 id="10-请说说MyBatis的工作原理"><a href="#10-请说说MyBatis的工作原理" class="headerlink" title="10. 请说说MyBatis的工作原理"></a>10. 请说说MyBatis的工作原理</h2><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis  的工作原理如下图</p>
<p><img src="/07-MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/MyBatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="MyBatis工作原理"></p>
<p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了  MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句， 需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加 载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所 有方法。</p>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据  SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement  类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信 息。</p>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和  POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过 程。</p>
<p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型 和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<p><strong>MyBatis的功能架构是怎样的</strong></p>
<p>我们把Mybatis的功能架构分为三层：</p>
<p>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层 一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p>
<p>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的 目的是根据调用的请求完成一次数据库操作。</p>
<p>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这 些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的 支撑。</p>
<p>MyBatis的框架架构设计是怎么样的</p>
<p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成 Configuration这个类，就是图中的红框。</p>
<p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的 配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL 语句、结果映射配置），存储在内存中。</p>
<p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是 Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的 MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以 得到最终要执行的SQL语句和参数。</p>
<p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p>
<p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、 JavaBean或者基本数据类型，并将最终结果返回。</p>
<p><strong>为什么需要预编译</strong></p>
<p>定义：</p>
<p>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编 译，这样 DBMS 执行 SQL 时，就不需要重新编译。 </p>
<p><strong>为什么需要预编译</strong></p>
<p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以 优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编 译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时 预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓 存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis 默认情况下，将对所有的 SQL 进行预编译。</p>
<p><strong>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></p>
<p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、 BatchExecutor。</p>
<p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使 用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添 加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行 executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 <strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p>
<p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也 可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参 数，如SqlSession openSession(ExecutorType execType) 。</p>
<p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句 （prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p>
<p><strong>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p>
<p>Mybatis仅支持association关联对象和collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在Mybatis配置文件中，可以配置是否 启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法， 比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独 发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 <strong>映射器</strong></p>
<p>#{}和${}的区别</p>
<p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</p>
<p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用 PreparedStatement的set方法来赋值。</p>
<p>Mybatis在处理时，是原值传入，就是把 {}时，是原值传入，就是把时，是原值传入，就是 把{}替换成变量的值，相当于JDBC中的Statement编译</p>
<p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上 单引号 ‘’</p>
<p>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p>
<p>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</p>
<p>模糊查询like语句该怎么写</p>
<p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p>
<p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引 号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p>
<p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p>
<p>（4）使用bind标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;listUserLikeUsername&quot; resultType=&quot;com.jourwon.pojo.User&quot;&gt;</span><br><span class="line">2 &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt;</span><br><span class="line">3 select id,sex,age,username,password from person where username LIKE #</span><br><span class="line">&#123;pattern&#125;</span><br><span class="line">4 &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>在mapper中如何传递多个参数 </p>
<p>方法1：顺序传参法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(String name, int deptId);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的数字代表传入参数的顺序。</p>
<p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。 </p>
<p>方法2：@Param注解传参法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptI</span><br><span class="line">d&quot;) deptId);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p>
<p>这种方法在参数不多的情况还是比较直观的，推荐使用。 </p>
<p>方法3：Map传参法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(Map&lt;String, Object&gt; params);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;UserResu</span><br><span class="line">ltMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是Map里面的key名称。</p>
<p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。 </p>
<p>方法4：Java Bean传参法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public User selectUser(User user);</span><br><span class="line">2</span><br><span class="line">3 &lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot;</span><br><span class="line">resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">4 select * from user</span><br><span class="line">5 where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">6 &lt;/select&gt;</span><br><span class="line">7 &lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot;</span><br><span class="line">resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是User类里面的成员属性。</p>
<p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑 处理方便，推荐使用。</p>
<p><strong>Mybatis如何执行批量操作</strong></p>
<p>使用foreach标签</p>
<p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的 属性主要有item，index，collection，open，separator，close。</p>
<p>item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；</p>
<p>index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用； open　　表示该语句以什么开始，常用“(”；</p>
<p>separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</p>
<p>close　　表示以什么结束，常用“)”。</p>
<p>在使用foreach的时候最关键的也是最容易出错的就是collection 属性，该属性是必须指定 的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： </p>
<p>如果传入的是单参数且参数类型是一个List的时候，collection 属性值为list</p>
<p>如果传入的是单参数且参数类型是一个array数组的时候，collection 的属性值为array 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以 封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个 Map的，</p>
<p>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己 封装的map里面的key</p>
<p>具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 批量保存(foreach插入多条数据两种方法)</span><br><span class="line">2 int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); ‐‐&gt;</span><br><span class="line">3 &lt;!‐‐ MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 ‐‐&gt; //推荐</span><br><span class="line">使用</span><br><span class="line">4 &lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">5 INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">6 VALUES</span><br><span class="line">7 &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">8 (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">9 &lt;/foreach&gt;</span><br><span class="line">10 &lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="line">2 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true ‐‐</span><br><span class="line">&gt;</span><br><span class="line">3 &lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">4 &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;</span><br><span class="line">5 INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">6 VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">7 &lt;/foreach&gt;</span><br><span class="line">8 &lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用ExecutorType.BATCH</strong></p>
<p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一 个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行 所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作 时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求 的</p>
<p>具体用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1 //批量保存方法测试</span><br><span class="line">2 @Test</span><br><span class="line">3 public void testBatch() throws IOException&#123;</span><br><span class="line">4 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">5 //可以执行批量操作的sqlSession</span><br><span class="line">6 SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATC</span><br><span class="line">H);</span><br><span class="line">7</span><br><span class="line">8 //批量保存执行前时间</span><br><span class="line">9 long start = System.currentTimeMillis();</span><br><span class="line">10 try &#123;</span><br><span class="line">11 EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">12 for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">13 mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0,</span><br><span class="line">5), &quot;b&quot;, &quot;1&quot;));</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 openSession.commit();</span><br><span class="line">17 long end = System.currentTimeMillis();</span><br><span class="line">18 //批量保存执行后的时间</span><br><span class="line">19 System.out.println(&quot;执行时长&quot; + (end ‐ start));</span><br><span class="line">20 //批量 预编译sql一次==》设置参数==》10000次==》执行1次 677</span><br><span class="line">21 //非批量 （预编译=设置参数=执行 ）==》10000次 1121</span><br><span class="line">22</span><br><span class="line">23 &#125; finally &#123;</span><br><span class="line">24 openSession.close();</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br></pre></td></tr></table></figure>

<p>mapper和mapper.xml如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 public interface EmployeeMapper &#123;</span><br><span class="line">2 //批量保存员工</span><br><span class="line">3 Long addEmp(Employee employee);</span><br><span class="line">4 &#125;</span><br><span class="line">1 &lt;mapper namespace=&quot;com.jourwon.mapper.EmployeeMapper&quot;</span><br><span class="line">2 &lt;!‐‐批量保存员工 ‐‐&gt;</span><br><span class="line">3 &lt;insert id=&quot;addEmp&quot;&gt;</span><br><span class="line">4 insert into employee(lastName,email,gender)</span><br><span class="line">5 values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">6 &lt;/insert&gt;</span><br><span class="line">7 &lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如何获取生成的主键</strong></p>
<p>对于支持主键自增的数据库（MySQL）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot; &gt;</span><br><span class="line">2 insert into user(</span><br><span class="line">3 user_name, user_password, create_time)</span><br><span class="line">4 values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=</span><br><span class="line">TIMESTAMP&#125;)</span><br><span class="line">5 &lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那 么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体 或者Map 来获取主键值。通过 getUserId获取主键</p>
<p>不支持主键自增的数据库（Oracle）</p>
<p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主 键。</p>
<p>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的 数据库，也适用于提供主键自增功能的数据库</p>
<p>＜selectKey＞一般的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;BEFOR</span><br><span class="line">E&quot;&gt;</span><br><span class="line">2 &lt;/selectKey&gt;</span><br></pre></td></tr></table></figure>

<p>属性 描述</p>
<p>keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列， 也可以是逗号分隔的属性名称列表。</p>
<p>keyColmn </p>
<p>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以</p>
<p>是逗号分隔的属性名称列表。</p>
<p>resultType </p>
<p>结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用</p>
<p>作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性 的 Object 或一个 Map。</p>
<p>order </p>
<p>值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 </p>
<p>keyProperty 然后执行插入语句。如果为AFTER则相反。</p>
<p>statementType </p>
<p>使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED </p>
<p>和 CALLABLE 语句的映射类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;insert id=&quot;insertUser&quot; &gt;</span><br><span class="line">2 &lt;selectKey keyColumn=&quot;id&quot; resultType=&quot;long&quot; keyProperty=&quot;userId&quot;</span><br><span class="line">order=&quot;BEFORE&quot;&gt;</span><br><span class="line">3 SELECT USER_ID.nextval as id from dual</span><br><span class="line">4 &lt;/selectKey&gt;</span><br><span class="line">5 insert into user(</span><br><span class="line">6 user_id,user_name, user_password, create_time)</span><br><span class="line">7 values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=</span><br><span class="line">TIMESTAMP&#125;)</span><br><span class="line">8 &lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就 可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时 keyProperty&#x3D;“任意自定义变量名”，resultType 可以不写。</p>
<p>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后 将值作为主键插入到数据库中。</p>
<p>扩展</p>
<p>如果Mysql 使用selectKey的方式获取主键，需要注意下面两点：</p>
<p>order ： AFTER</p>
<p>获取递增主键值 ：SELECT LAST_INSERT_ID()</p>
<p>当实体类中的属性名和表中的字段名不一样 ，怎么办</p>
<p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一 致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultType=&quot;com.jourwon.pojo.Or</span><br><span class="line">der&quot;&gt;</span><br><span class="line">2 select order_id id, order_no orderno ,order_price price form orders wher</span><br><span class="line">e order_id=#&#123;id&#125;;</span><br><span class="line">3 &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>第2种： 通过来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderResultMap&quot;&gt;</span><br><span class="line">2 select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">3 &lt;/select&gt;</span><br><span class="line">4</span><br><span class="line">5 &lt;resultMap type=&quot;com.jourwon.pojo.Order&quot; id=&quot;orderResultMap&quot;&gt;</span><br><span class="line">6 &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">7 &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&gt;</span><br><span class="line">8</span><br><span class="line">9 &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的</span><br><span class="line">属性–&gt;</span><br><span class="line">10 &lt;result property =&quot;orderno&quot; column =&quot;order_no&quot;/&gt;</span><br><span class="line">11 &lt;result property=&quot;price&quot; column=&quot;order_price&quot; /&gt;</span><br><span class="line">12 &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Mapper</strong> <strong>编写有哪几种方式？</strong></p>
<p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接 口，mapper 接口实现类、mapper.xml 文件。</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;mappers&gt;</span><br><span class="line">2 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">3 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">4 &lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口</p>
<p>（3）实现类集成 SqlSessionDaoSupport</p>
<p>mapper 方法中可以 this.getSqlSession() 进行数据增删改查。 </p>
<p>（4）spring 配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean id=&quot; &quot; class=&quot;mapper 接口的实现&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;sqlSessionFactory&quot;</span><br><span class="line">3 ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">4 &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;mappers&gt;</span><br><span class="line">2 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">3 &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">4 &lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口：</p>
<p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p>
<p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致 </p>
<p>（5）Spring 中定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;mapperInterface&quot; value=&quot;mapper 接口地址&quot; /&gt;</span><br><span class="line">3 &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">4 &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第三种：使用 mapper 扫描器：</p>
<p>（1）mapper.xml 文件编写：</p>
<p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p>
<p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； </p>
<p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行 配置。</p>
<p>（2）定义 mapper 接口：</p>
<p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录 （3）配置 mapper 扫描器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">2 &lt;property name=&quot;basePackage&quot; value=&quot;mapper 接口包地址</span><br><span class="line">3 &quot;&gt;&lt;/property&gt;</span><br><span class="line">4 &lt;property name=&quot;sqlSessionFactoryBeanName&quot;</span><br><span class="line">5 value=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">6 &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p>
<p><strong>什么是MyBatis的接口绑定？有哪些实现方式？</strong></p>
<p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们 直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的 选择和设置。</p>
<p>接口绑定有两种实现方式</p>
<p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语 句来绑定；</p>
<p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为 接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用 xml绑定，一般用xml绑定的比较多。</p>
<p><strong>使用MyBatis的mapper接口调用时有哪些要求</strong>？</p>
<p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p>
<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的 类型相同。</p>
<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型 相同。</p>
<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<p><strong>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口 的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</strong></p>
<p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace 的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就 是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法 名拼接字符串作为key值，可唯一定位一个MappedStatement，举例： com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为 com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。 在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为 一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成 代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将sql执行结果返回。</p>
<p><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></p>
<p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置</p>
<p>namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没 有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id 就可以重复，namespace不同，namespace+id自然也就不同。</p>
<p><strong>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong></p>
<p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在 Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素 会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其 每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、 <delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql 对象。</p>
<p><strong>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p>
<p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</p>
<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME， 对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智 能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常 工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性 逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<p><strong>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</strong> 还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、 <selectKey>，加上动态sql的9个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中<sql>为sql片段标签， 通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p>
<p><strong>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义 在A标签的后面，还是说必须定义在A标签的前面？</strong></p>
<p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在 任何地方，Mybatis都可以正确识别。</p>
<p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存 在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标 签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<p><strong>高级查询</strong></p>
<p><strong>MyBatis实现一对一，一对多有几种方式，怎么操作的？</strong></p>
<p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面 的association，collection节点配置一对一，一对多的类就可以完成</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据， 也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p>
<p><strong>Mybatis是否可以映射Enum枚举类？</strong></p>
<p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列 上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和 getResult()接口方法。</p>
<p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至 javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占 位符参数和获取列查询结果。</p>
<p><strong>动态SQL</strong></p>
<p><strong>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</strong> Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断 和动态拼接sql的功能，Mybatis提供了9种动态sql标签 trim|where|set|foreach|if|choose|when|otherwise|bind 。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态sql的功能。</p>
<p><strong>插件模块</strong></p>
<p><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非 物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分 页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法 内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页 参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>
<p><strong>简述Mybatis的插件运行原理，以及如何编写一个插件。</strong></p>
<p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、 Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对 象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体 就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要 拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 </p>
<p><strong>缓存</strong></p>
<p><strong>Mybatis的一级、二级缓存</strong></p>
<p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session， 当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓 存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默 认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接 口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的 进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:25" itemprop="dateModified" datetime="2021-03-03T13:51:25+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring概述-10"><a href="#Spring概述-10" class="headerlink" title="Spring概述(10)"></a>Spring概述(10)</h1><h2 id="1-什么是spring"><a href="#1-什么是spring" class="headerlink" title="1. 什么是spring?"></a>1. 什么是spring?</h2><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早由<strong>Rod Johnson</strong>创建，目的是为了解 决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提 供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应 用程序的开发。 Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发。</strong></p>
<p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能 的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency  injection，DI）和面向切面编程（aspect-oriented programming， AOP）</strong>。</p>
<p> 为了降低Java开发的复杂性，Spring采取了以下4种关键策略 </p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程； </li>
<li>通过依赖注入和面向接口实现松耦合； </li>
<li>基于切面和惯例进行声明式编程； </li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<h2 id="2-Spring框架的设计目标，设计理念，和核心是什么"><a href="#2-Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="2. Spring框架的设计目标，设计理念，和核心是什么"></a>2. Spring框架的设计目标，设计理念，和核心是什么</h2><p><strong>Spring设计目标：</strong>Spring为开发者提供一个一站式轻量级应用开发平台； </p>
<p><strong>Spring设计理念：</strong>在JavaEE开发中，支持POJO和JavaBean开发方式，使应用 面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现 对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器， 实现解耦； </p>
<p><strong>Spring框架的核心：</strong>IoC容器和AOP模块。通过IoC容器管理POJO对象以及他 们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。 IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的 功能分离出来形成可重用的功能组件。 </p>
<h2 id="3-Spring的优缺点是什么？"><a href="#3-Spring的优缺点是什么？" class="headerlink" title="3. Spring的优缺点是什么？"></a>3. Spring的优缺点是什么？</h2><p>**优点 **</p>
<ul>
<li>方便解耦，简化开发<br>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring管理。 </li>
<li>AOP编程的支持<br>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等 功能。 </li>
<li>声明式事务的支持<br>只需要通过配置就可以完成对事务的管理，而无需手动编程。 </li>
<li>方便程序的测试<br>Spring对Junit4支持，可以通过注解方便的测试Spring程序。 </li>
<li>方便集成各种优秀框架<br>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持 （如：Struts、Hibernate、MyBatis等）。 </li>
<li>降低JavaEE API的使用难度<br>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用 等），都提供了封装，使这些API应用难度大大降低。</li>
</ul>
<p>**缺点 **</p>
<ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全 </li>
<li>Spring依赖反射，反射影响性能 </li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h2 id="4-Spring有哪些应用场景"><a href="#4-Spring有哪些应用场景" class="headerlink" title="4. Spring有哪些应用场景"></a>4. Spring有哪些应用场景</h2><p><strong>应用场景：</strong>JavaEE企业应用开发，包括SSH、SSM等 </p>
<p><strong>Spring价值：</strong></p>
<ul>
<li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化； </li>
<li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离 开来； </li>
<li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性 和可测试性；</li>
</ul>
<h2 id="5-Spring由哪些模块组成？"><a href="#5-Spring由哪些模块组成？" class="headerlink" title="5. Spring由哪些模块组成？"></a>5. Spring由哪些模块组成？</h2><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被 分别整合在<strong>核心容器（Core Container） 、 AOP（Aspect Oriented Programming） 和设备支持（Instrmentation） 、数据访问与集成（Data Access&#x2F;Integeration） 、  Web、 消息（Messaging） 、 Test</strong>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201020183306246.png" alt="image-20201020183306246"></p>
<ul>
<li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of  Control，IOC）和依赖注入（Dependency Injection，DI）功能。 </li>
<li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管 理对象称为Bean。 </li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框 架式的对象访问方法。 </li>
<li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂 商特有的错误代码解析， 用于简化JDBC。 </li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。 </li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet  listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。 </li>
<li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进 行单元测试和集成测试。</li>
</ul>
<h2 id="6-Spring-框架中都用到了哪些设计模式？"><a href="#6-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="6. Spring 框架中都用到了哪些设计模式？"></a>6. Spring 框架中都用到了哪些设计模式？</h2><ol>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实 例； </li>
<li>单例模式：Bean默认为单例模式。</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生 成技术； </li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate,  JmsTemplate, JpaTemplate。 </li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中 listener的实现–ApplicationListener。</li>
</ol>
<h2 id="7-详细讲解一下核心容器（spring-context应用上下文-模-块"><a href="#7-详细讲解一下核心容器（spring-context应用上下文-模-块" class="headerlink" title="7. 详细讲解一下核心容器（spring context应用上下文) 模 块"></a>7. 详细讲解一下核心容器（spring context应用上下文) 模 块</h2><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以 spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为 一个容器。 </p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和 依赖从真正的应用代码中分离。最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件 中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。 </p>
<h2 id="8-Spring框架中有哪些不同类型的事件"><a href="#8-Spring框架中有哪些不同类型的事件" class="headerlink" title="8. Spring框架中有哪些不同类型的事件"></a>8. Spring框架中有哪些不同类型的事件</h2><p>Spring 提供了以下5种标准的事件： </p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：在调用 ConfigurableApplicationContext 接口中的refresh()方法时被触发。 </li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触 发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 </li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被 关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个 http请求（request）结束触发该事件。如果一个bean实现了 ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean 会自动被通知。</li>
</ol>
<h2 id="9-Spring-应用程序有哪些不同组件？"><a href="#9-Spring-应用程序有哪些不同组件？" class="headerlink" title="9. Spring 应用程序有哪些不同组件？"></a>9. Spring 应用程序有哪些不同组件？</h2><p>Spring 应用一般有以下组件： </p>
<ul>
<li>接口 - 定义功能。 </li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。 </li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。 </li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。 </li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h2 id="10-使用-Spring-有哪些方式？"><a href="#10-使用-Spring-有哪些方式？" class="headerlink" title="10. 使用 Spring 有哪些方式？"></a>10. 使用 Spring 有哪些方式？</h2><p>使用 Spring 有以下方式： </p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。 </li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。 </li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java  Objects）。 </li>
<li>用于远程使用。</li>
</ul>
<h1 id="Spring控制反转-IOC-（13）"><a href="#Spring控制反转-IOC-（13）" class="headerlink" title="Spring控制反转(IOC)（13）"></a>Spring控制反转(IOC)（13）</h1><h2 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h2><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对</p>
<p>象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反</p>
<p>转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h2 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h2><ul>
<li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li>
<li>解耦，由容器去维护具体的对象 </li>
<li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
<h2 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h2><ul>
<li>IOC 或 依赖注入把应用的代码量降到最低。</li>
<li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li>
<li>最小的代价和最小的侵入性使松散耦合得以实现。</li>
<li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li>
</ul>
<h2 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h2><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 interface Fruit &#123;</span><br><span class="line">2 public abstract void eat();</span><br><span class="line">3 &#125;</span><br><span class="line">4</span><br><span class="line">5 class Apple implements Fruit &#123;</span><br><span class="line">6 public void eat()&#123;</span><br><span class="line">7 System.out.println(&quot;Apple&quot;);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br><span class="line">11 class Orange implements Fruit &#123;</span><br><span class="line">12 public void eat()&#123;</span><br><span class="line">13 System.out.println(&quot;Orange&quot;);</span><br><span class="line">14 &#125;</span><br><span class="line">15 &#125;</span><br><span class="line">16</span><br><span class="line">17 class Factory &#123;</span><br><span class="line">18 public static Fruit getInstance(String ClassName) &#123;</span><br><span class="line">19 Fruit f=null;</span><br><span class="line">20 try &#123;</span><br><span class="line">21 f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">22 &#125; catch (Exception e) &#123;</span><br><span class="line">23 e.printStackTrace();</span><br><span class="line">24 &#125;</span><br><span class="line">25 return f;</span><br><span class="line">26 &#125;</span><br><span class="line">27 &#125;</span><br><span class="line">28</span><br><span class="line">29 class Client &#123;</span><br><span class="line">30 public static void main(String[] a) &#123;</span><br><span class="line">31 Fruit f=Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;);</span><br><span class="line">32 if(f!=null)&#123;</span><br><span class="line">33 f.eat();</span><br><span class="line">34 &#125;</span><br><span class="line">35 &#125;</span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h2><p>Spring 的 IoC 设计支持以下功能：依赖注入依赖检查自动装配支持集合指定初始化方法和销毁方法</p>
<p>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</p>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring </p>
<p>RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<h2 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做 Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取 bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean 之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具</p>
<p>有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化。统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
<p>加载方式</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean 时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所</p>
<p>依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>创建方式</p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>注册方式</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、</p>
<p>BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h2 id="Spring-如何设计容器的，BeanFactory和-ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和-ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和 ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和 ApplicationContext的关系详解</h2><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，</p>
<p>Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 </p>
<p>ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" alt="容器的层级关系"></p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功</p>
<p>能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<ol>
<li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
</li>
<li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出</p>
</li>
</ol>
<p>Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 </p>
<p>BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<h2 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h2><p>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
<p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans 的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找 bean配置。</p>
<p>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<h2 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h2><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
<h2 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h2><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接</p>
<p>口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<ul>
<li>查找定位操作与应用代码完全无关。</li>
<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>
<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>
</ul>
<h2 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor </p>
<p>Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h2 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h2><table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter注 入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属 性</td>
<td>会覆盖 setter 属 性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h2 id="Spring-Beans（19）什么是Spring-beans？"><a href="#Spring-Beans（19）什么是Spring-beans？" class="headerlink" title="Spring Beans（19）什么是Spring beans？"></a>Spring Beans（19）什么是Spring beans？</h2><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h2 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h2><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括bean，它的生命周期详情及它的依赖。</p>
<h3 id="如何创建一个如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何创建一个如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何创建一个如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何创建一个如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
</ul>
<h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h2 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h2><ol>
<li><p>Set方法注入；</p>
</li>
<li><p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p>
</li>
<li><p>静态工厂注入；</p>
</li>
<li><p>实例工厂；</p>
</li>
</ol>
<h2 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h2><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过 bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean 每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p>
<h2 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h2><p>Spring框架支持以下五种bean的作用域：</p>
<ul>
<li>singleton : bean在每个Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的SpringApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个</li>
</ul>
<p>实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
<p>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h3 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，</p>
<p>把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean() 了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h2 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前</p>
<p>需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。解释Spring框架中bean的生命周期</p>
<p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean 实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
<p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="bean生命周期"></p>
<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对 Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方</p>
<p>法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用 setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-</p>
<p>ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，</p>
<p>该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-</p>
<p>ProcessAfterInitialization()方法；此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方</p>
<p>法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的</p>
<p>DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<h2 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h2><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的</p>
<p>时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h2 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h2><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
<h2 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h2><p>Spring提供以下几种集合的配置元素：类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<h2 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h2><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h2 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h2><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，</p>
<p>Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通</p>
<p>过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean </p>
<p>Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h3 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。</li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType进行装配。</li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
<h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，。</p>
<p>在启动spring IoC时，容器自动装载了一个</p>
<p>AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：  </p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</li>
</ul>
<h2 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h2><p>自动装配的局限性是：重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<h3 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h3><p>可以</p>
<h1 id="Spring注解（8）"><a href="#Spring注解（8）" class="headerlink" title="Spring注解（8）"></a>Spring注解（8）</h1><h2 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h2><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring 配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被</p>
<p>Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	@Configuration</span><br><span class="line">2	public class StudentConfig &#123;</span><br><span class="line">3	@Bean</span><br><span class="line">4	public StudentBean myStudent() &#123;</span><br><span class="line">5	return new StudentBean();</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h2><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 元素。</p>
<h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h2 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h2><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出</p>
<p>BeanInitializationException。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1	public class Employee &#123;</span><br><span class="line">2	private String name;</span><br><span class="line">3	@Required</span><br><span class="line">4	public void setName(String name)&#123;</span><br><span class="line">5	this.name=name;</span><br><span class="line">6	&#125;</span><br><span class="line">7	public string getName()&#123;</span><br><span class="line">8	return name;</span><br><span class="line">9	&#125;</span><br><span class="line">10	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h2><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰 setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	public class Employee &#123;</span><br><span class="line">2	private String name;</span><br><span class="line">3	@Autowired</span><br><span class="line">4	public void setName(String name) &#123;</span><br><span class="line">5	this.name=name;</span><br><span class="line">6	&#125;</span><br><span class="line">7	public string getName()&#123;</span><br><span class="line">8	return name;</span><br><span class="line">9	&#125;</span><br><span class="line">10	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p>
<p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。 </p>
<h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL </li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h1 id="Spring数据访问（14）"><a href="#Spring数据访问（14）" class="headerlink" title="Spring数据访问（14）"></a>Spring数据访问（14）</h1><h2 id="解释对象-x2F-关系映射集成模块"><a href="#解释对象-x2F-关系映射集成模块" class="headerlink" title="解释对象&#x2F;关系映射集成模块"></a>解释对象&#x2F;关系映射集成模块</h2><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h2 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h2><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者</p>
<p>只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
<h3 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h2 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h2><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访</p>
<p>问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。</p>
<p>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h2 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h2><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h2 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h2><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h2 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h2><p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>ernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
<h2 id="如何通扩展-Hib过HibernateDaoSupport将Spring和Hibernate-结合起来？"><a href="#如何通扩展-Hib过HibernateDaoSupport将Spring和Hibernate-结合起来？" class="headerlink" title="如何通扩展 Hib过HibernateDaoSupport将Spring和Hibernate 结合起来？"></a>如何通扩展 Hib过HibernateDaoSupport将Spring和Hibernate 结合起来？</h2><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<h2 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h2><p>Spring支持两种类型的事务管理：编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h2 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，</p>
<p>spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog或者redo log实现的。</p>
<h2 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h2><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>
<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>
<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
<h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>\1.    ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>\2.    ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）； 3. ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
<p>\4.    ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
<p>\5.    ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h2><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API 支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h2 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h2><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h1 id="Spring面向切面编程-AOP-（13）什么是AOP"><a href="#Spring面向切面编程-AOP-（13）什么是AOP" class="headerlink" title="Spring面向切面编程(AOP)（13）什么是AOP"></a>Spring面向切面编程(AOP)（13）什么是AOP</h1><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<h2 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h2><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）  AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）  Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP</p>
<p>对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h2 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h2><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ 的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而</p>
<p>Spring AOP则无需特定的编译器处理。</p>
<h3 id="InvocationHandler-的-invoke-Object-proxy-Method-method-Object-args-："><a href="#InvocationHandler-的-invoke-Object-proxy-Method-method-Object-args-：" class="headerlink" title="InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)："></a>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：</h3><p>proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
<h2 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h2><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object &#x3D; Proxy</p>
<h2 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h2><p>（1）  切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）  连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）  通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）  切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）  引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）  目标对象（Target Object）： 被一个或者多个切面（aspect）所通知</p>
<p>（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知</p>
<p>（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）  织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>
</ul>
<h2 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean</p>
<p>中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是</p>
<p>ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有 bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<p>Spring只支持方法级别的连接点</p>
<p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段可以利用Aspect来补充。</p>
<h2 id="连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h2><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h2 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过</p>
<p>SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<p>\1. 前置通知（Before）：在目标方法被调用之前调用通知功能；</p>
<p>\2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p>
<p>\3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p>
<p>\4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p>
<p>\5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p>同一个aspect，不同advice的执行顺序：</p>
<p>①没有异常情况下的执行顺序：</p>
<p>around before advice before advice target method 执行 around after advice after advice</p>
<p>afterReturning</p>
<p>②有异常情况下的执行顺序： around before advice before advice target method 执行 around after advice after advice</p>
<p>afterThrowing:异常发生 java.lang.RuntimeException: 异常发生</p>
<h2 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h2><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ul>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ul>
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<p><img src="/06-Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/Aspect%E6%B3%A8%E8%A7%A3.png" alt="Aspect注解"></p>
<h2 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h2><p>在这种情况下，切面由常规类以及基于XML的配置实现。解释基于注解的切面实现</p>
<p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h2 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h2><p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/05-Spring%20MVC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/05-Spring%20MVC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:24" itemprop="dateModified" datetime="2021-03-03T13:51:24+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级 Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的 web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间 的配合。 </p>
<h2 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h2><p>（1）可以支持各种视图技术,而不仅仅局限于JSP； </p>
<p>（2）与Spring框架集成（如IoC容器、AOP等）； </p>
<p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射 （handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器 （ViewResolver）。 </p>
<p>（4） 支持各种请求资源的映射策略。 </p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）<br>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了 其它组件之间的耦合度。 </p>
<p>（2）处理器映射器HandlerMapping（不需要程序员开发）<br>作用：根据请求的URL来查找Handler </p>
<p>（3）处理器适配器HandlerAdapter<br>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。 </p>
<p>（4）处理器Handler（需要程序员开发） </p>
<p>（5）视图解析器 ViewResolver（不需要程序员开发）<br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view） </p>
<p>（6）视图View（需要程序员开发jsp）<br>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等 等） </p>
<h2 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h2><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的 HTTP请求和响应。</p>
<h2 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h2><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解 析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽 象的方式实现了一个控制层，允许用户创建多种用途的控制器。 </p>
<h2 id="Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性 能的,解决方案是在控制器里面不能写字段。 </p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下  DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下  DispatcherServlet 的工作流程？</h2><p>（1）用户发送请求至前端控制器DispatcherServlet； </p>
<p>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器， 请求获取Handle； </p>
<p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦 截器(如果有则生成)一并返回给DispatcherServlet； </p>
<p>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；</p>
<p>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制 器)； </p>
<p>（6）Handler执行完成返回ModelAndView； </p>
<p>（7）HandlerAdapter将Handler执行结果ModelAndView返回给 DispatcherServlet； </p>
<p>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行 解析；</p>
<p>（9）ViewResolver解析后返回具体View； </p>
<p>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） </p>
<p>（11）DispatcherServlet响应用户。<br>![SpringMVC工作流程](05-Spring MVC面试题（2020最新版）.assets&#x2F;SpringMVC工作流程.png)</p>
<h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h2 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h2><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验 的总结）。模型（model）-视图（view）-控制器（controller），三层架构的 设计模式。用于实现前端页面的展现与后端业务数据处理的分离。 </p>
<p>mvc设计模式的好处 </p>
<p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展 性，可维护性。 </p>
<p>2.有利于系统的并行开发，提升开发效率。 </p>
<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="注解原理是什么"><a href="#注解原理是什么" class="headerlink" title="注解原理是什么"></a>注解原理是什么</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生 成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代 理对象。通过代理对象调用自定义注解的方法，会终调用 AnnotationInvocationHandler的invoke方法。该方法会从memberValues这 个Map中索引出对应的值。而memberValues的来源是Java常量池。 </p>
<h2 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h2><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用 于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 </p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对 象。 </p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给 客户。</p>
<h2 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h2><p>答：一般用@Controller注解,也可以使用@RestController,@RestController 注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p>
<h2 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h2><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简</p>
<p>便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使</p>
<p>用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和 @RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于</p>
<p>HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC </p>
<p>Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方</p>
<p>法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<ul>
<li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li>
<li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li>
</ul>
<h2 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p>
<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p>
<p>value， method</p>
<p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes，produces</p>
<p>consumes： 指定处理请求的提交内容类型（Content-Type），例如 application&#x2F;json, text&#x2F;html;</p>
<p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params，headers</p>
<p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h2 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的</p>
<p>HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h2 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h2><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 </p>
<p>@RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; </p>
<p>RequestMethod.GET)</p>
<p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h2><p>相同点都是基于mvc的表现层框架，都用于web项目的开发。</p>
<p>不同点</p>
<p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：</p>
<p>DispatcherServlet。struts2的前端控制器是filter：</p>
<p>StrutsPreparedAndExcutorFilter。</p>
<p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p>
<p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC 通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，   后又将ModelAndView中的模型数据通过 reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p>
<h2 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h2><p>（1）  转发：在返回值前面加”forward:”，譬如”forward:user.do?name&#x3D;method4”</p>
<p>（2）  重定向：在返回值前面加”redirect:”，譬如”redirect:<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></p>
<h2 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。</p>
<p>具体步骤如下 ：</p>
<p>（1）  加入Jackson.jar</p>
<p>（2）  在配置文件中配置json的映射</p>
<p>（3）  在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<h2 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><p>（1）  解决post请求乱码问题：</p>
<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;filter&gt;</span><br><span class="line">2 &lt;filter‐name&gt;CharacterEncodingFilter&lt;/filter‐name&gt;</span><br><span class="line">3 &lt;filter‐class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/fi</span><br><span class="line">lter‐class&gt;</span><br><span class="line">4</span><br><span class="line">5 &lt;init‐param&gt;</span><br><span class="line">6 &lt;param‐name&gt;encoding&lt;/param‐name&gt;</span><br><span class="line">7 &lt;param‐value&gt;utf‐8&lt;/param‐value&gt;</span><br><span class="line">8 &lt;/init‐param&gt;</span><br><span class="line">9 &lt;/filter&gt;</span><br><span class="line">10</span><br><span class="line">11 &lt;filter‐mapping&gt;</span><br><span class="line">12 &lt;filter‐name&gt;CharacterEncodingFilter&lt;/filter‐name&gt;</span><br><span class="line">13 &lt;url‐pattern&gt;/*&lt;/url‐pattern&gt;</span><br><span class="line">14 &lt;/filter‐mapping&gt;</span><br></pre></td></tr></table></figure>

<p>（2）get请求中文参数出现乱码解决方法有两个： </p>
<p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;ConnectorURIEncoding=&quot;utf‐8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; proto</span><br><span class="line">col=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>②另外一种方法对参数进行重新编码：</p>
<p>String userName &#x3D; new </p>
<p>String(request.getParamter(“userName”).getBytes(“ISO8859-</p>
<p>1”),“utf-8”)</p>
<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h2 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h2><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<h3 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上 method&#x3D;RequestMethod.GET。</p>
<h2 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h2><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>
<h3 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>
<h2 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h2><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p>
<h3 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h2 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h2><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!‐‐ 配置Spring MVC的拦截器 ‐‐&gt;</span><br><span class="line">2 &lt;mvc:interceptors&gt;</span><br><span class="line">3 &lt;!‐‐ 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 ‐‐&gt;</span><br><span class="line">4 &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.zwp.action.MyHandlerInterceptor&quot;&gt;&lt;/b</span><br><span class="line">ean&gt;</span><br><span class="line">5 &lt;!‐‐ 只针对部分请求拦截 ‐‐&gt;</span><br><span class="line">6 &lt;mvc:interceptor&gt;</span><br><span class="line">7 &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;</span><br><span class="line">8 &lt;bean class=&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot; /&gt;</span><br><span class="line">9 &lt;/mvc:interceptor&gt;</span><br><span class="line">10 &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h2><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:23" itemprop="dateModified" datetime="2021-03-03T13:51:23+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="并发编程的优缺点为什么要使用并发编程（并发编程的优点）"><a href="#并发编程的优缺点为什么要使用并发编程（并发编程的优点）" class="headerlink" title="并发编程的优缺点为什么要使用并发编程（并发编程的优点）"></a>并发编程的优缺点为什么要使用并发编程（并发编程的优点）</h2><ul>
<li>充分利用多核CPU的计算能力：通过并发编程的形式可以将多核CPU 的计算能力发挥到极致，性能得到提升</li>
<li>方便进行业务拆分，提升系统并发能力和性能：在特殊的业务场景下，先天的就适合于并发编程。现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li>
</ul>
<h2 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h2><p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如</p>
<p><strong>：内存泄漏、上下文切换、线程安全、死锁</strong>等问题。</p>
<h2 id="并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？"><a href="#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h2><p>并发编程三要素（线程的安全性问题体现在）： </p>
<p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么 全部执行成功要么全部执行失败。 </p>
<p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。 （synchronized,volatile） </p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行 重排序） </p>
<p>出现线程安全问题的原因： </p>
<ul>
<li>线程切换带来的原子性问题 </li>
<li>缓存导致的可见性问题 </li>
<li>编译优化带来的有序性问题</li>
</ul>
<p>解决办法： </p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题 </li>
<li>synchronized、volatile、LOCK，可以解决可见性问题 </li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
<h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><ul>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑 上来看那些任务是同时执行。 </li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上 的“同时进行”。 </li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行 所以不存在线程不安全情况，也就不存在临界区的问题。</li>
</ul>
<p>做一个形象的比喻： </p>
<p>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>串行 &#x3D; 一个队列和一台咖啡机。</p>
<h2 id="什么是多线程，多线程的优劣？"><a href="#什么是多线程，多线程的优劣？" class="headerlink" title="什么是多线程，多线程的优劣？"></a>什么是多线程，多线程的优劣？</h2><p>多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个 不同的线程来执行不同的任务。 </p>
<p>多线程的好处： 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可 以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单 个程序创建多个并行执行的线程来完成各自的任务。 </p>
<p>多线程的劣势： </p>
<ul>
<li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； </li>
<li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程； </li>
<li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问 题。</li>
</ul>
<h2 id="线程和进程区别-什么是线程和进程"><a href="#线程和进程区别-什么是线程和进程" class="headerlink" title="线程和进程区别 什么是线程和进程?"></a>线程和进程区别 什么是线程和进程?</h2><p>**进程 **</p>
<p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进 程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进 程。 </p>
<p><strong>线程</strong></p>
<p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至 少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。 </p>
<p>**进程与线程的区别 **</p>
<p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight  Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)， 它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有 若干个线程，至少包含一个线程。 </p>
<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执 行的基本单位 </p>
<p><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切 换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空 间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开 销小。 </p>
<p><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线 （线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻 量级进程。 </p>
<p><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空 间和资源是相互独立的 </p>
<p><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个 线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 </p>
<p><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控 制，两者均可并发执行 </p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任 意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的 策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就 会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 </p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存 自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务<br>从保存到再加载的过程就是一次上下文切换。</strong> </p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在 每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换 对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一 项就是，其上下文切换和模式切换的时间消耗非常少。 </p>
<h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><p>守护线程和用户线程 </p>
<ul>
<li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网 络的子线程等都是用户线程 </li>
<li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护 线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程 会随 JVM 一起结束工作</li>
</ul>
<p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部 同时还启动了好多守护线程，比如垃圾回收线程。 比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线 程运行。而守护线程不会影响 JVM 的退出。 </p>
<p>注意事项： </p>
<ol>
<li>setDaemon(true)必须在start()方法前执行，否则会抛出  IllegalThreadStateException 异常 </li>
<li>在守护线程中产生的新线程也是守护线程 </li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算 逻辑 </li>
<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清 理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守 护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语 句块可能无法被执行。</li>
</ol>
<h2 id="如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？"><a href="#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h2><p>windows上面用任务管理器看，linux下可以用 top 这个工具看。</p>
<ol>
<li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p 查 找出cpu利用厉害的pid号 </li>
<li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查 找出cpu利用率厉害的线程号，比如top -H -p 1328 </li>
<li>将获取到的线程号转换成16进制，去百度转换一下就行 </li>
<li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; &#x2F;tmp&#x2F;t.dat，比 如jstack 31365 &gt; &#x2F;tmp&#x2F;t.dat </li>
<li>编辑&#x2F;tmp&#x2F;t.dat文件，查找线程号对应的信息</li>
</ol>
<h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>百度百科：死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资 源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推 进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进 程（线程）称为死锁进程（线程）。 </p>
<p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线 程被无限期地阻塞，因此程序不可能正常终止。 </p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方 的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.png" alt="线程死锁"></p>
<p>线程死锁 下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 ： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 public class DeadLockDemo &#123; </span><br><span class="line">2  private static Object resource1 = new Object();//资源 1 </span><br><span class="line">3  private static Object resource2 = new Object();//资源 2</span><br><span class="line">4 </span><br><span class="line">5  public static void main(String[] args) &#123;</span><br><span class="line">6  new Thread(() ‐&gt; &#123; </span><br><span class="line">7  synchronized (resource1) &#123; </span><br><span class="line">8  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">9  try &#123; </span><br><span class="line">10  Thread.sleep(1000); </span><br><span class="line">11  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">12  e.printStackTrace(); </span><br><span class="line">13  &#125; </span><br><span class="line">14  System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); </span><br><span class="line">15  synchronized (resource2) &#123; </span><br><span class="line">16  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">17  &#125; </span><br><span class="line">18  &#125; </span><br><span class="line">19  &#125;, &quot;线程 1&quot;).start();</span><br><span class="line">20 </span><br><span class="line">21  new Thread(() ‐&gt; &#123; </span><br><span class="line">22  synchronized (resource2) &#123; </span><br><span class="line">23  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">24  try &#123; </span><br><span class="line">25  Thread.sleep(1000); </span><br><span class="line">26  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">27  e.printStackTrace(); </span><br><span class="line">28  &#125; </span><br><span class="line">29  System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;); </span><br><span class="line">30  synchronized (resource1) &#123; </span><br><span class="line">31  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">32  &#125; </span><br><span class="line">33  &#125; </span><br><span class="line">34  &#125;, &quot;线程 2&quot;).start(); </span><br><span class="line">35  &#125; </span><br><span class="line">36 &#125; </span><br></pre></td></tr></table></figure>

<p>输出结果 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 Thread[线程 1,5,main]get resource1 </span><br><span class="line">2 Thread[线程 2,5,main]get resource2 </span><br><span class="line">3 Thread[线程 1,5,main]waiting get resource2 </span><br><span class="line">4 Thread[线程 2,5,main]waiting get resource1 </span><br></pre></td></tr></table></figure>

<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通 过Thread.sleep(1000)；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然 后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死 锁。上面的例子符合产生死锁的四个必要条件。 </p>
<h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ol>
<li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只 能被一个线程(进程)占用，直到被该线程(进程)释放 </li>
<li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对 已获得的资源保持不放。 </li>
<li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程 强行剥夺，只有自己使用完毕后才释放资源。 </li>
<li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环 路（类似于死循环），造成永久阻塞</li>
</ol>
<h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。 </p>
<p><strong>破坏互斥条件</strong> </p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源 需要互斥访问）。 </p>
<p><strong>破坏请求与保持条件</strong> </p>
<p>一次性申请所有的资源。 </p>
<p>**破坏不剥夺条件 **</p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占 有的资源。 </p>
<p>**破坏循环等待条件 **</p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环 等待条件。 </p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 new Thread(() ‐&gt; &#123; </span><br><span class="line">2  synchronized (resource1) &#123; </span><br><span class="line">3  System.out.println(Thread.currentThread() + &quot;get resource1&quot;); </span><br><span class="line">4  try &#123; </span><br><span class="line">5  Thread.sleep(1000); </span><br><span class="line">6  &#125; catch (InterruptedException e) &#123; </span><br><span class="line">7  e.printStackTrace();</span><br><span class="line">8  &#125; </span><br><span class="line">9  System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); </span><br><span class="line">10  synchronized (resource2) &#123; </span><br><span class="line">11  System.out.println(Thread.currentThread() + &quot;get resource2&quot;); </span><br><span class="line">12  &#125; </span><br><span class="line">13  &#125; </span><br><span class="line">14 &#125;, &quot;线程 2&quot;).start(); </span><br></pre></td></tr></table></figure>

<p>输出结果 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 Thread[线程 1,5,main]get resource1 </span><br><span class="line">2 Thread[线程 1,5,main]waiting get resource2 </span><br><span class="line">3 Thread[线程 1,5,main]get resource2 </span><br><span class="line">4 Thread[线程 2,5,main]get resource1 </span><br><span class="line">5 Thread[线程 2,5,main]waiting get resource2 </span><br><span class="line">6 Thread[线程 2,5,main]get resource2 </span><br></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生? </p>
<p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后 线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对  resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样 就破坏了破坏循环等待条件，因此避免了死锁。 </p>
<h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>创建线程有四种方式：</p>
<ul>
<li>继承 Thread 类；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>使用 Executors 工具类创建线程池继承 Thread 类</li>
</ul>
<p>步骤</p>
<ol>
<li>定义一个Thread类的子类，重写run方法，将相关逻辑实现，run()方法</li>
</ol>
<p>就是线程要执行的业务逻辑方法 </p>
<ol start="2">
<li><p>创建自定义的线程子类对象</p>
</li>
<li><p>调用子类实例的star()方法来启动线程</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyThread extends Thread &#123;</span><br><span class="line">2 </span><br><span class="line">3	@Override</span><br><span class="line">4	public void run() &#123;</span><br><span class="line">5	System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);</span><br><span class="line">6	&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 public class TheadTest &#123;</span><br><span class="line">2</span><br><span class="line">3	public static void main(String[] args) &#123;</span><br><span class="line">4	MyThread myThread = new MyThread();</span><br><span class="line">5	myThread.start();</span><br><span class="line">6	System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);</span><br><span class="line">7	&#125;</span><br><span class="line">8</span><br><span class="line">9 &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>运行结果 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 main main()方法执行结束 </span><br><span class="line">2 Thread‐0 run()方法正在执行... </span><br></pre></td></tr></table></figure>

<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>步骤</p>
<ol>
<li><p>定义Runnable接口实现类MyRunnable，并重写run()方法</p>
</li>
<li><p>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，该Thread对象才是真正的线程对象</p>
</li>
<li><p>调用线程对象的start()方法</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyRunnable implements Runnable &#123;</span><br><span class="line">2</span><br><span class="line">3	@Override</span><br><span class="line">4	public void run() &#123;</span><br><span class="line">5	System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">6	&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br><span class="line">1 public class RunnableTest &#123;</span><br><span class="line">2</span><br><span class="line">3	public static void main(String[] args) &#123;</span><br><span class="line">4	MyRunnable myRunnable = new MyRunnable();</span><br><span class="line">5	Thread thread = new Thread(myRunnable);</span><br><span class="line">6	thread.start();</span><br><span class="line">7	System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">8	&#125;</span><br><span class="line">9</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	main main()方法执行完成</span><br><span class="line">2	Thread‐0 run()方法执行中...</span><br></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>步骤</p>
<ol>
<li><p>创建实现Callable接口的类myCallable</p>
</li>
<li><p>以myCallable为参数创建FutureTask对象</p>
</li>
<li><p>将FutureTask作为参数创建Thread对象</p>
</li>
<li><p>调用线程对象的start()方法</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">2</span><br><span class="line">3	@Override</span><br><span class="line">4	public Integer call() &#123;</span><br><span class="line">5	System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);</span><br><span class="line">6	return 1;</span><br><span class="line">7	&#125;</span><br><span class="line">8</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 public class CallableTest &#123;</span><br><span class="line">2</span><br><span class="line">3	public static void main(String[] args) &#123;</span><br><span class="line">4	FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());</span><br><span class="line">5	Thread thread = new Thread(futureTask);</span><br><span class="line">6	thread.start();</span><br><span class="line">7</span><br><span class="line">8	try &#123;</span><br><span class="line">9	Thread.sleep(1000);</span><br><span class="line">10	System.out.println(&quot;返回结果 &quot; + futureTask.get());</span><br><span class="line">11	&#125; catch (InterruptedException e) &#123;</span><br><span class="line">12	e.printStackTrace();</span><br><span class="line">13	&#125; catch (ExecutionException e) &#123;</span><br><span class="line">14	e.printStackTrace();</span><br><span class="line">15	&#125;</span><br><span class="line">16	System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">17	&#125;</span><br><span class="line">18</span><br><span class="line">19 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1	Thread‐0 call()方法执行中...</span><br><span class="line">2	返回结果 1</span><br><span class="line">3	main main()方法执行完成</span><br></pre></td></tr></table></figure>

<h3 id="使用-Executors-工具类创建线程池"><a href="#使用-Executors-工具类创建线程池" class="headerlink" title="使用 Executors 工具类创建线程池"></a>使用 Executors 工具类创建线程池</h3><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public class MyRunnable implements Runnable &#123;</span><br><span class="line">2</span><br><span class="line">3	@Override</span><br><span class="line">4	public void run() &#123;</span><br><span class="line">5	System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">6	&#125;</span><br><span class="line">7</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 public class SingleThreadExecutorTest &#123;</span><br><span class="line">2 </span><br><span class="line">3  public static void main(String[] args) &#123; </span><br><span class="line">4  ExecutorService executorService = Executors.newSingleThreadExecutor(); </span><br><span class="line">5  MyRunnable runnableTest = new MyRunnable(); </span><br><span class="line">6	for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">7	executorService.execute(runnableTest);</span><br><span class="line">8	&#125;</span><br><span class="line">9</span><br><span class="line">10	System.out.println(&quot;线程任务开始执行&quot;);</span><br><span class="line">11	executorService.shutdown();</span><br><span class="line">12	&#125;</span><br><span class="line">13</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	线程任务开始执行</span><br><span class="line">2	pool‐1‐thread‐1 is running...</span><br><span class="line">3	pool‐1‐thread‐1 is running...</span><br><span class="line">4	pool‐1‐thread‐1 is running...</span><br><span class="line">5	pool‐1‐thread‐1 is running...</span><br><span class="line">6	pool‐1‐thread‐1 is running...</span><br></pre></td></tr></table></figure>

<h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的， run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。 start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待 run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说</p>
<p>Callable用于产生结果，Future 用于获取结果。</p>
<h2 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h2><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 </p>
<p>Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判</p>
<p>断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 </p>
<p>Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>
<h2 id="线程的状态和基本操作说说线程的生命周期及五种基本状态？"><a href="#线程的状态和基本操作说说线程的生命周期及五种基本状态？" class="headerlink" title="线程的状态和基本操作说说线程的生命周期及五种基本状态？"></a>线程的状态和基本操作说说线程的生命周期及五种基本状态？</h2><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p>
<ol>
<li><p>新建(new)：新创建了一个线程对象。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p>
</li>
<li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片</p>
</li>
</ol>
<p>（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； </p>
<ol start="4">
<li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</li>
</ol>
<p>阻塞的情况分三种：</p>
<p>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；</p>
<p>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</p>
<p>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会</p>
<p>进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p>
<ol start="5">
<li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了 run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
<h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p>
<p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<p>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
<p>ava虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用</p>
<p>CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用</p>
<p>CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>
<h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p>线程调度器选择优先级 高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p>
<p>（1）  线程体中调用了 yield 方法让出了对 cpu 的占用权利</p>
<p>（2）  线程体中调用了 sleep 方法使线程进入睡眠状态</p>
<p>（3）  线程由于 IO 操作受到阻塞</p>
<p>（4）  另外一个更高优先级线程出现</p>
<p>（5）  在支持时间片的系统中，该线程的时间片用完</p>
<h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</h2><p>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 </p>
<p>CPU 时间可以基于线程优先级或者线程等待的时间。</p>
<p>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择</p>
<p>（也就是说不要让你的程序依赖于线程的优先级）。</p>
<p>请说出与线程同步以及线程调度相关的方法。</p>
<p>（1）  wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<p>（2）  sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p>
<p>（3）  notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>
<p>（4）  notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给</p>
<p>所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>两者都可以暂停线程的执行</p>
<ul>
<li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li>
<li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用途不同：Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>
<li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<p>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1	synchronized (monitor) &#123;</span><br><span class="line">2	// 判断条件谓词是否得到满足</span><br><span class="line">3	while(!locked) &#123;</span><br><span class="line">4	// 等待唤醒</span><br><span class="line">5	monitor.wait();</span><br><span class="line">6	&#125;</span><br><span class="line">7	// 处理其他的业务逻辑</span><br><span class="line">8	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p>
<h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，</p>
<p>接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 </p>
<p>notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放</p>
<p>这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p>
<p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p>
<h2 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h2><p>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其</p>
<p>他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><p>（1）  sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>（2）  线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p>
<p>（3）  sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p>
<p>（4）  sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p>
<h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><p>在java中有以下3种方法可以终止正在运行的线程：</p>
<p>\1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p>
<p>\2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及 resume一样都是过期作废的方法。</p>
<p>\3. 使用interrupt方法中断线程。</p>
<h2 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h2><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监</p>
<p>视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出</p>
<p>interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p>
<p>isInterrupted：查看当前中断信号是true还是false 什么是阻塞式方法？</p>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回.</p>
<h2 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h2><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的</p>
<p>notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p>
<p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p>
<h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>
<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>
<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争</p>
<p>成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。如何在两个线程间共享数据？在两个线程间共享变量即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h2 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h2><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作比如说 经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p>
<p>Java中线程通信协作的 常见的两种方式：</p>
<p>一.syncrhoized加锁的线程的Object类的wait()&#x2F;notify()&#x2F;notifyAll()</p>
<p>二.ReentrantLock类加锁的线程的Condition类的await()&#x2F;signal()&#x2F;signalAll() 线程间直接的数据交换：</p>
<p>三.通过管道进行线程间通信：1）字节流；2）字符流同步方法和同步块，哪个是更好的选择？</p>
<p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<p>请知道一条原则：同步的范围越小越好。</p>
<h2 id="什么是线程同步和线程互斥，有哪几种实现方式？"><a href="#什么是线程同步和线程互斥，有哪几种实现方式？" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式？"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h2><p>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</p>
<p>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</p>
<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻  多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p>
<p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p>
<p>实现线程同步的方法</p>
<ul>
<li>同步代码方法：sychronized 关键字修饰的方法同步代码块：</li>
<li>sychronized 关键字修饰的代码块</li>
<li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li>
<li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了 lock接口的锁他与sychronized方法具有相同的基本行为和语义</li>
</ul>
<h2 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h2><p>在 java 虚拟机中，每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p>
<p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的</p>
<p>监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p>
<p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p>
<h2 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h2><p>这里区分一下：</p>
<p>（1）  如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，</p>
<p>没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p>
<p>（2）  如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到</p>
<p>ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据</p>
<p>maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略</p>
<p>RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 什么叫线程安全？servlet 是线程安全吗?</p>
<p>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</p>
<p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p>
<p>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程</p>
<p>安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p>
<h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p>
<p>方法二：使用自动锁 synchronized。</p>
<p>方法三：使用手动锁 Lock。</p>
<p>手动锁 Java 示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 Lock lock = new ReentrantLock(); </span><br><span class="line">2 lock. lock(); </span><br><span class="line">3 try &#123;</span><br><span class="line">4	System. out. println(&quot;获得锁&quot;);</span><br><span class="line">5	&#125; catch (Exception e) &#123;</span><br><span class="line">6	// TODO: handle exception</span><br><span class="line">7	&#125; finally &#123;</span><br><span class="line">8	System. out. println(&quot;释放锁&quot;);</span><br><span class="line">9	lock. unlock();</span><br><span class="line">10	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h2><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先 权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS  dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程 会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表低 优先级，10 代表高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先 级有关，如非特别需要，一般无需设置线程优先级。</p>
<p>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p>
<h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 </p>
<p>new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了</p>
<p>Thread1，main 函数中 new 了 Thread2，那么：</p>
<p>（1）  Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</p>
<p>（2）  Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</p>
<h2 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</h2><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump 文件中。</p>
<p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。</p>
<p>在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p>
<p>一个线程运行时发生异常会怎样？如果异常没有被捕获该线程将会停止执行。</p>
<p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 </p>
<p>Thread.getUncaughtExceptionHandler()来查询线程的</p>
<p>UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p>
<h2 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h2><ul>
<li><p>线程的生命周期开销非常高消耗过多的 </p>
</li>
<li><p>CPU资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p>
</li>
<li><p>降低稳定性JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p>
</li>
</ul>
<h1 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java中垃圾回收有什么目的？什么时候进行垃圾回收？垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p>
<h3 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h3><p>不会，在下一个垃圾回调周期中，这个对象将是被可回收的。</p>
<p>也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</p>
<h3 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h3><p>1）     垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；</p>
<p>finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { }</p>
<p>在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间</p>
<p>2）     GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。</p>
<h3 id="重排序数据依赖性为什么代码会重排序？"><a href="#重排序数据依赖性为什么代码会重排序？" class="headerlink" title="重排序数据依赖性为什么代码会重排序？"></a>重排序数据依赖性为什么代码会重排序？</h3><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image001.gif" alt="img">在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：在单线程环境下不能改变程序运行的结果；存在数据依赖关系的不允许重排序需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
<h2 id="as-if-srial规则和happens-before规则的区别"><a href="#as-if-srial规则和happens-before规则的区别" class="headerlink" title="as-if-srial规则和happens-before规则的区别"></a>as-if-srial规则和happens-before规则的区别</h2><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image002.gif" alt="img"> as-if-serial语义保证单线程内程序的执行结果不被改变，happensbefore关系保证正确同步的多线程程序的执行结果不被改变。 <img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image003.gif" alt="img"> as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before指定的顺序来执行的。</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image004.gif" alt="img"> as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p>
<h1 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-的作用？"><a href="#synchronized-的作用？" class="headerlink" title="synchronized 的作用？"></a>synchronized 的作用？</h3><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</p>
<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视</p>
<p>器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的</p>
<p>线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方</p>
<p>对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p>synchronized关键字最主要的三种使用方式：</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image005.gif" alt="img"> 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image006.gif" alt="img"> 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 <img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/clip_image007.gif" alt="img"> 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定</p>
<p>对象的锁。</p>
<p>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实</p>
<p>例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具</p>
<p>有缓存功能！下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 public class Singleton &#123;</span><br><span class="line">2</span><br><span class="line">3 private volatile static Singleton uniqueInstance;</span><br><span class="line">4</span><br><span class="line">5	private Singleton() &#123;</span><br><span class="line">6	&#125;</span><br><span class="line">7</span><br><span class="line">8	public static Singleton getUniqueInstance() &#123;</span><br><span class="line">9	//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br><span class="line">10	if (uniqueInstance == null) &#123;</span><br><span class="line">11	//类对象加锁</span><br><span class="line">12	synchronized (Singleton.class) &#123;</span><br><span class="line">13	if (uniqueInstance == null) &#123;</span><br><span class="line">14	uniqueInstance = new Singleton();</span><br><span class="line">15	&#125;</span><br><span class="line">16	&#125;</span><br><span class="line">17	&#125;</span><br><span class="line">18	return uniqueInstance;</span><br><span class="line">19	&#125;</span><br><span class="line">20	&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance </p>
<p>&#x3D; new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li><p>为 uniqueInstance 分配内存空间</p>
</li>
<li><p>初始化 uniqueInstance</p>
</li>
<li><p>将 uniqueInstance 指向分配的内存地址</p>
</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 </p>
<p>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。说一下 synchronized 底层实现原理？</p>
<p>synchronized是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过javap命令，查看相应的字节码文件。 synchronized 同步语句块的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	public class SynchronizedDemo &#123;</span><br><span class="line">2	public void method() &#123;</span><br><span class="line">3	synchronized (this) &#123;</span><br><span class="line">4	System.out.println(&quot;synchronized 代码块&quot;);</span><br><span class="line">5	&#125;</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<p>通过JDK 反汇编指令 javap -c -v SynchronizedDemo</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109183510197.png" alt="image-20201109183510197"></p>
<p>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是</p>
<p>monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</p>
<p>为什么会有两个monitorexit呢？</p>
<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此 后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p>
<p>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</p>
<p>synchronized可重入的原理</p>
<p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h3 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h3 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果</p>
<p>一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="线程-B-怎么知道线程-A-修改了变量"><a href="#线程-B-怎么知道线程-A-修改了变量" class="headerlink" title="线程 B 怎么知道线程 A 修改了变量"></a>线程 B 怎么知道线程 A 修改了变量</h3><p>（1）  volatile 修饰变量</p>
<p>（2）  synchronized 修饰修改变量的方法</p>
<p>（3）  wait&#x2F;notify</p>
<p>（4）while 轮询</p>
<h3 id="当一个线程进一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池</p>
<p>（注意不是等待池哦）中等待对象的锁。</p>
<h3 id="synchronized、volatile、CAS-比较"><a href="#synchronized、volatile、CAS-比较" class="headerlink" title="synchronized、volatile、CAS 比较"></a>synchronized、volatile、CAS 比较</h3><p>（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p>
<p>（3）CAS 是基于冲突检测的乐观锁（非阻塞）</p>
<h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul>
<li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； </li>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比</p>
<p>synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都</p>
<p>相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>相同点：两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</p>
<p>同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0 时才能释放锁。主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li>
<li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>
<li>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：  普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象    </li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h3><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 </p>
<p>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 </p>
<p>AtomicInteger。</p>
<p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h3><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<h3 id="volatle-变量和-atomic-变量有什么不同？"><a href="#volatle-变量和-atomic-变量有什么不同？" class="headerlink" title="volatle 变量和 atomic 变量有什么不同？"></a>volatle 变量和 atomic 变量有什么不同？</h3><p>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</p>
<p>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如</p>
<p>getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h3><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p>
<p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double 可以保证其操作原子性。</p>
<p>所以从Oracle Java Spec里面可以看到：</p>
<ul>
<li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li>
<li>如果使用volatile修饰long和double，那么其读写都是原子操作对于64位的引用地址的读写，都是原子操作</li>
<li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li>
<li>推荐JVM实现为原子操作</li>
</ul>
<h3 id="volatile-修饰符的有过什么实践？"><a href="#volatile-修饰符的有过什么实践？" class="headerlink" title="volatile 修饰符的有过什么实践？"></a>volatile 修饰符的有过什么实践？</h3><p>单例模式</p>
<p>是否 Lazy 初始化：是是否多线程安全：是</p>
<p>实现难度：较复杂描述：对于Double-Check这种可能出现的问题（当然这种概率已经非常小了，但毕竟还是有的嘛~），解决方案是：只需要给instance的声明加上volatile关</p>
<p>键字即可volatile关键字的一个作用是禁止指令重排，把instance声明为volatile 之后，对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。注意：volatile阻止的不是singleton &#x3D; newSingleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 public class Singleton7 &#123;</span><br><span class="line">2 </span><br><span class="line">3  private static volatile Singleton7 instance = null;</span><br><span class="line">4 </span><br><span class="line">5  private Singleton7() &#123;&#125;</span><br><span class="line">6</span><br><span class="line">7  public static Singleton7 getInstance() &#123;</span><br><span class="line">8  if (instance == null) &#123;</span><br><span class="line">9  synchronized (Singleton7.class) &#123;</span><br><span class="line">10  if (instance == null) &#123;</span><br><span class="line">11  instance = new Singleton7(); </span><br><span class="line">12  &#125; </span><br><span class="line">13  &#125; </span><br><span class="line">14  &#125;</span><br><span class="line">15 </span><br><span class="line">16  return instance;</span><br><span class="line">17  &#125;</span><br><span class="line">18 </span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p>
<p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p>
<p>区别</p>
<ul>
<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比 synchronized关键字要好。但是volatile关键字只能用于变量而</li>
</ul>
<p>synchronized关键字可以修饰方法以及代码块。synchronized关键字在</p>
<p>JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="什么是不可变对象，它对写并发应用有什么帮助？"><a href="#什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助？"></a>什么是不可变对象，它对写并发应用有什么帮助？</h3><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p>
<p>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不</p>
<p>可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p>
<p>只有满足如下状态，一个对象才是不可变的；  它的状态不能在创建后再被修改；  所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</p>
<p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>
<h1 id="Lock体系"><a href="#Lock体系" class="headerlink" title="Lock体系"></a>Lock体系</h1><h2 id="Lock简介与初识AQS"><a href="#Lock简介与初识AQS" class="headerlink" title="Lock简介与初识AQS"></a>Lock简介与初识AQS</h2><h3 id="Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1）  可以使锁更公平</p>
<p>（2）  可以使线程在等待锁的时候响应中断</p>
<p>（3）  可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4）  可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p>
<h3 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3><p>悲观锁：总是假设 坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 </p>
<p>Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<p>乐观锁的实现方式：</p>
<p>1、     使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p>
<p>2、     java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值</p>
<p>（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。</p>
<h3 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h3><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p>
<p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。</p>
<p>悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p>
<p>CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面</p>
<p>的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p>
<p>java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的</p>
<p>(AtomicInteger,AtomicBoolean,AtomicLong)。</p>
<h3 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h3><p>1、     ABA 问题：比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2、     循环时间长开销大：</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>
<p>3、     只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。什么是死锁？</p>
<p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 </p>
<p>b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h3 id="产生死锁的条件是什么？怎么防止死锁？"><a href="#产生死锁的条件是什么？怎么防止死锁？" class="headerlink" title="产生死锁的条件是什么？怎么防止死锁？"></a>产生死锁的条件是什么？怎么防止死锁？</h3><p>产生死锁的必要条件：</p>
<p>1、     互斥条件：所谓互斥就是进程在某一时间内独占资源。</p>
<p>2、     请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>3、     不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</p>
<p>4、     循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>
<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以 大可能地避免、预防和 解除死锁。</p>
<p>防止死锁可以采用以下的方法：</p>
<ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、</li>
<li>ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块。</li>
</ul>
<h3 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<p>1、     高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>
<p>2、     线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
<p>3、     线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p>
<h3 id="多线程锁的升级原理是什么？"><a href="#多线程锁的升级原理是什么？" class="headerlink" title="多线程锁的升级原理是什么？"></a>多线程锁的升级原理是什么？</h3><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降</p>
<h2 id="AQ-级。-S-AbstractQueuedSynchronizer-详解与源码分析"><a href="#AQ-级。-S-AbstractQueuedSynchronizer-详解与源码分析" class="headerlink" title="AQ(级。)S(AbstractQueuedSynchronizer)详解与源码分析"></a>AQ(级。)S(AbstractQueuedSynchronizer)详解与源码分析</h2><h3 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h3><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks包下面。</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109202104977.png" alt="image-20201109202104977"></p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h3><p>下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<p>AQS 原理概览</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制</p>
<p>AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
<p>看个AQS(AbstractQueuedSynchronizer)原理图：</p>
<p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109202131975.png" alt="image-20201109202131975"></p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1	//返回同步状态的当前值</span><br><span class="line">2	protected final int getState() &#123;</span><br><span class="line">3	return state;</span><br><span class="line">4	&#125;</span><br><span class="line">5	// 设置同步状态的值</span><br><span class="line">6	protected final void setState(int newState) &#123;</span><br><span class="line">7	state = newState;</span><br><span class="line">8	&#125;</span><br><span class="line">9	//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect （期望值）</span><br><span class="line">10	protected final boolean compareAndSetState(int expect, int update) &#123; </span><br><span class="line">11 return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>AQS 对资源的共享方式</p>
<p>AQS定义两种资源共享方式</p>
<ul>
<li><p>xclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：  </p>
<p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>
<p>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</p>
</li>
<li><p>Share（共享）：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p>
</li>
</ul>
<p>AQS底层使用了模板方法模式同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样</p>
<p>（模板方法模式很经典的一个应用）：</p>
<ol>
<li><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p>
</li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">2	tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">3	tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">4	tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">5	tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回fals e。</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，</p>
<p>会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就</p>
<p>会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累</p>
<p>加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为</p>
<p>N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS 也支持自定义同步器同时实现独占和共享两种方式，如</p>
<p>ReentrantReadWriteLock。</p>
<h2 id="ReentrantLock-重入锁-实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？"><a href="#ReentrantLock-重入锁-实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？" class="headerlink" title="ReentrantLock(重入锁)实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？"></a>ReentrantLock(重入锁)实现原理与公平锁非公平锁区别什么是可重入锁（ReentrantLock）？</h2><p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频</p>
<p>率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</p>
<p>在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是</p>
<p>ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。</p>
<p>重入性的实现原理要想支持重入性，就要解决两个问题：1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。</p>
<p>ReentrantLock支持两种锁：公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。</p>
<h2 id="读写锁ReentrantReadWriteLock源码分析"><a href="#读写锁ReentrantReadWriteLock源码分析" class="headerlink" title="读写锁ReentrantReadWriteLock源码分析"></a>读写锁ReentrantReadWriteLock源码分析</h2><h3 id="ReadWriteLock-是什么"><a href="#ReadWriteLock-是什么" class="headerlink" title="ReadWriteLock 是什么"></a>ReadWriteLock 是什么</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p>
<p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离</p>
<p>技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<p>而读写锁有以下三个重要的特性：</p>
<p>（1）  公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p>
<p>（2）  重进入：读锁和写锁都支持线程重进入。</p>
<p>（3）  锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p>
<h2 id="Condition源码分析与等待通知机制-LockSupport详解并发容器并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析"><a href="#Condition源码分析与等待通知机制-LockSupport详解并发容器并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析" class="headerlink" title="Condition源码分析与等待通知机制 LockSupport详解并发容器并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析"></a>Condition源码分析与等待通知机制 LockSupport详解并发容器并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</h2><h3 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h3><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。平时涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p>
<p>那么它到底是如何实现线程安全的？</p>
<p>JDK 1.6版本关键要素：</p>
<ul>
<li>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；</li>
<li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。</li>
</ul>
<p>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 </p>
<p>CAS + synchronized 来保证并发安全性。</p>
<h3 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h3><p>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数</p>
<p>的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p>
<p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>
<h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果</p>
<p>有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，</p>
<p>Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。</p>
<p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操</p>
<p>作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p>
<h3 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像</p>
<p>ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p>
<h3 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</p>
<p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。</p>
<p>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</p>
<p>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</p>
<p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出</p>
<p>ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
<h2 id="并发容器之CopyOnWriteArrayList详解"><a href="#并发容器之CopyOnWriteArrayList详解" class="headerlink" title="并发容器之CopyOnWriteArrayList详解"></a>并发容器之CopyOnWriteArrayList详解</h2><h3 id="CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？"><a href="#CopyOnWriteArrayList-是什么，可以用于什么应用场景？有哪些优缺点？" class="headerlink" title="CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？"></a>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</h3><p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p>
<p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在</p>
<p>CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<p>CopyOnWriteArrayList 的使用场景通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>
<p>CopyOnWriteArrayList 的缺点</p>
<ol>
<li><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</p>
</li>
<li><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然</p>
</li>
</ol>
<p>CopyOnWriteArrayList 能做到   终一致性,但是还是没法满足实时性要求。</p>
<ol start="3">
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add&#x2F;set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li>
</ol>
<p>CopyOnWriteArrayList 的设计思想</p>
<ol>
<li><p>读写分离，读和写分开</p>
</li>
<li><p>终一致性</p>
</li>
<li><p>使用另外开辟空间的思路，来解决并发冲突并发容器之ThreadLocal详解</p>
</li>
</ol>
<h3 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>hreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个</p>
<p>ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，</p>
<p>每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p>
<p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。</p>
<p>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。 ThreadLocal 使用例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadLocal &#123;</span><br><span class="line">2</span><br><span class="line">3	//线程本地存储变量</span><br><span class="line">4	private static final ThreadLocal&lt;Integer&gt; THREAD_LOCAL_NUM</span><br><span class="line">5	= new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">6	@Override</span><br><span class="line">7	protected Integer initialValue() &#123;</span><br><span class="line">8	return 0;</span><br><span class="line">9	&#125;</span><br><span class="line">10	&#125;;</span><br><span class="line">11</span><br><span class="line">12	public static void main(String[] args) &#123;</span><br><span class="line">13	for (int i = 0; i &lt;3; i++) &#123;//启动三个线程</span><br><span class="line">14	Thread t = new Thread() &#123;</span><br><span class="line">15	@Override</span><br><span class="line">16	public void run() &#123;</span><br><span class="line">17	add10ByThreadLocal();</span><br><span class="line">18	&#125;</span><br><span class="line">19	&#125;;</span><br><span class="line">20	t.start();</span><br><span class="line">21	&#125;</span><br><span class="line">22	&#125;</span><br><span class="line">23</span><br><span class="line">24	/**</span><br><span class="line">25	* 线程本地存储变量加 5</span><br><span class="line">*/</span><br><span class="line">26 </span><br><span class="line">27	private static void add10ByThreadLocal() &#123;</span><br><span class="line">28	for (int i = 0; i &lt;5; i++) &#123;</span><br><span class="line">29	Integer n = THREAD_LOCAL_NUM.get();</span><br><span class="line">30	n += 1;</span><br><span class="line">31	THREAD_LOCAL_NUM.set(n);</span><br><span class="line">32	System.out.println(Thread.currentThread().getName() + &quot; : ThreadLocal n um=&quot; + n);</span><br><span class="line">33	&#125;</span><br><span class="line">34	&#125;</span><br><span class="line">35</span><br><span class="line">36 &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：启动了 3 个线程，每个线程 后都打印到 “ThreadLocal num&#x3D;5”，而不是 num 一直在累加直到值等于 15</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1	Thread‐0 : ThreadLocal num=1</span><br><span class="line">2	Thread‐1 : ThreadLocal num=1</span><br><span class="line">3	Thread‐0 : ThreadLocal num=2</span><br><span class="line">4	Thread‐0 : ThreadLocal num=3</span><br><span class="line">5	Thread‐1 : ThreadLocal num=2</span><br><span class="line">6	Thread‐2 : ThreadLocal num=1</span><br><span class="line">7	Thread‐0 : ThreadLocal num=4</span><br><span class="line">8	Thread‐2 : ThreadLocal num=2</span><br><span class="line">9	Thread‐1 : ThreadLocal num=3</span><br><span class="line">10	Thread‐1 : ThreadLocal num=4</span><br><span class="line">11	Thread‐2 : ThreadLocal num=3</span><br><span class="line">12	Thread‐0 : ThreadLocal num=5</span><br><span class="line">13	Thread‐2 : ThreadLocal num=4</span><br><span class="line">14	Thread‐2 : ThreadLocal num=5</span><br><span class="line">15	Thread‐1 : ThreadLocal num=5</span><br></pre></td></tr></table></figure>

<h3 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h3><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h2 id="ThreadLocal内存泄漏分析与解决方案"><a href="#ThreadLocal内存泄漏分析与解决方案" class="headerlink" title="ThreadLocal内存泄漏分析与解决方案"></a>ThreadLocal内存泄漏分析与解决方案</h2><h3 id="ThreadLocal造成内存泄漏的原因？"><a href="#ThreadLocal造成内存泄漏的原因？" class="headerlink" title="ThreadLocal造成内存泄漏的原因？"></a>ThreadLocal造成内存泄漏的原因？</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key 为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 </p>
<p>ThreadLocal方法后  好手动调用remove()方法</p>
<h3 id="ThreadLocal内存泄漏解决方案？"><a href="#ThreadLocal内存泄漏解决方案？" class="headerlink" title="ThreadLocal内存泄漏解决方案？"></a>ThreadLocal内存泄漏解决方案？</h3><ul>
<li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li>
<li>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li>
</ul>
<h2 id="并发容器之BlockingQueue详解"><a href="#并发容器之BlockingQueue详解" class="headerlink" title="并发容器之BlockingQueue详解"></a>并发容器之BlockingQueue详解</h2><h3 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>
<p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>
<p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>
<p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>
<p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协</p>
<p>作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，</p>
<p>wait,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而</p>
<p>是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>
<p>阻塞队列使用 经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p>
<h2 id="并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与-LinkedBlockingQueue详解线程池-Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？"><a href="#并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与-LinkedBlockingQueue详解线程池-Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？" class="headerlink" title="并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与 LinkedBlockingQueue详解线程池 Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？"></a>并发容器之ConcurrentLinkedQueue详解与源码分析并发容器之ArrayBlockingQueue与 LinkedBlockingQueue详解线程池 Executors类创建四种常见线程池什么是线程池？有哪几种创建方式？</h2><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 </p>
<p>Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<p>（1）  newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>（2）  newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的 大大小。线程池的大小一旦达到 大值就</p>
<p>会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p>
<p>（3）  newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的 大线程大小。</p>
<p>（4）  newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h3 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h3><ul>
<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li>
<li>提高响应速度。可有效的控制  大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
<li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</li>
</ul>
<h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ul>
<li>RUNNING：这是   正常的状态，接受新的任务，处理等待队列中的任务。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>​          TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 </li>
<li>TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>​           TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h3 id="什么是-Executor-框架？为什么使用-Executor-框架？"><a href="#什么是-Executor-框架？为什么使用-Executor-框架？" class="headerlink" title="什么是 Executor 框架？为什么使用 Executor 框架？"></a>什么是 Executor 框架？为什么使用 Executor 框架？</h3><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的，而且无限制的创建线程会引起应用程序内存溢出。</p>
<p>所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以</p>
<p>回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。</p>
<h3 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h3><ul>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象能执行我们的线程任务。</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
<li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。</li>
</ul>
<h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 </p>
<p>Runnable 和 Callable 类型的任务。</p>
<p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有异常处理：submit()方便Exception处理</p>
<h3 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p>
<h2 id="线程池之ThreadPoolExecutor详解"><a href="#线程池之ThreadPoolExecutor详解" class="headerlink" title="线程池之ThreadPoolExecutor详解"></a>线程池之ThreadPoolExecutor详解</h2><h3 id="Executors和ThreaPoolExecutor创建线程池的区别"><a href="#Executors和ThreaPoolExecutor创建线程池的区别" class="headerlink" title="Executors和ThreaPoolExecutor创建线程池的区别"></a>Executors和ThreaPoolExecutor创建线程池的区别</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p>Executors 各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor:<br>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数 大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li>
</ul>
<p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>
<h3 id="你知道怎么创建线程池吗？"><a href="#你知道怎么创建线程池吗？" class="headerlink" title="你知道怎么创建线程池吗？"></a>你知道怎么创建线程池吗？</h3><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>
<p>ThreadPoolExecutor() 是 原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>
<h3 id="ThreadPoolExecutor构造函数重要参数分析"><a href="#ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="ThreadPoolExecutor构造函数重要参数分析"></a>ThreadPoolExecutor构造函数重要参数分析</h3><p>ThreadPoolExecutor3 个最重要的参数：</p>
<p>corePoolSize ：核心线程数，线程数定义了    小可以同时运行的线程数量。</p>
<p>​             maximumPoolSize ：线程池中允许存在的工作线程的  大数量</p>
<p>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</p>
<p>ThreadPoolExecutor其他常见参数:</p>
<ol>
<li><p>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</p>
</li>
<li><p>unit ：keepAliveTime 参数的时间单位。</p>
</li>
<li><p>threadFactory：为线程池提供创建新线程的线程工厂</p>
</li>
<li><p>handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略 ThreadPoolExecutor饱和策略</p>
</li>
</ol>
<p>ThreadPoolExecutor饱和策略定义:</p>
<p>如果当前同时运行的线程数量达到  大线程数量并且队列也已经被放满了任时，</p>
<p>ThreadPoolTaskExecutor 定义一些策略:</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃 早的未处理的任务请求。</li>
</ul>
<p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 </p>
<p>RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 </p>
<p>ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 </p>
<p>ThreadPoolExecutor.CallerRunsPolicy。当  大池被填满时，此策略为我们提供可</p>
<p>伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="一个简单的线程池Demo-Runnable-ThreadPoolExecutor-线程池实现原理"><a href="#一个简单的线程池Demo-Runnable-ThreadPoolExecutor-线程池实现原理" class="headerlink" title="一个简单的线程池Demo:Runnable+ThreadPoolExecutor 线程池实现原理"></a>一个简单的线程池Demo:Runnable+ThreadPoolExecutor 线程池实现原理</h3><p><img src="/04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89-%E9%87%8D%E7%82%B9.assets/image-20201109203453876.png" alt="image-20201109203453876"></p>
<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 </p>
<p>Demo。</p>
<p>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1 import java.util.Date;</span><br><span class="line">2</span><br><span class="line">3/** </span><br><span class="line">4  * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="line">5  */</span><br><span class="line">6 public class MyRunnable implements Runnable &#123;</span><br><span class="line">7 </span><br><span class="line">8  private String command;</span><br><span class="line">9 </span><br><span class="line">10  public MyRunnable(String s) &#123; </span><br><span class="line">11  this.command = s;</span><br><span class="line">12  &#125;</span><br><span class="line">13</span><br><span class="line">14  @Override </span><br><span class="line">15  public void run() &#123; </span><br><span class="line">16  System.out.println(Thread.currentThread().getName() + &quot; Start. Time = &quot; + new Date()); </span><br><span class="line">17  processCommand();</span><br><span class="line">18  System.out.println(Thread.currentThread().getName() + &quot; End. Time = &quot; + new Date()); </span><br><span class="line">19  &#125;</span><br><span class="line">20 </span><br><span class="line">21  private void processCommand() &#123;</span><br><span class="line">22  try &#123;</span><br><span class="line">23  Thread.sleep(5000);</span><br><span class="line">24  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">25  e.printStackTrace(); </span><br><span class="line">26  &#125; </span><br><span class="line">27  &#125;</span><br><span class="line">28 </span><br><span class="line">29  @Override</span><br><span class="line">30  public String toString() &#123; </span><br><span class="line">31  return this.command;</span><br><span class="line">32  &#125;</span><br><span class="line">33 &#125; </span><br></pre></td></tr></table></figure>

<p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1 import java.util.concurrent.ArrayBlockingQueue; </span><br><span class="line">2 import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">3 import java.util.concurrent.TimeUnit;</span><br><span class="line">4 </span><br><span class="line">5 public class ThreadPoolExecutorDemo &#123;</span><br><span class="line">6</span><br><span class="line">7  private static final int CORE_POOL_SIZE = 5;</span><br><span class="line">8  private static final int MAX_POOL_SIZE = 10; </span><br><span class="line">9  private static final int QUEUE_CAPACITY = 100;</span><br><span class="line">10  private static final Long KEEP_ALIVE_TIME = 1L; </span><br><span class="line">11  public static void main(String[] args) &#123;</span><br><span class="line">12</span><br><span class="line">13  //使用阿里巴巴推荐的创建线程池的方式</span><br><span class="line">14  //通过ThreadPoolExecutor构造函数自定义参数创建 </span><br><span class="line">15  ThreadPoolExecutor executor = new ThreadPoolExecutor( </span><br><span class="line">16  CORE_POOL_SIZE, </span><br><span class="line">17  MAX_POOL_SIZE, </span><br><span class="line">18  KEEP_ALIVE_TIME, </span><br><span class="line">19  TimeUnit.SECONDS,</span><br><span class="line">20  new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), </span><br><span class="line">21  new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">22</span><br><span class="line">23  for (int i = 0; i &lt; 10; i++) &#123; </span><br><span class="line">24  //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">25  Runnable worker = new MyRunnable(&quot;&quot; + i); </span><br><span class="line">26  //执行Runnable </span><br><span class="line">27  executor.execute(worker);</span><br><span class="line">28  &#125; </span><br><span class="line">29  //终止线程池 </span><br><span class="line">30  executor.shutdown(); </span><br><span class="line">31  while (!executor.isTerminated()) &#123; </span><br><span class="line">32  &#125; </span><br><span class="line">33  System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">34  &#125;</span><br><span class="line">35 &#125; </span><br></pre></td></tr></table></figure>

<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><p>corePoolSize: 核心线程数为 5。</p>
</li>
<li><p>maximumPoolSize ：   大线程数 10</p>
</li>
<li><p>keepAliveTime : 等待时间为 1L。</p>
</li>
<li><p>unit: 等待时间的单位为 TimeUnit.SECONDS。</p>
</li>
<li><p>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</p>
</li>
</ol>
<p>handler:饱和策略为 CallerRunsPolicy。 Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1	pool‐1‐thread‐2 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">2	pool‐1‐thread‐5 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">3	pool‐1‐thread‐4 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">4	pool‐1‐thread‐1 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">5	pool‐1‐thread‐3 Start. Time = Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">6	pool‐1‐thread‐5 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">7	pool‐1‐thread‐3 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">8	pool‐1‐thread‐2 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">9	pool‐1‐thread‐4 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">10	pool‐1‐thread‐1 End. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">11	pool‐1‐thread‐2 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">12	pool‐1‐thread‐1 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">13	pool‐1‐thread‐4 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">14	pool‐1‐thread‐3 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">15	pool‐1‐thread‐5 Start. Time = Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">16	pool‐1‐thread‐2 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">17	pool‐1‐thread‐3 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">18	pool‐1‐thread‐4 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">19	pool‐1‐thread‐5 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">20	pool‐1‐thread‐1 End. Time = Tue Nov 12 20:59:54 CST 2019</span><br></pre></td></tr></table></figure>

<h2 id="线程池之ScheduledThreadPoolExecutor详解-FutureTask详解原子操作类"><a href="#线程池之ScheduledThreadPoolExecutor详解-FutureTask详解原子操作类" class="headerlink" title="线程池之ScheduledThreadPoolExecutor详解 FutureTask详解原子操作类"></a>线程池之ScheduledThreadPoolExecutor详解 FutureTask详解原子操作类</h2><h3 id="什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？"></a>什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？</h3><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。</p>
<p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p>
<p>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——</p>
<p>Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持</p>
<p>CAS 的原子操作。</p>
<p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用</p>
<p>同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p>
<p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。</p>
<p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，</p>
<p>AtomicReference</p>
<p>原子数组：AtomicIntegerArray，AtomicLongArray，</p>
<p>AtomicReferenceArray</p>
<p>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，</p>
<p>AtomicReferenceFieldUpdater</p>
<p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个</p>
<p>boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）说一下 atomic 的原理？</p>
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个</p>
<p>（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>
<p>AtomicInteger 类的部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><br><span class="line">2	private static final Unsafe unsafe = Unsafe.getUnsafe(); 3 private static final long valueOffset;</span><br><span class="line">4</span><br><span class="line">5	static &#123;</span><br><span class="line">6	try &#123;</span><br><span class="line">7	valueOffset = unsafe.objectFieldOffset</span><br><span class="line">8	(AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">9	&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">10	&#125;</span><br><span class="line">11</span><br><span class="line">12 private volatile int value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。</p>
<p>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个</p>
<p>volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的 新值。</p>
<h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h2 id="并发工具之CountDownLatch与CyclicBarrier"><a href="#并发工具之CountDownLatch与CyclicBarrier" class="headerlink" title="并发工具之CountDownLatch与CyclicBarrier"></a>并发工具之CountDownLatch与CyclicBarrier</h2><h3 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h3><p>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li>
<li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>
<li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入 barrierAction，指定当所有线程都到达时执行的业务功能；</li>
<li>CountDownLatch是不能复用的，而CyclicLatch是可以复用的。</li>
</ul>
<h2 id="并发工具之Semaphore与Exchanger"><a href="#并发工具之Semaphore与Exchanger" class="headerlink" title="并发工具之Semaphore与Exchanger"></a>并发工具之Semaphore与Exchanger</h2><h3 id="Semaphore-有什么作用"><a href="#Semaphore-有什么作用" class="headerlink" title="Semaphore 有什么作用"></a>Semaphore 有什么作用</h3><p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。</p>
<p>Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码 多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p>
<p>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 </p>
<p>ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量) 可以指定多个线程同时访问某个资源。</p>
<h3 id="什么是线程间交换数据的工具Exchanger"><a href="#什么是线程间交换数据的工具Exchanger" class="headerlink" title="什么是线程间交换数据的工具Exchanger"></a>什么是线程间交换数据的工具Exchanger</h3><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供</p>
<p>了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过 exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p>
<h3 id="常用的并发工具类有哪些？"><a href="#常用的并发工具类有哪些？" class="headerlink" title="常用的并发工具类有哪些？"></a>常用的并发工具类有哪些？</h3><ul>
<li>Semaphore(信号量)-允许多个线程同时访问： synchronized 和ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li>CountDownLatch(倒计时器)： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li>CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到 后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 </li>
<li>CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h1 id="并发实践"><a href="#并发实践" class="headerlink" title="并发实践"></a>并发实践</h1>
      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="善善332">
      <meta itemprop="description" content="运气和努力一样重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和善寺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 15:01:16" itemprop="dateCreated datePublished" datetime="2022-10-12T15:01:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 13:51:22" itemprop="dateModified" datetime="2021-03-03T13:51:22+08:00">2021-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java异常架构与异常关键字"><a href="#Java异常架构与异常关键字" class="headerlink" title="Java异常架构与异常关键字"></a>Java异常架构与异常关键字</h1><h2 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。</p>
<p>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答 what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</p>
<h2 id="Java异常架构"><a href="#Java异常架构" class="headerlink" title="Java异常架构"></a>Java异常架构</h2><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/Java%E5%BC%82%E5%B8%B8.png" alt="Java异常"></p>
<h3 id="1-Throwable"><a href="#1-Throwable" class="headerlink" title="1. Throwable"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<h3 id="2-Error（错误）"><a href="#2-Error（错误）" class="headerlink" title="2. Error（错误）"></a>2. Error（错误）</h3><p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual </p>
<p>MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）</p>
<p>等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不</p>
<p>应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h3 id="3-Exception（异常）"><a href="#3-Exception（异常）" class="headerlink" title="3. Exception（异常）"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
<p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、</p>
<p>ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛</p>
<p>出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><p>定义: Exception 中除 RuntimeException 及其子类之外的异常。</p>
<p>特点: Java 编译器会检查它。如果程序中出现此类异常，比如 </p>
<p>ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p>
<h3 id="4-受检异常与非受检异常"><a href="#4-受检异常与非受检异常" class="headerlink" title="4. 受检异常与非受检异常"></a>4. 受检异常与非受检异常</h3><p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常</p>
<p>（unchecked exception）。</p>
<h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h4><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合</p>
<p>预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 </p>
<p>RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p>
<h4 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h4><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException极其子类）和错误(Error)</p>
<h2 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h2><p>• try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p>
<p>• catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p>
<p>• finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了 return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p>
<p>• throw – 用于抛出异常。</p>
<p>• throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109173809704.png" alt="image-20201109173809704"></p>
<p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对</p>
<p>象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、 catch、throw、throws 和 finally。</p>
<p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p>
<h2 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下</p>
<p>去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意</p>
<p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/clip_image001-1604914706296.gif" alt="img"> 非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</p>
<p>​         <img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/clip_image002-1604914706296.gif" alt="img"> 一个方法出现编译时异常，就需要 try-catch&#x2F; throws 处理，否则会导致编译错误</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。 throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。如何选择异常类型</p>
<p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p>
<p><img src="/03-Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89.assets/image-20201109173855168.png" alt="image-20201109173855168"></p>
<h2 id="常见异常处理方式直接抛出异常"><a href="#常见异常处理方式直接抛出异常" class="headerlink" title="常见异常处理方式直接抛出异常"></a>常见异常处理方式直接抛出异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws IOException &#123; </span><br><span class="line">2 File file = new File(filePath);</span><br><span class="line">3 String result; </span><br><span class="line">4 BufferedReader reader = new BufferedReader(new FileReader(file)); </span><br><span class="line">5 while((result = reader.readLine())!=null) &#123; </span><br><span class="line">6 System.out.println(result);</span><br><span class="line">7	&#125;</span><br><span class="line">8	reader.close();</span><br><span class="line">9	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws MyException &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// code</span><br><span class="line">4 &#125; catch (IOException e) &#123;</span><br><span class="line">5	MyException ex = new MyException(&quot;read file failed.&quot;);</span><br><span class="line">6	ex.initCause(e);</span><br><span class="line">7	throw ex;</span><br><span class="line">8	&#125;</span><br><span class="line">9	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	private static void readFile(String filePath) &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// code</span><br><span class="line">4	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">5	// handle FileNotFoundException</span><br><span class="line">6 &#125; catch (IOException e)&#123;</span><br><span class="line">7	// handle IOException</span><br><span class="line">8	&#125;</span><br><span class="line">9	&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	private static void readFile(String filePath) &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// code</span><br><span class="line">4	&#125; catch (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">5	// handle FileNotFoundException or UnknownHostException</span><br><span class="line">6 &#125; catch (IOException e)&#123;</span><br><span class="line">7	// handle IOException</span><br><span class="line">8	&#125;</span><br><span class="line">9	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详</p>
<p>细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	public class MyException extends Exception &#123;</span><br><span class="line">2	public MyException()&#123; &#125;</span><br><span class="line">3	public MyException(String msg)&#123;</span><br><span class="line">4	super(msg);</span><br><span class="line">5	&#125;</span><br><span class="line">6	// ...</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1 private static void readFile(String filePath) throws MyException &#123; </span><br><span class="line">2  File file = new File(filePath); </span><br><span class="line">3  String result;</span><br><span class="line">4  BufferedReader reader = null; </span><br><span class="line">5  try &#123; </span><br><span class="line">6  reader = new BufferedReader(new FileReader(file)); </span><br><span class="line">7  while((result = reader.readLine())!=null) &#123;</span><br><span class="line">8  System.out.println(result); </span><br><span class="line">9  &#125; </span><br><span class="line">10  &#125; catch (IOException e) &#123;</span><br><span class="line">11  System.out.println(&quot;readFile method catch block.&quot;); </span><br><span class="line">12  MyException ex = new MyException(&quot;read file failed.&quot;); </span><br><span class="line">13  ex.initCause(e);</span><br><span class="line">14  throw ex; </span><br><span class="line">15  &#125; finally &#123; </span><br><span class="line">16  System.out.println(&quot;readFile method finally block.&quot;);</span><br><span class="line">17  if (null != reader) &#123; </span><br><span class="line">18  try &#123;</span><br><span class="line">19  reader.close(); </span><br><span class="line">20  &#125; catch (IOException e) &#123;</span><br><span class="line">21  e.printStackTrace(); </span><br><span class="line">22  &#125; </span><br><span class="line">23  &#125;</span><br><span class="line">24  &#125; </span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入  finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入  finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。 若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码 中的 catch 子句修改如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 catch (IOException e) &#123; </span><br><span class="line">2  System.out.println(&quot;readFile method catch block.&quot;);</span><br><span class="line">3  return; </span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是 否执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 readFile method catch block. </span><br><span class="line">2 readFile method finally block.</span><br></pre></td></tr></table></figure>

<p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p>
<h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	private static void tryWithResourceTest()&#123;</span><br><span class="line">2	try (Scanner scanner = new Scanner(new FileInputStream(&quot;c:/abc&quot;),&quot;UTF8&quot;))&#123;</span><br><span class="line">3	// code</span><br><span class="line">4 &#125; catch (IOException e)&#123;</span><br><span class="line">5	// handle exception</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h1 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h1><h2 id="1-Error-和-Exception-区别是什么？"><a href="#1-Error-和-Exception-区别是什么？" class="headerlink" title="1. Error 和 Exception 区别是什么？"></a>1. Error 和 Exception 区别是什么？</h2><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出 等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕 获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复； </p>
<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错 误，应对其进行处理，使应用程序可以继续正常运行。 </p>
<h2 id="2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="2. 运行时异常和一般异常(受检异常)区别是什么？"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h2><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出 现的异常。 Java 编译器不会检查运行时异常。 </p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编 译器会检查受检异常。 </p>
<p><strong>RuntimeException异常和受检异常之间的区别：</strong>是否强制要求调用者必须处 理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建 议使用RuntimeException异常。 </p>
<h2 id="3-JVM-是如何处理异常的？"><a href="#3-JVM-是如何处理异常的？" class="headerlink" title="3. JVM 是如何处理异常的？"></a>3. JVM 是如何处理异常的？</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM， 该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常 对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，终才进 入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常 处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如 果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异 常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并 终止应用程序。 </p>
<h2 id="4-throw-和-throws-的区别是什么？"><a href="#4-throw-和-throws-的区别是什么？" class="headerlink" title="4. throw 和 throws 的区别是什么？"></a>4. throw 和 throws 的区别是什么？</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出 异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法 内部通过 throw 拋出异常对象。 </p>
<p>**throws 关键字和 throw 关键字在使用上的几点区别如下： **</p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中 的异常，受查异常和非受查异常都可以被抛出。 </li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出 的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中 必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异 常。</li>
</ul>
<h2 id="5-final、finally、finalize-有什么区别？"><a href="#5-final、finally、finalize-有什么区别？" class="headerlink" title="5. final、finally、finalize 有什么区别？"></a>5. final、finally、finalize 有什么区别？</h2><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方 法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 </li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执 行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用 来存放一些关闭资源的代码。 </li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类， Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的 清理工作。</li>
</ul>
<h2 id="6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="6. NoClassDefFoundError 和  ClassNotFoundException 区别？"></a>6. NoClassDefFoundError 和  ClassNotFoundException 区别？</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该 尝试捕获这个异常。 </p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类 的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到 了，可能是变异后被删除了等原因导致； </p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其 进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用  Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动 态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中， 另一个加载器又尝试去加载它。 </p>
<h2 id="7-try-catch-finally-中哪个部分可以省略？"><a href="#7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="7. try-catch-finally 中哪个部分可以省略？"></a>7. try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略 </p>
<p>**原因 **</p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时 异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处 理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch可以省略，你加上catch编译器也觉得无可厚非。 </p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对 所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛 出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾 处理，或者加上catch捕获以便进一步处理。 </p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。  </p>
<h2 id="8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？"><a href="#8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？" class="headerlink" title="8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？"></a>8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</h2><p>答：会执行，在 return 前执行。 </p>
<p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块， try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块 执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会 返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的 困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也 可以通过提升编译器的语法检查级别来产生警告或错误。 </p>
<p><strong>代码示例1：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public static int getInt() &#123; </span><br><span class="line">2  int a = 10; </span><br><span class="line">3  try &#123;</span><br><span class="line">4  System.out.println(a / 0); </span><br><span class="line">5  a = 20; </span><br><span class="line">6  &#125; catch (ArithmeticException e) &#123; </span><br><span class="line">7  a = 30; </span><br><span class="line">8  return a; </span><br><span class="line">9  /* </span><br><span class="line">10  * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返 回路径就形成了 </span><br><span class="line">11  * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 </span><br><span class="line">12  * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量 了，而是常量30 </span><br><span class="line">13  */ </span><br><span class="line">14  &#125; finally &#123; </span><br><span class="line">15  a = 40; </span><br><span class="line">16  &#125; </span><br><span class="line">17  return a; </span><br><span class="line">18 &#125; </span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong>30 </p>
<p><strong>代码示例2：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 public static int getInt() &#123; </span><br><span class="line">2  int a = 10; </span><br><span class="line">3  try &#123; </span><br><span class="line">4  System.out.println(a / 0); </span><br><span class="line">5  a = 20; </span><br><span class="line">6  &#125; catch (ArithmeticException e) &#123; </span><br><span class="line">7  a = 30; </span><br><span class="line">8  return a; </span><br><span class="line">9  &#125; finally &#123; </span><br><span class="line">10  a = 40; </span><br><span class="line">11  //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直 接返回40 </span><br><span class="line">12  return a; </span><br><span class="line">13  &#125;</span><br><span class="line">14 </span><br><span class="line">15 &#125; </span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong>40  </p>
<h2 id="9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。"><a href="#9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。" class="headerlink" title="9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。"></a>9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</h2><p>有如下代码片断： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 try &#123; </span><br><span class="line">2  throw new ExampleB(&quot;b&quot;) </span><br><span class="line">3 &#125; catch（ExampleA e）&#123; </span><br><span class="line">4  System.out.println(&quot;ExampleA&quot;); </span><br><span class="line">5 &#125; catch（Exception e）&#123; </span><br><span class="line">6  System.out.println(&quot;Exception&quot;); </span><br><span class="line">7 &#125; </span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？ </p>
<p><strong>答：</strong> </p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类 型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB  类型的异常） </p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 class Annoyance extends Exception &#123; </span><br><span class="line">2 &#125; </span><br><span class="line">3 class Sneeze extends Annoyance &#123; </span><br><span class="line">4 &#125; </span><br><span class="line">5 class Human &#123; </span><br><span class="line">6  public static void main(String[] args) </span><br><span class="line">7  throws Exception &#123; </span><br><span class="line">8  try &#123; </span><br><span class="line">9  try &#123; </span><br><span class="line">10  throw new Sneeze(); </span><br><span class="line">11  &#125; catch ( Annoyance a ) &#123; </span><br><span class="line">12  System.out.println(&quot;Caught Annoyance&quot;); </span><br><span class="line">13  throw a; </span><br><span class="line">14  &#125; </span><br><span class="line">15  &#125; catch ( Sneeze s ) &#123; </span><br><span class="line">16  System.out.println(&quot;Caught Sneeze&quot;); </span><br><span class="line">17  return ; </span><br><span class="line">18  &#125; finally &#123; </span><br><span class="line">19  System.out.println(&quot;Hello World!&quot;); </span><br><span class="line">20  &#125; </span><br><span class="line">21  &#125; </span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Caught Annoyance </span><br><span class="line">2 Caught Sneeze </span><br><span class="line">3 Hello World! </span><br></pre></td></tr></table></figure>

<h2 id="10-常见的-RuntimeException-有哪些？"><a href="#10-常见的-RuntimeException-有哪些？" class="headerlink" title="10. 常见的 RuntimeException 有哪些？"></a>10. 常见的 RuntimeException 有哪些？</h2><ul>
<li>ClassCastException(类转换异常) </li>
<li>IndexOutOfBoundsException(数组越界) </li>
<li>NullPointerException(空指针) </li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致) </li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<h2 id="11-Java常见异常有哪些"><a href="#11-Java常见异常有哪些" class="headerlink" title="11. Java常见异常有哪些"></a>11. Java常见异常有哪些</h2><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时,抛出该异常</p>
<h1 id="Java异常处理最佳实践"><a href="#Java异常处理最佳实践" class="headerlink" title="Java异常处理最佳实践"></a>Java异常处理最佳实践</h1><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。本文给出几个被很多团队使用的异常处理 佳实践。</p>
<h2 id="1-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#1-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="1. 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>1. 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在 try块的 后关闭资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1	public void doNotCloseResourceInTry() &#123;</span><br><span class="line">2	FileInputStream inputStream = null;</span><br><span class="line">3	try &#123;</span><br><span class="line">4	File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">5	inputStream = new FileInputStream(file);</span><br><span class="line">6	// use the inputStream to read a file</span><br><span class="line">7	// do NOT do this</span><br><span class="line">8	inputStream.close();</span><br><span class="line">9	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">10	log.error(e);</span><br><span class="line">11	&#125; catch (IOException e) &#123;</span><br><span class="line">12	log.error(e);</span><br><span class="line">13	&#125;</span><br><span class="line">14	&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的  后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<h3 id="1-1-使用-finally-代码块"><a href="#1-1-使用-finally-代码块" class="headerlink" title="1.1 使用 finally 代码块"></a>1.1 使用 finally 代码块</h3><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功</p>
<p>执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 public void closeResourceInFinally() &#123; </span><br><span class="line">2  FileInputStream inputStream = null; </span><br><span class="line">3  try &#123; </span><br><span class="line">4  File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">5  inputStream = new FileInputStream(file); </span><br><span class="line">6  // use the inputStream to read a file</span><br><span class="line">7  &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">8  log.error(e);</span><br><span class="line">9  &#125; finally &#123;</span><br><span class="line">10  if (inputStream != null) &#123; </span><br><span class="line">11  try &#123; </span><br><span class="line">12  inputStream.close(); </span><br><span class="line">13  &#125; catch (IOException e) &#123; </span><br><span class="line">14  log.error(e); </span><br><span class="line">15  &#125; </span><br><span class="line">16  &#125; </span><br><span class="line">17  &#125;</span><br><span class="line">18 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Java-7-的-try-with-resource-语法"><a href="#1-2-Java-7-的-try-with-resource-语法" class="headerlink" title="1.2 Java 7 的 try-with-resource 语法"></a>1.2 Java 7 的 try-with-resource 语法</h3><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1	public void automaticallyCloseResource() &#123;</span><br><span class="line">2	File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">3	try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">4	// use the inputStream to read a file</span><br><span class="line">5	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">6	log.error(e);</span><br><span class="line">7 &#125; catch (IOException e) &#123;</span><br><span class="line">8	log.error(e);</span><br><span class="line">9	&#125;</span><br><span class="line">10	&#125;</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<h2 id="2-优先明确的异常"><a href="#2-优先明确的异常" class="headerlink" title="2. 优先明确的异常"></a>2. 优先明确的异常</h2><p>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</p>
<p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。因此，总是尝试寻找 适合你的异常事件的类，例如，抛出一个 </p>
<p>NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 public void doNotDoThis() throws Exception &#123;</span><br><span class="line">2 ...</span><br><span class="line">3	&#125;</span><br><span class="line">4	public void doThis() throws NumberFormatException &#123; </span><br><span class="line">5 ...</span><br><span class="line">6 &#125;</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="3-对异常进行文档说明"><a href="#3-对异常进行文档说明" class="headerlink" title="3. 对异常进行文档说明"></a>3. 对异常进行文档说明</h2><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p>
<p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 public void doSomething(String input) throws MyBusinessException &#123; </span><br><span class="line">2 ...</span><br><span class="line">3 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-使用描述性消息抛出异常"><a href="#4-使用描述性消息抛出异常" class="headerlink" title="4. 使用描述性消息抛出异常"></a>4. 使用描述性消息抛出异常</h2><p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>
<p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1	try &#123;</span><br><span class="line">2	new Long(&quot;xyz&quot;);</span><br><span class="line">3 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">4	log.error(e);</span><br><span class="line">5	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-优先捕获最具体的异常"><a href="#5-优先捕获最具体的异常" class="headerlink" title="5. 优先捕获最具体的异常"></a>5. 优先捕获最具体的异常</h2><p>大多数 IDE 都可以帮助你实现这个  佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获</p>
<p>IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。总是优先捕获  具体的异常类，并将不太具体的 catch 块添加到列表的末尾。你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非</p>
<p>NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public void catchMostSpecificExceptionFirst() &#123; </span><br><span class="line">2  try &#123;</span><br><span class="line">3  doSomething(&quot;A message&quot;);</span><br><span class="line">4	&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5	log.error(e);</span><br><span class="line">6	&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">7	log.error(e)</span><br><span class="line">8	&#125;</span><br><span class="line">9	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-不要捕获-Throwable-类"><a href="#6-不要捕获-Throwable-类" class="headerlink" title="6. 不要捕获 Throwable 类"></a>6. 不要捕获 Throwable 类</h2><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你</p>
<p>永远不应该这样做！</p>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以， 好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	public void doNotCatchThrowable() &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// do something</span><br><span class="line">4	&#125; catch (Throwable t) &#123;</span><br><span class="line">5 // don&#x27;t do this!</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-不要忽略异常"><a href="#7-不要忽略异常" class="headerlink" title="7. 不要忽略异常"></a>7. 不要忽略异常</h2><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	public void doNotIgnoreExceptions() &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5	// this will never happen</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。合理的做法是至少要记录异常的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1	public void logAnException() &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5	log.error(&quot;This should never happen: &quot; + e);</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-不要记录并抛出异常"><a href="#8-不要记录并抛出异常" class="headerlink" title="8. 不要记录并抛出异常"></a>8. 不要记录并抛出异常</h2><p>这可能是本文中 常被忽略的  佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1	try &#123;</span><br><span class="line">2	new Long(&quot;xyz&quot;);</span><br><span class="line">3 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">4	log.error(e);</span><br><span class="line">5	throw e;</span><br><span class="line">6	&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 17:44:28,945 ERROR TestExceptionHandling:65 ‐ java.lang.NumberFormatExcep tion: For input string: &quot;xyz&quot; </span><br><span class="line">2 Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input str ing: &quot;xyz&quot; </span><br><span class="line">3 at java.lang.NumberFormatException.forInputString(NumberFormatException.j ava:65)</span><br><span class="line">4 at java.lang.Long.parseLong(Long.java:589) </span><br><span class="line">5 at java.lang.Long.(Long.java:965) </span><br><span class="line">6 at com.stackify.example.TestExceptionHandling.logAndThrowException(TestEx ceptionHandling.java:63) </span><br><span class="line">7 at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:5</span><br><span class="line">8)</span><br></pre></td></tr></table></figure>

<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">3	// do something</span><br><span class="line">4	&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5	throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>

<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>
<h2 id="9-包装异常时不要抛弃原始的异常"><a href="#9-包装异常时不要抛弃原始的异常" class="headerlink" title="9. 包装异常时不要抛弃原始的异常"></a>9. 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。</p>
<p>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 </p>
<p>NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的</p>
<p>构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">2	try &#123;</span><br><span class="line">3	// do something</span><br><span class="line">4 &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">5	throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br><span class="line">6	&#125;</span><br><span class="line">7	&#125;</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h2 id="10-不要使用异常控制程序的流程"><a href="#10-不要使用异常控制程序的流程" class="headerlink" title="10. 不要使用异常控制程序的流程"></a>10. 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p>
<h2 id="11-使用标准异常"><a href="#11-使用标准异常" class="headerlink" title="11. 使用标准异常"></a>11. 使用标准异常</h2><p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</p>
<h2 id="12-异常会影响性能"><a href="#12-异常会影响性能" class="headerlink" title="12. 异常会影响性能"></a>12. 异常会影响性能</h2><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p>
<ul>
<li>仅在异常情况下使用异常；</li>
<li>在可恢复的异常情况下使用异常；尽管使用异常有利于 Java 开发，但是在应用中  好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</li>
</ul>
<h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个 佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<h2 id="异常处理-阿里巴巴Java开发手册"><a href="#异常处理-阿里巴巴Java开发手册" class="headerlink" title="异常处理-阿里巴巴Java开发手册"></a>异常处理-阿里巴巴Java开发手册</h2><ol>
<li>【强制】Java 类库中定义的可以通过预检查方式规避的</li>
</ol>
<p>RuntimeException异常不应该通过catch 的方式来处理，比如：</p>
<p>NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj !&#x3D; null) {…} 反例：try { obj.method(); } catch </p>
<p>(NullPointerException e) {…}</p>
<ol start="2">
<li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p>
</li>
<li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，</p>
</li>
</ol>
<p>再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p>
<ol start="4">
<li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。 外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p>
</li>
<li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p>
</li>
<li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p>
</li>
<li><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1	private int x = 0;</span><br><span class="line">2	public int checkReturn() &#123;</span><br><span class="line">3	try &#123;</span><br><span class="line">4	// x等于1，此处不返回</span><br><span class="line">5	return ++x;</span><br><span class="line">6	&#125; finally &#123;</span><br><span class="line">7	// 返回的结果是2</span><br><span class="line">8	return ++x;</span><br><span class="line">9	&#125;</span><br><span class="line">10	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p>
</li>
<li><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出</p>
</li>
</ol>
<p>NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：</p>
<p>ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p>
<ol start="3">
<li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p>
</li>
<li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用</p>
</li>
</ol>
<p>obj.getA().getB().getC()；一连串调用，易产生NPE。</p>
<p>正例：使用JDK8的Optional类来防止NPE问题。</p>
<ol start="5">
<li>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new</li>
</ol>
<p>RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：</p>
<p>DAOException &#x2F; ServiceException等。</p>
<ol start="6">
<li><p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p>
</li>
<li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {…}</p>
</li>
</ol>

      
    </div>

    
    
    

       
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="善善332"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">善善332</p>
  <div class="site-description" itemprop="description">运气和努力一样重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CHl332" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CHl332" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2541621686@qq.com" title="E-Mail → mailto:2541621686@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/mywechat.jpg" title="Wechar → &#x2F;images&#x2F;mywechat.jpg"><i class="fa-weixin fa-fw"></i>Wechar</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/shanshan3.32/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;shanshan3.32&#x2F;" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.yuque.com/docs/share/4fda01be-199a-4d34-aa02-eb4960d4fa2b#%20%E3%80%8ASpringCloud%E3%80%8B" title="YuQue → https:&#x2F;&#x2F;www.yuque.com&#x2F;docs&#x2F;share&#x2F;4fda01be-199a-4d34-aa02-eb4960d4fa2b?# 《SpringCloud》" rel="noopener" target="_blank"><i class="fa-file-text fa-fw"></i>YuQue</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://funnylog.gitee.io/mysql45/iframe/" title="https:&#x2F;&#x2F;funnylog.gitee.io&#x2F;mysql45&#x2F;iframe&#x2F;" rel="noopener" target="_blank">MySQL45讲</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fishc.com.cn/" title="https:&#x2F;&#x2F;fishc.com.cn" rel="noopener" target="_blank">鱼C论坛</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-09 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">善善332</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


<!-- 自定义加上的 -->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共255.2k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>

<script type="text/javascript">
var OriginTitile = document.title,
    st;
document.addEventListener("visibilitychange", function () {
    document.hidden ? (document.title = "暂时离开一下", clearTimeout(st)) : (document.title =
        "回来了O(∩_∩)O~", st = setTimeout(function () {
            document.title = OriginTitile
        }, 3e3))
})
</script>
</html>
